# [Mastering Embedded Linux Programming](https://www.amazon.com/Mastering-Embedded-Linux-Programming-potential/dp/1789530385/ref=sr_1_3?keywords=9781789530384&qid=1661185260&sr=8-3)
<img alt="9781789530384" src="../covers/9781789530384.jpg" width="200"/>

> This is the most accurate, complete, and comprehensive resource to
> use for diving into the depth of Embedded Linux.
> Note that this is not a one time read, you are going to need it for a while.

## Chapter 1/19

<details>
<summary>Specify the life cycle of Embedded Linux projects:</summary>

1. Board Bring-Up
1. System Architecture and Design Choice
1. Writing Embedded Applications
1. Debugging and Optimizing Performance
</details>

<details>
<summary>Specify the five elements of Embedded Linux:</summary>

1. Toolchain
1. Bootloader
1. Kernel
1. Root filesystem
1. Embedded Applications
</details>

<details>
<summary>Specify hardware requirements for Embedded Linux:</summary>

1. CPU architecture
1. Reasonable amout of RAM
1. Non-volatile storage
1. Serial port
1. Debugging interface (e.g. JTAG)
</details>

## Chapter 2/19

<details>
<summary>Packages required for working on an Embedded Linux project:</summary>

```sh
sudo pacman -S base-devel bzip2 cmake git gperf help2man ncurses python rsync unzip wget xz
```
</details>

[LLVM support for kernel build](https://kernel.org/doc/html/latest/kbuild/llvm.html)
<details>
<summary>GNU toolchain consist of three main components</summary>

* binutils **(base-devel)**: [https://gnu.org/software/binutils](https://gnu.org/software/binutils)
* gcc **(base-devel)**: [https://gcc.gnu.org](https://gcc.gnu.org)
* C library + Linux header files
</details>

<details>
<summary>GNU prefixes a tuple for toolchanins combined with four components:</summary>

* CPU Architecture + Endianness (e.g. `x86_64`, `mipsel`, `armeb`)
* Vendor (e.g. `buildroot`)
* Kernel (e.g. `linux`)
* Operating System + ABI (e.g. `gnueabi`, `gnueabihf`, `musleabi`, `musleabihf`)

```sh
gcc -dumpmachine
```
</details>
<details>
<summary>C libraries used in toolchains:</summary>

* glibc: [https://gnu.org/software/libc](https://gnu.org/software/libs)
* musl libs: [https://musl.libc.org](https://musl.libc.org)
* uClibc-ng: [https://uclibc-ng.org](https://uclibc-ng.org)
* eglibc: [https://uclibc.org/home](https://uclibc.org/home)

</details>

<details>
<summary>Toolchain can be completely built manually by [Cross Linux From Scratch](https://trac.clfs.org).</summary>

</details>

<details>
<summary>Another alternative to build toolchains is [crosstool-NG](https://crosstool-ng.github.io).</summary>

</details>

<details>
<summary>crosstool-ng installation process:</summary>

```sh
git clone https://github.com/crosstool-ng/crosstool-ng.git
cd crosstool-ng
git checkout <latest>
./bootstrap
./configure --enable-local
make -j<cores>
```
</details>

<details>
<summary>List sample configurations of toolchains using crosstool-ng:</summary>

```sh
./ct-ng list-samples
```
</details>

<details>
<summary>Inspect details of a toolchain sample configuration using crosstool-ng:</summary>

```sh
./ct-ng show-<sample>
./ct-ng show-armv6-unknown-linux-gnueabihf
./ct-ng show-arm-cortex_a8-linux-gnueabi
./ct-ng show-arm-unknown-linux-gnueabi
```
</details>

<details>
<summary>Building a toolchain for Raspberry Pi Zero:</summary>

```sh
./ct-ng distclean
./ct-ng show-armv6-unknown-linux-gnueabihf
./ct-ng armv6-unknown-linux-gnueabihf
```

Change following parts:

* Tarbal path
* Build path
* Vendor tuple

```sh
./ct-ng build
```
</details>

<details>
<summary>Building a toolchain for BeagleBone Black:</summary>

```sh
./ct-ng distclean
./ct-ng show-arm-cortex_a8-linux-gnueabi
./ct-ng arm-cortex_a8-linux-gnueabi
```

Change following parts:

* **Paths and misc options** >> **Render the toolchain read-only**: disable
* **Target options** >> **Floating point**: **hardware (FPU)**
* **Target options** >> **Use specific FPU**: neon

```sh
./ct-ng build
```
</details>

<details>
<summary>Building a toolchain for QEMU:</summary>

```sh
./ct-ng distclean
./ct-ng show-arm-unknown-linux-gnueai
./ct-ng arm-unknown-linux-gnueai
```

Change following parts:

* **Paths and misc options**: disable **Render the toolchain read-only**

```sh
./ct-ng build
```
</details>

<details>
<summary>Inspect compiler configurations in toolchain:</summary>

```sh
${CROSS_COMPILE}gcc -v
```
</details>

<details>
<summary>Override default compiler options in build:</summary>

```sh
${CROSS_COMPILE}gcc -mcpu=cortex-a5 main.c -o app
```
</details>

<details>
<summary>Inspect architecture specific options of compiler:</summary>

```sh
${CROSS_COMPILE}gcc --target-help
```
</details>

<details>
<summary>Inspect the sysroot path of compiler in toolchain:</summary>

```sh
${CROSS_COMPILE}gcc -print-sysroot
```
</details>

<details>
<summary>C library components:</summary>

* libc (linked by default)
* libm
* libpthread
* librt
</details>

<details>
<summary>Inspect linked libraries of an executable:</summary>

```sh
${CROSS_COMPILE}readelf -a app | grep "Shared library"
```
</details>

<details>
<summary>Inspect the runtime linker used for an executable:</summary>

```sh
${CROSS_COMPILE}readelf -a app | grep "program interpreter"
```
</details>

<details>
<summary>Link a static library in compile time:</summary>

```sh
${CROSS_COMPILE}gcc -static main.c -o app
```
</details>

<details>
<summary>Expose static library locations using toolchain:</summary>

```sh
SYSROOT=$(${CROSS_COMPILE}gcc -print-sysroot)
cd $SYSROOT
ls -l usr/lib/libc.a
```
</details>

<details>
<summary>Create a static library:</summary>

```sh
${CROSS_COMPILE}gcc -c test1.o
${CROSS_COMPILE}gcc -c test2.o
${CROSS_COMPILE}ar rc libtest1.a test1.o test2.o
${CROSS_COMPILE}gcc main.c -ltest -L../libs -I../libs -o app
```
</details>

<details>
<summary>Create a shared library:</summary>

```sh
${CROSS_COMPILE}gcc -fPIC -c test1.c
${CROSS_COMPILE}gcc -fPIC -c test2.c
${CROSS_COMPILE}gcc -shared -o libtest.so test1.o test2.o
${CROSS_COMPILE}gcc main.c -ltest -L../libs -I../libs -o app
${CROSS_COMPILE}readelf -a app | grep library
${CROSS_COMPILE}readelf -a app | grep interpreter
```
</details>

<details>
<summary>Inspect SONAME of a shared library:</summary>

```sh
readelf -a /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2 | grep SONAME
libjpeg.so.8
```
</details>

<details>
<summary>Cross-compile using Make:</summary>

```sh
make CROSS_COMPILE=armv6-rpi-linux-gnueabihf-
```

```sh
export CROSS_COMPILE=armv6-rpi-linux-gnueabihf-
make
```
</details>

<details>
<summary>Cross-compile using Autotools:</summary>

* GNU Autoconf [https::/gnu.org/software/autoconf/autoconf.html](https::/gnu.org/software/autoconf/autoconf.html)
* GNU Automake [https://gnu.org/savannah-checkouts/gnu/automake](https://gnu.org/savannah-checkouts/gnu/automake)
* GNU Libtool [https://gnu.org/software/libtool/libtool.html](https://gnu.org/software/libtool/libtool.html)
* Gnulib [https://gnu.org/software/gnulib](https://gnu.org/software/gnulib)

```sh
./configure
make
make install
```
</details>

<details>
<summary>Build a project with autotools:</summary>

```sh
CC=armv6-rpi-linux-gnueabihf ./configure --host=armv6-rpi-linux-gnueabihf
```
</details>

<details>
<summary>Cross compile SQlite using autotools and add it to the toolchain:</summary>

```sh
wget http://www.sqlite.org/2020/sqlite-autoconf-3330000.tar.gz
tar xf sqlite-autoconf-3330000.tar.gz
cd sqlite-autoconf-3330000
CC=armv6-rpi-linux-gnueabihf ./configure --host=armv6-rpi-linux-gnueabihf --prefix=/usr
make
make DESTDIR=$(armv6-rpi-linux-gnueabi-gcc -print-sysroot) install

armv6-rpi-linux-gnueabihf main.c -o sqlite-test -lsqlite3
```
</details>

<details>
<summary>Look up library dependencies using pkg-config:</summary>

```sh
cat $(armv6-rpi-linux-gnueabihf-gcc -print-sysroot)/usr/lib/pkgconfig/sqlite3.pc

export PKG_CONFIG_LIBDIR=$(armv6-rpi-linux-gnueabihf-gcc -print-sysroot)/usr/lib/pkgconfig
pkg-config sqlite3 --libs --cflags
armv6-rpi-linux-gnueabihf-gcc $(pkg-config sqlite3 --cflags --libs) main.c -o sqlite-test
```
</details>

<details>
<summary>Cross compile a project using CMake:</summary>

```sh
cmake -S . -B build -D CMAKE_INSTALL_PREFIX:PATH=sysroot -D CMAKE_C_COMPILER:PATH=x-tools/armv6-rpi-linux-gnueabihf-gcc
cmake --build build --parallel
cmake --build build --target install
```
</details>

## Chapter 3/19

<details>
<summary>Describe the boot sequence:</summary>

* **Phase 1 Rom Code**: loads a small chunk of code from first few pages of NAND, from flash memory connected through **Serial Peripheral Interface**, or from the first sector of an MMC device, or from a file named ML on the first partition of an MMC device.
* **Phase 2 Secondary Program Loader (SPL)**: sets up memory controller and other essential parts of the system in preparation for loading the **TPL** into DRAM.
* **Phase 3 Tertiary Program Loader (TPL)**: full bootloader such as U-Boot loads the kernel + optional FDT and initramfs into DRAM.
</details>

<details>
<summary>Specify what parameters should be passed to the kernel on moving from the bootloader to a kernel:</summary>

* The machine number, which is used on PowerPC and Arm platform without support for a device tree, to Identify the type of SoC.
* Basic details of the hardware that's been detected so far, including the size and location of the physical RAM and the CPU's clock speed.
* The kernel command line.
* Optionally, the location and size of a device tree binary.
* Optionally, the location and size of an initial RAM disk, called the **initial RAM file system (initramfs)**.
</details>

<details>
<summary>Device Tree Specification:</summary>

</details>

* https://github.com/devicetree-org/devicetree-specification/releases

<details>
<summary>Specify common properties of device tree specification:</summary>

* Device tree begins with a root node.
* **reg** property referes to a range of units in a register space.
* 

```dts
/dts-v1/;
/{
    model = "TI AM335x BeagleBone";
    compatible = "ti,am33xx";
    #address-cells = <1>;
    #size-cells = <1>;
    cpus {
        #address-cells = <1>;
        #size-cells = <0>;
        cpu@0 {
            compatible = "arm,cortex-a8";
            device_type = "cpu";
            reg = <0>;
        };
    };
    memory@80000000 {
        device_type = "memory";
        reg = <0x80000000 0x20000000>; /* 512 MB */
    };
};
```
</details>

* [Device Tree Bindings](https://kernel.org/doc/html/latest/devicetree/bindings/ "/devicetree/bindings")

<details>
<summary>Specify an interrupt controller device tree source:</summary>

* Labels used can be expressed in connections to reference to a node.
* Labels are also referred to as **phandles**.
* **interrupt-controller** property identifies not as interrupt controller.
* **interrupt-parrent** property references the interrupt controller.

```dts
/dts-v1/;
{
    intc: interrupt-controller@48200000 {
        compatible = "ti,am33xx-intc";
        interrupt-controller;
        #interrupt-cells = <1>;
        reg = <0x48200000 0x1000>;
    };
    lcdc: lcdc@48200000 {
        compatible = "ti,am33xx-tilcdc";
        reg = <0x4830e000 0x1000>;
        interrupt-parent = <&intc>;
        interrupts = <36>;
        ti,hwmods = "lcdc";
        status = "disabled";
    };
};
```
</details>

<details>
<summary>Using include in device tree source:</summary>

```dts
/include/ "vexpress-v2m.dtsi"
```
</details>

<details>
<summary>Overlay nodes on top of another to create a composite tree in which the outer layers extend or modify the inner ones:</summary>

* The **status** is disabled, meaning that no device driver should be bound to it.

```dts
mmc1: mmc@48060000 {
    compatible = "ti,omap4-hsmmc";
    t.hwmods = "mmc1";
    ti,dual-volt;
    ti,needs-special-reset;
    ti,needs-special-hs-handling;
    dmas = <&edma_xbar 24 0 0 &edma_xbar 25 0 0>;
    dma_names = "tx", "rx";
    interrupts = <64>;
    reg = <0x48060000 0x1000>;
    status = "disabled";
};
```

* The **status** property is set to *okay*, which causes the MMC device driver to bind with this interface.

```dtsi
&mmc1 {
    status = "okay";
    bus-width = <0x4>;
    pinctrl-names = "default";
    pinctrl-0 = <&mmc1_pins>;
    cd-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;
};
```

* The **mmc1** interface is connected to a different voltage regulator on the BeagleBone Black as expressed in am335x-boneblack.dts, which associates it with the voltage regulator via the **vmmcsd_fixed** label:

```dtsi
&mmc1 {
    vmmc-supply = <&vmmcsd_fixed>;
};
```
</details>

<details>
<summary>Compile a device tree source:</summary>

```sh
dtc beaglebone-black.dts -o beaglebone-black.dtb
```
</details>

<details>
<summary>Build U-Boot:</summary>

The results of the compilation:

* `u-boot`: U-Boot in ELF object format, suitable for use with a debugger
* `u-boot.map`: The symbol table
* `u-boot.bin`: U-Boot in raw binary format, suitable for running on your device
* `u-boot.img`: This is `u-boot.bin` with a U-Boot header added, suitable for uploading to a running copy of U-Boot
* `u-boot.srec`: U-Boot in Motoral S-record (**SRECORD** or **SRE**) format, suitable for transferring over a serial connection
* `MLO`: The BeagleBone Black also requires a **SPL** which is built here

```sh
git clone git:://git.denx.de/u-boot.git
cd u-boot
git checkout v2021.01
make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf- am335x_emv_defconfig
make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf- -j2
sudo fdisk /dev/sda
mkfs.vfat -F 16 -n boot /dev/sda1
mkfs.ext4 -L rootfs /dev/sda2
mount /dev/sda1 /run/media/brian/boot
cp MLO u-boot.img /run/media/brian/boot
umount /run/media/brian/boot
picocom -b 115200 /dev/ttyUSB0
```
</details>

<details>
<summary>Use U-Boot to read flash memory over serial console:</summary>

```sh
# read 0x200000 bytes from offset 0x400000 from the start of the NAND memory into RAM address 0x82000000
nand read 82000000 400000 200000
```
</details>

<details>
<summary>Set environment variables in U-Boot:</summary>

```sh
setenv foo bar
printenv foo

setenv foo # reset foo
printenv # print all environment variables
```
</details>

<details>
<summary>Create an image to load into U-Boot:</summary>

```sh
mkimage --help
mkimage -A arm -O linux -T kernel -C gzip -a 0x80008000 0e 0x80008000 -n 'Linux' -d zImage uImage
```
</details>

<details>
<summary>Load image into U-Boot:</summary>

```sh
mmc rescan
fatload mmc 0:1 82000000 uimage
iminfo 82000000
```
</details>

<details>
<summary>Boot from network in U-Boot:</summary>

```sh
setenv ipaddr 192.168.1.12
setenv serverip 192.168.1.18
tftp 82000000 uImage
tftpboot 82000000 uimage
nandecc hw
nand erase 280000 400000
nand write 82000000 280000 400000
nand read 82000000 280000 400000
```
</details>

<details>
<summary>Boot Linux in U-Boot:</summary>

```sh
# bootm [kernel address] [ramdist address] [dtb address]
bootm 82000000 - 83000000
```
</details>

<details>
<summary>Automate boot process in U-Boot:</summary>

```sh
setenv bootcmd nand read 82000000 400000 200000\;bootm 82000000
```
</details>

## Chapter 4/19
## Chapter 5/19
## Chapter 6/19
## Chapter 7/19
## Chapter 8/19
## Chapter 9/19
## Chapter 10/19
## Chapter 11/19
## Chapter 12/19
## Chapter 13/19
## Chapter 14/19
## Chapter 15/19
## Chapter 16/19
## Chapter 17/19
## Chapter 18/19
## Chapter 19/19

# [Mastering Embedded Linux Programming](https://www.amazon.com/Mastering-Embedded-Linux-Programming-potential/dp/1789530385/ref=sr_1_3?keywords=9781789530384&qid=1661185260&sr=8-3)
<img alt="9781789530384" src="../covers/9781789530384.jpg" width="200"/>

> The best first step into Embedded Linux domain is to read this book.

## Chapter 1

<details>
<summary>Project life cycles</summary>

1. Board Bring-Up
1. System Architecture and Design Choice
1. Writing Embedded Applications
1. Debugging and Optimizing Performance
</details>

<details>
<summary>The five elements of embedded Linux</summary>

1. Toolchain
1. Bootloader
1. Kernel
1. Root filesystem
1. Embedded Applications
</details>

<details>
<summary>Hardware selection for embedded Linux</summary>

1. CPU architecture
1. Reasonable amout of RAM
1. Non-volatile storage
1. Serial port
1. Debugging interface (e.g. JTAG)
</details>

## Chapter 2

<details>
<summary>Technical requirements</summary>

```sh
sudo pacman -S base-devel bzip2 cmake git gperf help2man ncurses python rsync unzip wget xz
```
</details>

[LLVM support for kernel build](https://kernel.org/doc/html/latest/kbuild/llvm.html)
<details>
<summary>GNU toolchain consist of three main components</summary>

* binutils **(base-devel)**: [https://gnu.org/software/binutils](https://gnu.org/software/binutils)
* gcc **(base-devel)**: [https://gcc.gnu.org](https://gcc.gnu.org)
* C library + Linux header files
</details>

<details>
<summary>GNU prefixes a tuple for toolchanins combined with four components:</summary>

* CPU Architecture + Endianness (e.g. `x86_64`, `mipsel`, `armeb`)
* Vendor (e.g. `buildroot`)
* Kernel (e.g. `linux`)
* Operating System + ABI (e.g. `gnueabi`, `gnueabihf`, `musleabi`, `musleabihf`)

```sh
gcc -dumpmachine
```
</details>
<details>
<summary>C libraries used in toolchains:</summary>

* glibc: [https://gnu.org/software/libc](https://gnu.org/software/libs)
* musl libs: [https://musl.libc.org](https://musl.libc.org)
* uClibc-ng: [https://uclibc-ng.org](https://uclibc-ng.org)
* eglibc: [https://uclibc.org/home](https://uclibc.org/home)

</details>

Toolchain can be completely built manually by [Cross Linux From Scratch](https://trac.clfs.org).

Another alternative to build toolchains is [crosstool-NG](https://crosstool-ng.github.io).

<details>
<summary>Installing crosstool-ng:</summary>

```sh
git clone https://github.com/crosstool-ng/crosstool-ng.git
cd crosstool-ng
git checkout <latest>
./bootstrap
./configure --enable-local
make -j<cores>
```
</details>

<details>
<summary>List samples of toolchains using crosstool-ng:</summary>

```sh
./ct-ng list-samples
```
</details>

<details>
<summary>Inspect details of a sample using crosstool-ng:</summary>

```sh
./ct-ng show-<sample>
./ct-ng show-armv6-unknown-linux-gnueabihf
./ct-ng show-arm-cortex_a8-linux-gnueabi
./ct-ng show-arm-unknown-linux-gnueabi
```
</details>

<details>
<summary>Building a toolchain for Raspberry Pi Zero:</summary>

```sh
./ct-ng distclean
./ct-ng show-armv6-unknown-linux-gnueabihf
./ct-ng armv6-unknown-linux-gnueabihf
```

Change following parts:

* Tarbal path
* Build path
* Vendor tuple

```sh
./ct-ng build
```
</details>

<details>
<summary>Building a toolchain for BeagleBone Black:</summary>

```sh
./ct-ng distclean
./ct-ng show-arm-cortex_a8-linux-gnueabi
./ct-ng arm-cortex_a8-linux-gnueabi
```

Change following parts:

* **Paths and misc options** >> **Render the toolchain read-only**: disable
* **Target options** >> **Floating point**: **hardware (FPU)**
* **Target options** >> **Use specific FPU**: neon

```sh
./ct-ng build
```
</details>

<details>
<summary>Building a toolchain for QEMU:</summary>

```sh
./ct-ng distclean
./ct-ng show-arm-unknown-linux-gnueai
./ct-ng arm-unknown-linux-gnueai
```

Change following parts:

* **Paths and misc options**: disable **Render the toolchain read-only**

```sh
./ct-ng build
```
</details>


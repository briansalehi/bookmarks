# [Mastering Linux Security and Hardening](books/9781837630516.md)
<img alt="Mastering Linux Security and Hardening" src="../covers/9781837630516.jpg" width="200"/>

## Chapter 1/16

Installing a virtual machine in VirtualBox

Download and install VirtualBox and the VirtualBox Extension Pack. You can get them from https://www.virtualbox.org/.

Download the installation .iso files for Ubuntu Server 22.04, CentOS 7, AlmaLinux8, and AlmaLinux9. You can get them from https://ubuntu.com/, https://almalinux.org/, and https://www.centos.org/.

Start VirtualBox and click the New icon at the top of the screen. Fill out the information where requested. Increase the virtual drive size to 20 GB, but leave everything else as the default

Start the new virtual machine. Click on the folder icon that’s beside the Location dialog box and navigate to the directory where you stored the .iso fi les that you downloaded.

installing Ubuntu

Repeat the procedure for the other Linux distros.

Installing the EPEL repository on the CentOS 7 virtual machine

While the Ubuntu package repositories have pretty much everything that you need for this course, the CentOS and AlmaLinux package repositories are—shall we say—lacking.

you’ll need to install the EPEL repository. 
(The EPEL project is run by the Fedora team.) When you install third-party repositories on Red Hat 7 and CentOS 7 systems, you’ll also need to install a priorities package and edit the .repo fi les to set the proper priorities for each repository. This will prevent packages from the third-party repository from overwriting of f i cial Red Hat and CentOS packages if they just happen to have the same name.

1. The two packages that you’ll need to install EPEL are in the normal CentOS 7 repositories. To install them, just run this command:

```sh
sudo yum install yum-plugin-priorities epel-release
``````

2. When the installation completes, navigate to the /etc/yum.repos.d directory, and open the CentOS-Base.repo fi le in your favorite text editor. Af t er the last line of the base, updates, and extras sections, add the line priority=1. Af t er the last line of the centosplus section, add the line priority=2.

3. Open the epel.repo fi le for editing. Af t er the last line of the epel section, add the line priority=10. Af t er the last line of each remaining section, add the line priority=11.

4. Update the system and then create a list of the installed and available packages by running the following commands:

```sh
sudo yum upgrade sudo yum list > yum_list.txt
``````

Installing the EPEL repository on the AlmaLinux 8/9 virtual machines

To install the EPEL repository on AlmaLinux, all you have to do is run this command:
sudo dnf install epel-release There’s no priorities package as there is on CentOS 7 and earlier, so we won’t have to worry about conf i guring the repository priorities.
When the package installation is complete, update the system and create a list of available sof t ware packages with these two commands:

```sh
sudo dnf upgrade sudo dnf list > dnf_list.txt
``````

Configuring a network for VirtualBox virtual machines

Creating a virtual machine snapshot with VirtualBox

Keeping the Linux systems updated

Spend some time perusing the Common Vulnerabilities and Exposures database, and you’ll soon see why it’s so important to keep your systems updated.

https://cve.mitre.org/

Updating Debian-based systems

run two commands, as shown here:

```sh
sudo apt update sudo apt dist-upgrade
``````

Occasionally, you’ll also need to remove some old packages that are no longer needed.

```sh
sudo apt auto-remove
``````

Configuring auto updates for Ubuntu

When you fi rst install Ubuntu 22.04, automatic updates are turned on by default. To verify that, you’ll fi rst check the status of the unattended-upgrades service, like so:

```sh
systemctl status unattended-upgrades
``````

Then, look in the `/etc/apt/apt.conf.d/20auto-upgrades` fi le. If auto-updating is enabled, you’ll see this:

```sh
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
``````

By default, Ubuntu systems don’t automatically reboot af t er an update is installed. If you keep it that way, you’ll see a message about it when you log into the system. 
But if you prefer, you can set Ubuntu to automatically reboot af t er it automatically updates itself.

1. Go into the `/etc/apt/apt.conf.d` directory and open the `50unattended-upgrades` fi le in your favorite text editor. In the vicinity of line 67, you’ll see a line that says:

```sh
Unattended-Upgrade::Automatic-Reboot "false";
``````

3. With this new conf i guration, Ubuntu will now reboot itself immediately af t er the automatic update process has completed. If you’d rather have the machine reboot at a specif i c time, scroll down to about line 103, where you’ll see this:

```sh
//Unattended-Upgrade::Automatic-Reboot-Time "02:00";
``````

5. To disable automatic updates, just go into the `/etc/apt/apt.conf.d` directory and open the `20auto-upgrades` fi le in your favorite text editor. Here’s what you’ll see:

```sh
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
``````

6. Change the parameter for that second line to 0, so that the fi le will now look like this:

```sh
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "0";
``````

1. If you want to see if there are any security-related updates available, but don’t want to see any non-security updates, use the unattended-upgrade command, like so:

```sh
sudo unattended-upgrade --dry-run -d
``````

8. To manually install the security-related updates without installing non-security updates, just run:

```sh
sudo unattended-upgrade -d
``````

Also, if you’re running a non-Ubuntu fl avor of Debian, which would include Rasp-bian for the Raspberry Pi, you can give it the same functionality as Ubuntu by installing the unattended-upgrades package. Just run this command:

```sh
sudo apt install unattended-upgrades
``````

Updating Red Hat 7-based systems

With Red Hat-based systems, which include CentOS and Oracle Linux, there’s no automatic update mechanism that you can set up during installation. So, with the default conf i guration, you’ll need to perform updates yourself:

1. To update a Red Hat 7-based system, just run this one command:

```sh
sudo yum upgrade
``````

2. Sometimes, you might just want to see if there are any security-related updates that are ready to be installed. Do that by running this command:

```sh
sudo yum updateinfo list updates security
``````

3. If any security updates are available, you’ll see them at the end of the command output.

1. If the only thing you want to install is the security updates, run this command:

```sh
sudo yum upgrade --security
``````

1. Now, let’s say that you need a CentOS system to automatically update itself. You’re in luck because there’s a package for that. Install and enable it, and start it by running these two commands:

```sh
sudo yum install yum-cron sudo systemctl enable --now yum-cron
``````

6. To conf i gure it, go into the `/etc/yum` directory, and edit the `yum-cron.conf` fi le.

1. Let’s say that you only want security updates to get applied automatically. Just change the last line to the following:

```sh
update_cmd = security
``````

1. On lines 15 and 20, you’ll see this:

```sh
download_updates = yes apply_updates = no
``````

This indicates that by default, yum-cron is only set to automatically download updates, but not to install them.
2. If you want the updates to get automatically installed, change the apply_updates parameter to yes.

Note that unlike Ubuntu, there’s no setting to make the system automatically reboot itself af t er an update.

11. Finally, let’s look at the mail settings for yum-cron, which you’ll fi nd on lines 48 through 57 of the yum-cron.conf fi le

As you can see, the email_to = line is set to send messages to the root user account. If you want to receive messages on your own account, just change it here.

12. To see the messages, you’ll need to install a mail reader program, if one isn’t already installed. 
(It hasn’t been installed if

you chose Minimal installation when you installed the operating system.) Your best bet is to install mutt, like so:

```sh
sudo yum install mutt
``````

14. As with all operating systems, certain updates will require that the system be restarted. And how do you know when the system needs to be restarted? With the needs-restarting com-mand, of course. First, though, you need to make sure that needs-restarting is installed on your system. Do that with this command:

```sh
sudo yum install yum-utils
``````

* `sudo needs-restarting`: This shows the services that need to be restarted, and the reasons why the system might need to be rebooted.
* `sudo needs-restarting -s`: This only shows the services that need to be restarted.
* `sudo needs-restarting -r`: This only shows the reasons why the system needs to be rebooted.

Updating Red Hat 8/9-based systems

For the most part, you use dnf the same way that you’d use yum, with the same arguments and options. For example, to do a system upgrade, just do:
sudo dnf upgrade

2. The main functional dif f erence between yum and dnf is that dnf has a dif f erent automatic update mechanism. Instead of installing the yum-cron package, you’ll now install the dnf-automatic package, like so:

```sh
sudo dnf install dnf-automatic
``````

3. In the /etc/dnf directory, you’ll see the automatic.conf fi le, which you’ll conf i gure the same way as you did the yum-cron.conf fi le for CentOS 7. Instead of working as a cron job, as the old yum-cron did, dnf-automatic works with a systemd timer. When you fi rst install dnf-automatic, the timer is disabled. Enable it and start it by running this command:

```sh
sudo systemctl enable --now dnf-automatic.timer
``````

4. Verify that it’s running with this command:

```sh
sudo systemctl status dnf-automatic.timer
``````

5. If it started successfully, you should see something like this when you check the status:

```sh
sudo systemctl status dnf-automatic.timer
``````

To determine if a system needs to be restarted, just install the yum-utils package and run the needs-restarting command, the same as you did for CentOS 7. (For some reason, the Red Hat developers never bothered to change the package name to dnf-utils.)

Managing updates in an enterprise

In an enterprise setting, there are two additional considerations:
• You want to restrict what packages the end users are allowed to install.
• You always want to test updates on a separate test network before allowing them to be installed on a production network.

For these reasons, enterprises will of t en set up their own repository servers that only have approved packages and approved updates.

Further reading

https://linuxsecurity.com/

## Chapter 2/16

The dangers of logging in as the root user

Logging in as the root user can do the following:

* Make it easier for you to accidentally perform an action that causes damage to the system
* Make it easier for someone else to perform an action that causes damage to the system

What we need is a mechanism that allows users to perform administrative tasks without incurring the risk of having them always log on as the root user, and that would also allow users to have only the admin privileges they really need to perform a certain job. In Linux and Unix, we have that mecha-nism in the form of the sudo utility.

You can see that I used su - to log in to the root command prompt and that I then logged back out. 
While I was logged in, I did several things that require root privileges, but none of that got recorded.

What’s to prevent a person from just doing a sudo su - to prevent his or her misdeeds from being detected?” That’s easy.
Just don’t give people the power to go to the root com-mand prompt.

how to allow a user to do everything, including logging in to the root command prompt

Adding users to a predefined admin group

The fi rst method, which is the simplest, is to add users to a predef i ned administrators group and then, if it hasn’t already been done, to conf i gure the sudo policy to allow that group to do its job. It’s simple enough to do except that dif f erent Linux distro families use dif f erent admin groups.

On Unix, BSD, and most Linux systems, you would add users to the wheel group.

By doing sudo visudo, I’ll open the sudo policy fi le. 
Scrolling down, we’ll see the line that gives the wheel group its awesome power:

```sudo
%wheel ALL=(ALL) ALL
``````

The percent sign indicates that we’re working with a group.
The three appearances of ALL mean that members of that group can perform ALL commands, as ALL users, on ALL machines in the network on which this policy is deployed.

```sudo
%wheel ALL=(ALL) NOPASSWD: ALL
``````

If we were to comment out the %wheel line in the former snippet and remove the comment symbol from in front of the %wheel line in this snippet, then members of the wheel group would be able to perform all of their sudo tasks without ever having to enter any password. That’s something that I really don’t recommend, even for home use.

To add an existing user to the wheel group, use usermod with the -G option. You might also want to use the -a option, in order to prevent removing the user from other groups to which he or she belongs.

```sudo
sudo usermod -a -G wheel maggie
``````

You can also add a user account to the wheel group as you create it.

```sudo
sudo useradd -G wheel frank
``````

Note that, with my usage of useradd, I’m assuming that we’re working with a member of the Red Hat family, which comes with predef i ned default settings to create user accounts. 
For non-Red Hat-type distros that use the wheel group, you’d need to either reconf i gure the default settings or use extra option switches in order to create the user’s home direc-tory and to assign the correct shell. Your command would then look something like this:

```sudo
sudo useradd -G wheel -m -d /home/frank -s /bin/bash frank
``````

For members of the Debian family, including Ubuntu, the procedure is the same, except that you would use the sudo group instead of the wheel group.

When you log in to one of those services and initially create your virtual machine, the cloud service will have you log in to that virtual machine as the root user. (This even happens with Ubuntu, even though the root user account is disabled whenever you do a local installation of Ubuntu.) The fi rst thing that you’ll want to do in this scenario is to create a normal user account for yourself and give it full sudo privileges. Then, log out of the root account and log back in with your normal user account. You’ll then want to disable the root account with this command:

```sh
sudo passwd -l root
``````

Creating an entry in the sudo policy file

what if you want to deploy a sudo policy across a network with a mixed group of both Red Hat and Ubuntu machines?

create an entry in the sudo policy fi le. You can either create an entry for an individual user or create a user alias.

To give members of the user alias full sudo power, add another line that would look like this:

```sudo
ADMINS ALL=(ALL) ALL
``````

It’s also possible to add a visudo entry for just a single user, and you might need to do that under very special circumstances.

```sudo
frank ALL=(ALL) ALL
``````

Setting up sudo for users with only certain delegated privileges

A basic tenet of IT security philosophy is to give network users enough privileges so that they can get their jobs done, but no privileges beyond that.

You can, for example, create a BACKUPADMINS user alias for backup administrators, a WEBADMINS user alias for web server administrators, or whatever else you desire.

```sudo
User_Alias SOFTWAREADMINS = vicky, cleopatra
``````

That’s good, except that Vicky and Cleopatra still can’t do anything. You’ll need to assign some duties to the user alias.

```sudo
Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum
``````

Now, it’s just a simple matter of assigning the SOFTWARE command alias to the SOFTWAREADMINS user alias:

SOFTWAREADMINS ALL=(ALL) SOFTWARE

Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig, /usr/bin/systemctl start, /usr/bin/systemctl stop, /usr/bin/systemctl reload, /usr/bin/systemctl restart, /usr/bin/systemctl status, /usr/bin/systemctl enable, /usr/bin/systemctl disable

The way sudo works is that if a command is listed by itself, then the assigned user can use that command with any subcommands, options, or arguments.

But when a command is listed in the command alias with a subcommand, option, or argument, that’s all anyone who’s assigned to the command alias can run.

Okay, so Lionel can run sudo systemctl status, which is pretty much useless, but he can’t do anything meaningful, such as specifying the service that he wants to check.

That’s a bit of a problem. There are two ways to fi x this, but there’s only one way that you want to use. You could just eliminate all of the systemctl subcommands and make the SERVICES alias look like this:

```sudo
Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig, /usr/bin/systemctl
``````

But if you do that, Lionel and Charlie will also be able to shut down or reboot the system, edit the services fi les, or change the machine from one systemd target to another.

Because the systemctl command covers a lot of dif f erent functions, you have to be careful not to allow delegated users to access too many of those functions. A better solution would be to add a wildcard to each of the systemctl subcommands:

```sudo
Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig, /usr/bin/systemctl start *, /usr/bin/systemctl stop *, /usr/bin/systemctl reload *, /usr/bin/systemctl
``````

restart *, /usr/bin/systemctl status *, /usr/bin/systemctl enable *, /usr/bin/ systemctl disable *

you’re not limited to using user aliases and command aliases. You can also assign privileges to either a Linux group or an individual user. You can also assign individual commands to a user alias, Linux group, or individual user. Here’s an example:
katelyn ALL=(ALL) STORAGE gunther ALL=(ALL) /sbin/fdisk -l %backup_admins ALL=(ALL) BACKUP

Each host alias consists of a list of server hostnames. This is what allows you to create one sudoers fi le on one machine and deploy it across the network. For example, you could create a WEBSERVERS host alias, a WEBADMINS user alias, and a WEBCOMMANDS command alias with the appropriate commands. 
Your conf i guration would look something like this:

```sudo
Host_Alias WEBSERVERS = webserver1, webserver2 User_Alias WEBADMINS = junior, kayla Cmnd_Alias WEBCOMMANDS = /usr/bin/systemctl status httpd, /usr/bin/systemctl start httpd, /usr/bin/systemctl stop httpd, /usr/bin/systemctl restart httpd WEBADMINS WEBSERVERS=(ALL) WEBCOMMANDS
``````

even though sudo is a security tool, certain things that you can do with it can make your system even more insecure than it was.

The sudo timer

By default, the sudo timer is set for 5 minutes. This means that once a user performs one sudo com-mand and enters a password, he or she can perform another sudo command within 5 minutes without having to enter the password again. Although this is obviously handy, it can also be problematic if users were to walk away from their desks with a command terminal still open.

you can easily disable this timer by adding a line to the Defaults section of the sudoers fi le.

If you need to leave your desk for a moment, your best action would be to log out of the server fi rst. Short of that, you could just reset the sudo timer by running this command:
sudo -k

View your sudo privileges

Are you unsure of what sudo privileges you possess?

sudo -l

In the Defaults specification section of the fi le, add the following line:
Defaults timestamp_timeout = 0

Preventing users from having root shell access

Let’s say that you want to set up a user with limited sudo privileges, and you decide to do so by adding a line like this:

```sudo
maggie ALL=(ALL) /bin/bash, /bin/zsh
``````

you haven’t limited Maggie’s access at all. You have ef f ectively given her full sudo privileges with both the Bash shell and the ZSH shell.

Preventing users from using shell escapes

Certain programs, especially text editors and pagers, have a handy shell escape feature. This allows a user to run a shell command without having to exit the program fi rst.

For example, from the command mode of the Vi and Vim editors, someone could run the ls command by running :!

imagine that you want Frank to be able to edit the sshd_config fi le and only that fi le. You might be tempted to add a line to your sudo conf i guration that would look like this:
frank ALL=(ALL) /bin/vim /etc/ssh/sshd_config This looks like it would work, right? Well, it doesn’t, because once Frank has opened the sshd_config fi le with his sudo privilege, he can then use Vim’s shell escape feature to perform other root-level commands, which includes being able to edit other conf i guration fi les, create new users, manipulate system services, or install malware.

You can fi x this problem by having Frank use sudoedit instead of vim.

```sudo
frank ALL=(ALL) sudoedit /etc/ssh/sshd_config
``````

Other programs that have a shell escape feature include the following:
• emacs • less • view • more

So, how do we deal with these? That’s easy. We’ll use the NOEXEC: option when we set up our sudoers rules.

```sudo
vicky ALL=(ALL) /usr/bin/less
``````

```sh
[vicky@localhost log]$ sudo less messages
``````

To open a shell from within less, Vicky will type !bash instead of :shell:

Once again, watch what happens when she hits the Enter key:

```sh
!done (press RETURN)
[root@localhost log]#
``````

Let’s fi x that by adding the NOEXEC: option to the su-doers rule:

```sudo
vicky ALL=(ALL) NOEXEC: /usr/bin/less
``````

This prevents Vicky from escaping to even her own shell:

Preventing users from using other dangerous programs

Some programs that don’t have shell escapes can still be dangerous if you give users unrestricted privileges to use them. These include the following:
• cat • cut • awk • sed

If you must give someone sudo privileges to use one of these programs, it’s best to limit their use to only specif i c fi les.

Limiting the user’s actions with commands

Let’s say that you create a sudo rule so that Sylvester can use the systemctl command:

```sudo
sylvester ALL=(ALL) /usr/bin/systemctl
``````

It would be better to specify what systemctl functions Sylvester is allowed to do.

```sudo
sylvester ALL=(ALL) /usr/bin/systemctl * sshd
``````

But what if you want Sylvester to do only certain specif i c actions with the Secure Shell service? Then you’ll have to omit the wildcard and

specify all of the actions that you want Sylvester to do:
sylvester ALL=(ALL) /usr/bin/systemctl status sshd, /usr/bin/systemctl restart sshd

When writing sudo policies, you’ll want to be aware of the dif f erences between the dif f erent Linux and Unix distributions on your network. For example, on Red Hat-type systems, the systemctl binary fi le is located in the /usr/bin directory. On Debian/Ubuntu systems, it’s located in the /bin directory. If you have to roll out a sudoers fi le to a large enterprise network with mixed operating systems, you can use host aliases to ensure that servers will only allow the execution of commands that are appropriate for their operating systems.
Also, be aware that some system services have dif f erent names on dif f erent Linux distri-butions. On Red Hat-type systems, the Secure Shell service is sshd. On Debian/Ubuntu systems, it’s just plain ssh.

Letting users run as other users

In the following line, (ALL) means that Sylvester can run the systemctl commands as any user:

```sudo
sylvester ALL=(ALL) /usr/bin/systemctl status sshd, /usr/bin/systemctl restart sshd
``````

This ef f ectively gives Sylvester root privileges for these commands because the root user is def i nitely any user. You could, if desired, change that (ALL) to (root) in order to specify that Sylvester can only run these commands as the root user:

```sudo
sylvester ALL=(root) /usr/bin/systemctl status sshd, /usr/bin/systemctl restart sshd
``````

Okay, there’s probably not much point in that because nothing changes.

But there are more practical uses for this feature. Let’s say that Vicky is a database admin, and you want her to run as the database user:
vicky ALL=(database) /usr/local/sbin/some_database_script.sh

Vicky could then run the command as the database user by entering the following command:

```sh
sudo -u database some_database_script.sh
``````

Preventing abuse via a user’s shell scripts

let’s have Frank create the frank_script.sh shell script

add this rule for Frank:

```sudo
frank ALL=(ALL) /home/frank/frank_script.sh
``````

since this fi le is in Frank’s own home directory and he is its owner, he can edit it any way he wants.

```sh
#!/bin/bash echo "This script belongs to Frank the Cat."
sudo -i
``````

What sudo -i does is to log a person in to the root user’s shell, the same way that sudo su - does. If Frank were to do sudo -i from his own command prompt, it would fail because he doesn’t have the privilege to do that.

To remedy this, I’ll

move Frank’s script to the /usr/local/sbin/ directory and change the ownership to the root user so that Frank won’t be able to edit it. And of course, before I do that, I’ll make sure to delete that sudo -i line from it:

```sh
mv frank_script.sh /usr/local/sbin
chown root: /usr/local/sbin/frank_script.sh
``````

Finally, I’ll open visudo and change his rule to ref l ect the new location of the script. The new rule looks like this:

```sudo
frank ALL=(ALL) /usr/local/sbin/frank_script.sh
``````

Frank can still run the script, but he can’t edit it

Detecting and deleting default user accounts

One challenge of dealing with Internet of Things (IoT) devices is that you don’t do a normal operating system installation on them as you would when setting up a normal server. Instead, you download an image that has the operating system pre-installed and burn that image to a microSD card. The installed operating system is set up with a default user account, and many times, that user is set up with full sudo privileges and isn’t required to enter a sudo password.

So, the default credentials are out there for all the world to see. Obviously, the fi rst thing you want to do when setting up an IoT device is to set up your own user account, give it a good password, and give it sudo privileges. Then get rid of that default account, because leaving it in place, especially if you leave the default password, is just asking for trouble.

Look in the /etc/password fi le on RaspEX, and you’ll see the default user there:

raspex:x:1000:1000:,,,:/home/raspex:/bin/bash Then, look in the /etc/sudoers fi le, and you’ll see this line, which allows the raspex user to do all sudo commands without having to enter a password:
raspex ALL=(ALL) NOPASSWD: ALL Another thing to watch out for is that some Linux distributions for IoT devices have this rule in a sep-arate fi le in the /etc/sudoers.d directory, instead of in the main sudoers fi le. Either way, you’ll want to delete this rule, as well as the default user account, when you set up your IoT device. And of course, you’ll also want to change the root user password, and then lock the root user account.

New sudo features

5 new sudo features sysadmins need to know in 2022– https://opensource.com/ article/22/2/new-sudo-features-2022

I should also mention that in order to know which new sudo features your Linux distro supports, you’ll need to know which version of sudo that it includes. Find out by doing:

```sh
sudo --version
``````

Special sudo considerations for SUSE and OpenSUSE

If you’ve ever worked with any kind of SUSE machine, you may have been puzzled by the fact that it asks for the root user’s password, rather than your own password, when you perform a sudo command. 
That’s because SUSE has a whole dif f erent way of doing business with sudo.

When you install a SUSE distro,

when you check the Use this password for system administrator box, it doesn’t add your user account to the wheel group as the RHEL-type distros do. Instead, it automatically assigns the same password that you created for yourself to the root user account. So, you and the root user will both have the same password.

When you do sudo visudo on a SUSE machine, you’ll see these two lines that you don’t see on any other Linux distro:
Defaults targetpw # ask for the password of the target user i.e. root ALL ALL=(ALL) ALL # WARNING! Only use this together with 'Defaults targetpw'!

comment out the two lines

```sudo
%wheel ALL=(ALL:ALL) ALL Save the fi le and exit visudo.
``````

add a rule for wheel group

the root user account is still enabled, so let’s disable it

```sh
sudo passwd -l root
``````

## Chapter 3/16
## Chapter 4/16
## Chapter 5/16
## Chapter 6/16
## Chapter 7/16
## Chapter 8/16
## Chapter 9/16
## Chapter 10/16
## Chapter 11/16
## Chapter 12/16
## Chapter 13/16
## Chapter 14/16
## Chapter 15/16
## Chapter 16/16

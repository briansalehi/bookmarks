# [Beginning x64 Assembly Programming](https://www.amazon.com/Beginning-x64-Assembly-Programming-Professional/dp/1484250753/ref=sr_1_1?crid=22BRR7CF215MZ&keywords=9781484250761&qid=1661489724&sprefix=9781484250761%2Caps%2C658&sr=8-1)
<img alt="9781484250761" src="covers/9781484250761.jpg" width="200"/>

> Reading this book is so fun to read, it's hard to believe you're actually
> learning Assembly programming.
> This is also technically the best book to learn about Assembly programming.

## Chapter 1/43

<details>
<summary>Write exit procedure in x64 Assembly</summary>

```nasm
section .data
section .bss
section .text
    global main

main:
    mov rax, 60
    mov rdi, 0
    syscall
```
</details>

<details>
<summary>Write an assembly program in x64, link and run</summary>

```nasm
section .data
    message db "sample assembly program", 10, 0
    length equ $ - message

section .bss
section .text
    global main

main:
    push rbp
    mov rbp, rsp

    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, length
    syscall

    mov rsp, rbp
    pop rbp

    mov rax, 60
    mov rdi, 0
    syscall
```

```make
sample: sample.o
    gcc -Wall -g3 -Og -no-pie sample.o -o sample
sample.o: sample.asm
    nasm -f elf64 -g -F dwarf sample.asm -l sample.lst
```
</details>

* [nasm reference manual](https://www.nasm.us/doc/)
* [gcc reference manual](https://gcc.gnu.org/onlinedocs/)
* [make reference manual](https://www.gnu.org/software/make/manual/html_node/)

## Chapter 2/43

<details>
<summary>Convert decimal, binary, and hexadecimal representations of integral and floating point numbers.</summary>

</details>

* [IEEE-754](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/)

<details>
<summary>Inspect the list of general purpose registers:</summary>

* rax
* rbx
* rcx
* rdx
* rsi
* rdi
* rbp
* rsp
* r8
* r9
* r10
* r11
* r12
* r13
* r14
* r15
</details>

<details>
<summary>Inspect the instruction pointer register:</summary>

* rip
</details>

<details>
<summary>Inspect the flag register:</summary>

Name|Symbol|Bit|Content
---|---|---|---
Carry|CF|0|Previous instruction had a carry
Parityp|F|2|Last byte has even number of 1s
Adjust|AF|4|BCD operations
Zero|ZF|6|Previous instruction resulted a zero
Sign|SF|8|Previous instruction resulted in most significant bit equal to 1
Direction|DF|10|Direction of string operations (increment or decrement)
Overflow|OF|11|Previous instruction resulted in overflow
</details>

<details>
<summary>Inspect the SIMD registers:</summary>

* xmm
* ymm
</details>

## Chapter 3/43

<details>
<summary>Debug a compiled program with gdb:</summary>

```sh
gdb -q ./program
```
</details>

* [GDB User Manual](https://sourceware.org/gdb/current/onlinedocs/gdb/)

<details>
<summary>List source lines in debugging:</summary>

```gdb
list
list 10
```
</details>

* `help list` or `h l`
* `show listsize`
* `set listsize 20`

<details>
<summary>Set disassembly flavor in debugger:</summary>

```gdb
show disassembly-flavor
set disassembly-flavor intel
set disassembly-flavor att
```
</details>

* `help set disassembly-flavor`

<details>
<summary>Store gdb configurations in file for future use:</summary>

```sh
echo 'set disassembly-flavor intel' >> $HOME/.gdbinit
```
</details>

<details>
<summary>Disassembly a function or line of source in debugger:</summary>

```gdb
disassemble main
disassemble 'path/to/source.cpp'::func
```
</details>

* `help disassemble`

<details>
<summary>Examine an address in memory in debugger:</summary>

```gdb
x/s 0x654321
x/s &message
x/d 0x654321
x/x $rip
```
</details>

* `help x`

<details>
<summary>Set breakpoints in debugger:</summary>

```gdb
break main
```
</details>

* `help break`

<details>
<summary>Run program in debugging:</summary>

```gdb
run
```
</details>

* `help run`

<details>
<summary>Inspect registers in debugger:</summary>

```gdb
info registers
info all-registers
```
</details>

* `help info registers`
* `help info all-registers`

<details>
<summary>Inspect parameters of program in debugger:</summary>

```gdb
info breakpoints
info stack
info threads
info source
```
</details>

* `help info breakpoints`
* `help info stack`
* `help info threads`
* `help info source`

<details>
<summary>Manipulate breakpoints in debugger:</summary>

```gdb
disable breakpoint 1
enable breakpoint 1
delete breakpoint 1
```
</details>

* `help disable breakpoint`
* `help enable breakpoint`
* `help delete breakpoint`

<details>
<summary>Change executation of program in debugger:</summary>

```gdb
continue
next
step
```
</details>

* `help continue`
* `help next`
* `help step`
* `help finish`

<details>
<summary>Print variables through debugging session:</summary>

```gdb
print
```
</details>

* `help print`

<details>
<summary>Enable TUI for debugger:</summary>

```gdb
tui enable
```
</details>

* `help tui`

## Chapter 4/43

<details>
<summary>Create values in data section of memory:</summary>

```nasm
section .data
    message db "sample program", 10, 0
    message_length equ $ - message - 1
    pi dq 3.14

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; write
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, message_length
    syscall

    mov rsp, rbp
    pop rbp

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall
```
</details>

<details>
<summary>Use external functions from C in assembly code:</summary>

```nasm
extern printf

section .data
    string_fmtstr db "%s", 10, 0
    string db "sample program", 0

    integer_fmtstr db "%d", 10, 0
    number dd 37

    float_fmtstr db "%2.6f", 10, 0
    pi dq 3.141592

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; printf
    mov rax, 0 ; do not use xmm registers
    mov rdi, string_fmtstr
    mov rsi, string
    call printf

    ; printf
    mov rax, 0 ; do not use xmm registers
    mov rdi, integer_fmtstr
    mov rsi, [number]
    call printf

    ; printf
    mov rax, 1 ; use xmm registers
    movq xmm0, [pi]
    mov rdi, float_fmtstr
    call printf

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall
```
</details>

<details>
<summary>Exit program without writing a syscall:</summary>

```nasm
section .text
    global main

main:
    ret
```
</details>

## Chapter 5/43

<details>
<summary>Nothing to import.</summary>

</details>

## Chapter 6/43

<details>
<summary>Nothing to import.</summary>

</details>

## Chapter 7/43

<details>
<summary>Compare values in assembly and jump conditionally based on comparison:</summary>

* je: jump if equal
* jne: jump if not equal
* jg: jump if greater
* jge: jump if greater or equal
* jl: jump if lower
* jle: jump if lower or equal
* ja: jump if above
* jae: jump if above or equal
* jb: jump if below
* jbe: jump if below or equal

```nasm
extern printf

section .data
    numerator dq 5
    denominator dq 6
    greater_str db "greater", 10, 0
    less_str db "less", 10, 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    mov rax, [numerator]
    mov rbx, [denominator]
    cmp rax, rbx
    jge greater

    mov rax, 0
    mov rdi, greater_str
    call printf
    jmp exit

greater:
    mov rax, 0
    mov rdi, less_str
    call printf

exit:
    xor rax, rax
    mov rsp, rbp
    pop rbp
    ret
```

```gdb
break main
run
next
info rflags
```
</details>

<details>
<summary>Make a loop using `rcx` register as a counter manually decremented until it reached zero:</summary>

```nasm
extern printf

section .data
    counter dq 3
    fmt db "%d", 10, 0

section .text
    global main

main:
    ; make stack frame
    push rbp
    mov rbp, rsp

    ; store initial value
    mov rcx, [counter]

    ; print initial value
    mov rax, 0
    mov rdi, fmt
    mov rsi, rcx
    call printf

repeat:
    ; repeat decrementing until value reached zero
    dec rcx
    cmp rcx, 0
    jne repeat

    ; print result
    mov rax, 0
    mov rdi, fmt
    mov rsi, rcx
    call printf

    ; remove stack frame
    mov rsp, rbp
    pop rbp

    ; return zero value
    xor rax, rax
    ret
```
</details>

<details>
<summary>Make a loop using `rcx` register automatically decremented by `loop` instruction until reached zero:</summary>

```nasm
extern printf

section .data
    fmt db "%i", 10, 0
    initial dq 3

section .text
    global main

main:
    ; make stack frame
    push rbp
    mov rbp, rsp

    ; assign initial value
    mov rcx, [initial]

    ; print initial value
    xor rax, rax
    mov rdi, fmt
    mov rsi, rcx
    call printf

    ; printf modified rcx
    mov rcx, [initial]

repeat:
    ; decrement rcx until reached zero
    loop repeat

    ; print result
    xor rax, rax
    mov rdi, fmt
    mov rsi, rcx
    call printf

    ; remove stack frame
    mov rsp, rbp
    pop rbp

    ; return value
    xor rax, rax
    xor rdi, rdi
    ret
```
</details>

## Chapter 8/43

<details>
<summary>Create an array of integers in assembly:</summary>

```nasm
section .data
    word_array times 5 dw 0 ; array of 5 words containing 0
```
</details>

<details>
<summary>Create uninitialized variables in assembly:</summary>

```nasm
section .bss
    bvar resb 10
    wvar resw 5
    dvar resd 1
    qvar resq 100
```
</details>

<details>
<summary>Load the content of character sequences or arrays in assembly:</summary>

```nasm
section .data
    text db "abc", 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; load address of first character
    lea al, [text]

    ; point of second character
    inc rax

    ; load address of third character
    lea al, [text + 2]

    mov rsp, rbp
    pop rbp

    xor rax, rax
    ret
```
</details>

<details>
<summary>Inspect the ELF header of an executable object:</summary>

```sh
readelf --file-header ./program
```
</details>

<details>
<summary>Inspect symbols of an executable object:</summary>

```sh
readelf --symbols ./program | grep -E 'main|start|Num:.*' --color
```
</details>

<details>
<summary>Sort an executable object symbols based on their memory locations:</summary>

```sh
readelf --symbols ./program | sort -k 2 -r
```
</details>

## Chapter 9/43

<details>
<summary>Make arithmetic operations on integers:</summary>

* `mul` multiplies unsigned integers
* `imul` multiplies signed integers
* `imul` will store the lower 64 bits of the resulting product in rax and the upper 64 bits in rdx.
* `idiv` will divide the dividen in rdx:rax by the divisor in the source operand and store the integer result in rax.

```nasm
section .data
    number1 dq 36
    number2 dq 3

section .bss
    result resq 1
    modulo resq 1

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; addition
    mov rax, [number1]
    add rax, [number2]
    mov [result], rax ; 39

    ; subtration
    mov rax, [number1]
    sub rax, [number2]
    mov [result], rax ; 33

    ; increment
    mov rax, [number1]
    inc rax
    mov [result], rax

    ; shift arithmetic left
    mov rax, [number1]
    sal rax, 2 ; multiply by 4
    mov [result], rax

    ; shift arithmetic right
    mov rax, [number1]
    sar rax, 2 ; divide by 4
    mov [result], rax

    ; multiply
    mov rax, [number2]
    imul qword[number2] ; multiplly rax with number2
    mov [result], rax

    ; divide
    mov rax, [number1]
    mov rdx, 0 ; division uses rdx:rax convention
    idiv qword[number2]
    mov [result], rax
    mov [modulo], rdx

    mov rsp, rbp
    pop rbp

    xor rax, rax
    ret
```
</details>

## Chapter 10/43

<details>
<summary>Monitor `rsp` register and watch the changes after pushing into and popping from the stack to reverse a string:</summary>

```nasm
section .data
    text db "Brian Salehi", 10, 0
    length equ $ - text - 1

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; print initial sequence
    mov rax, 1
    mov rdi, 1
    mov rsi, text
    mov rdx, length
    syscall

    ; prepare for reverse operation
    xor rax, rax
    mov rbx, text
    mov rcx, length
    xor r12, r12 ; to store index

store_loop:
    ; push sequence to stack
    mov al, byte [rbx+r12]
    push rax
    inc r12
    loop store_loop

    xor rax, rax
    mov rbx, text
    mov rcx, length
    xor r12, r12

reverse_loop:
    ; pop sequence from stack
    pop rax
    mov byte [rbx+r12], al
    inc r12
    loop reverse_loop
    mov byte [rbx+r12], 0

    ; print reversed string
    mov rax, 1
    mov rdi, 1
    mov rsi, text
    mov rdx, length
    syscall

    mov rsp, rbp
    pop rbp

    xor rax, rax
    ret
```
</details>

## Chapter 11/43

<details>
<summary>Convert floating point numbers into binaries:</summary>

* A single-precision number is 32 bits, 1 sign bit, 8 exponent bits, and 23 fraction bits.

```txt
S   EEEEEEEE        FFFFFFFFFFFFFFFFFFFFFFF
0   1      8        9                     31
```

* A double-precision number is 64 bits, 1 sign bit, 11 exponent bits, and 52 fraction bits.

```
S   EEEEEEEEEEE     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
0   1         11    12                                                 63
```
</details>

<details>
<summary>Do arithmetic operations with floating point numbers in assembly:</summary>

* Single precision floating point arithmetic instructions are postfixed with ss
* Double precision floating point arithmetic instructions are postfixed with sd

```nasm
extern printf

section .data
    number1 dq 9.0
    number2 dq 73.0
    fmt db "%f %f", 10, 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; print floating-point numbers
    movsd xmm0, [number1]
    movsd xmm1, [number2]
    mov rax, 2 ; two floats
    mov rdi, fmt
    call printf

    ; sum floating-point numbers
    movsd xmm0, [number1]
    addsd xmm0, [number2]

    ; difference
    movsd xmm0, [number1]
    subsd xmm0, [number2]

    ; multiplication
    movsd xmm0, [number1]
    mulsd xmm0, [number2]

    ; division
    movsd xmm0, [number1]
    divsd xmm0, [number2]

    ; square root
    sqrtsd xmm0, [number1]

    mov rsp, rbp
    pop rbp

    xor rax, rax
    ret
```
</details>

## Chapter 12/43

<details>
<summary>Abbreviate function epilogue by using `leave` instruction:</summary>

```cpp
section .text
    global main

main:
    push rbp
    mov rbp, rsp

    leave
    ret
```
</details>

<details>
<summary>Write a simple function in assembly:</summary>

* functions execute instructions and return a value.

```nasm
section .data
    radius dq 10.0
    pi dq 3.14

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    call area
    movsd xmm1, [radius]

    xor rax, rax
    leave
    ret

area:
    push rbp
    mov rbp, rsp

    movsd xmm0, [radius]
    mulsd xmm0, [radius]
    mulsd xmm0, [pi]

    xor rax, rax
    leave
    ret
```
</details>

<details>
<summary>Return integral or floating-point values from functions:</summary>

* Use `xmm0` register for floating-point values and `rax` register for other values.

```nasm
section .data
    val dq 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    call fail_func
    xor rax, rax

    call success_func
    xor rax, rax

    leave
    ret

fail_func:
    push rbp
    mov rbp, rsp

    mov rax, 1

    leave
    ret

success_func:
    push rbp
    mov rbp, rsp

    mov rax, 0

    leave
    ret
```
</details>

<details>
<summary>Use local sections in a function to declare local variables:</summary>

```nasm
extern printf

section .data
    radius dq 10.0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    call area
    call print

    xor rax, rax
    leave
    ret

area:
section .data
    .pi dq 3.141592     ; local to area

section .text
    push rbp
    mov rbp, rsp

    movsd xmm0, [.pi]
    mulsd xmm0, [radius]
    mulsd xmm0, [radius]

    leave
    ret

print:
section .data
    .fmt db "%f", 10, 0

section .text
    push rbp
    mov rbp, rsp

    mov rax, 1
    mov rdi, .fmt
    call printf

    leave
    ret
```
</details>

## Chapter 13/43

<details>
<summary>Align the stack after function call with stack frame:</summary>

* Each function call results in 8 bytes return address being pushed on the stack.
* It is necessary to make sure to restore the stack to the appropriate value before we leave a function.

```nasm
section .text
    global main

main:
    push rbp
    call func1
    pop rbp
    ret

func1:
    push rbp
    call func2
    pop rbp
    ret

func2:
    push rbp
    call func3
    pop rbp
    ret

func3:
    push rbp
    pop rbp
    ret
```
</details>

## Chapter 14/43

<details>
<summary>Write functions in assembly and use them externally in another source:</summary>

* Calling convention will be discussed next

*arithmetic.asm*
```nasm
section .text
    global sum
    global difference
    global area

sum:
    push rbp
    mov rbp, rsp

    mov rax, rdi
    add rax, rsi

    mov rsp, rbp
    pop rbp
    ret

difference:
    push rbp
    mov rbp, rsp

    mov rax, rdi
    sub rax, rsi

    mov rsp, rbp
    pop rbp
    ret

area:
    section .data
        .pi dq 3.141592

    section .text
        push rbp
        mov rbp, rsp

        movsd xmm1, qword[.pi]
        mulsd xmm0, xmm0
        mulsd xmm0, xmm1

        mov rsp, rbp
        pop rbp
        ret
```

*main.asm*
```nasm
extern sum
extern difference
extern area

section .data
    format_integral db "%i", 10, 0
    format_floating db "%f", 10, 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; use and print the results of sum function
    mov rdi, 1
    mov rsi, 3
    call sum

    mov rdi, format_integral
    mov rsi, rax
    xor rax, rax
    call printf

    ; use and print the results of difference function
    mov rdi, 7
    mov rsi, 5
    call difference

    mov rdi, format_integral
    mov rsi, rax
    xor rax, rax
    call printf

    ; use and print the results of area function
    mov xmm0, qword[radius]
    call area

    mov rdi, format_floating
    mov rax, 1
    call printf

    mov rsp, rbp
    pop rbp
    ret
```
</details>

<details>
<summary>Make a variable global to be visible to external functions:</summary>

```nasm
global pi

section .data
    pi dq 3.141592

section .text
    ...
```

```nasm
extern pi

section .text
    ...
```
</details>

## Chapter 15/43

<details>
<summary>Use calling conventions to transfer variables to and from functions:</summary>

* Following calling conventions are for System V AMD64 ABI:
* For integral types, registers are `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9` respectively, and additional arguments are passed via the stack and in reverse order so that we can pop off in the right order.
* Function's return address `rip` is pushed on the stack, just after the arguments.
* In function, then `rbp` is pushed, there maybe another 8 bytes needed to be pushed to align the stack in 16 bytes.
* For floating point types, registers are `xmm0` to `xmm7`, additional arguments are passed via the stack but not with `push` instruction. Will be discussed later.

```nasm
section .text
    global main

main:
    section .data
        .first   dq 1
        .second  dq 2
        .third   dq 3
        .forth   dq 4
        .fifth   dq 5
        .sixth   dq 6
        .seventh dq 7
        .eighth  dq 8
        .ninth   dq 9
        .tenth   dq 10

    section .text
        push rbp
        mov rbp, rsp

        mov rdi, .first
        mov rsi, .second
        mov rdx, .third
        mov rcx, .forth
        mov r8, .fifth
        mov r9, .sixth
        push .tenth
        push .ninth
        push .eighth
        push .seventh
        call func

sum:
    section .text
                        ; first value on stack
                        ; 8 bytes rip pushed onto stack
        push rbp        ; 8 bytes rbp pushed onto stack
        mov rbp, rsp

        xor rax, rax

        add rax, rdi
        add rax, rsi
        add rax, rdx
        add rax, rcx
        add rax, r8
        add rax, r9
        
        push rbx        ; preserve callee register
        xor rbx, rbx

        mov rbx, qword[rbp+16]  ; first value on stack: + rip + rbp
        add rax, rbx    ; seventh

        mov rbx, qword[rbp+24]
        add rax, rbx    ; eighth

        mov rbx, qword[rbp+32]
        add rax, rbx    ; ningth

        mov rbx, qword[rbp+40]
        add rax, rbx    ; tenth

        pop rbx         ; restore callee register

        mov rsp, rbp
        pop rbp
        ret
```
</details>

## Chapter 16/43

<details>
<summary>Evaluate bit-wise operations in assembly:</summary>

* `shl` and `sal` shift left but `sal` has sign extension.
* `shr` and `sar` shift right but `sar` has sign extension.

```nasm
section .data
    number1 db 6        ; 00000110
    number2 db 10       ; 00001010

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    mov rax, number1
    xor rax, number2    ; 00001100

    mov rax, number1
    or  rax, number2    ; 00001110

    mov rax, number1
    and rax, number2    ; 00000010

    mov rax, number1
    not rax             ; 11111001

    mov rax, number1
    shl rax, 5          ; 11000000

    mov rax, number1
    shr rax, 3          ; 00000001

    mov rax, number1
    sal rax, 2          ; 00001100

    mov rax, number1
    sar rax, 2          ; 00000011

    mov rax, number1
    rol rax, 3          ; 00011000

    mov rax, number1
    ror rax, 3          ; 10000001

    mov rsp, rbp
    pop rbp
    ret
```
</details>

## Chapter 17/43
## Chapter 18/43
## Chapter 19/43
## Chapter 20/43
## Chapter 21/43
## Chapter 22/43
## Chapter 23/43
## Chapter 24/43
## Chapter 25/43
## Chapter 26/43
## Chapter 27/43
## Chapter 28/43
## Chapter 29/43
## Chapter 30/43
## Chapter 31/43
## Chapter 32/43
## Chapter 33/43
## Chapter 34/43
## Chapter 35/43
## Chapter 36/43
## Chapter 37/43
## Chapter 38/43
## Chapter 39/43
## Chapter 40/43
## Chapter 41/43
## Chapter 42/43
## Chapter 43/43

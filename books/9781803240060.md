# [Linux Device Driver Development](https://www.amazon.com/Linux-Device-Driver-Development-development/dp/1803240067/ref=sr_1_3?keywords=9781803240060&qid=1660591215&sr=8-3)
<img alt="Linux Device Driver Development" src="../covers/9781803240060.jpg" width="200"/>

## Chapter 1/17

<details>
<summary>How to download the Linux kernel for building?</summary>

> ```sh
> git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
> ``````
>
> The cloning process can be trimmed by setting `--depth 1` option.
>
> It is best practice to use **LTS** kernel releases for production, so checkout to the latest stable tag:
>
> ```sh
> git checkout v5.4
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>Describe each directory in the kernel source tree?</summary>

> `arch/`: To be as generic as possible, architecture-specific code.
> `block/`: Codes for block storage devices.
> `crypto/`: Cryptographic API and the encryption algorithm's code.
> `certs/`: Certificates and sign files to enable a module signature to make the kernel load signed modules.
> `documentation/`: Descriptions of the APIs that are used for different kernel frameworks and subsystems.
> `drivers/`: Device driver, organized into various subdirectories.
> `fs/`: Implementations of different filesystems that the kernel supports, such as NTFS, FAT, ETX{2,3,4}, sysfs, procfs, NFS, and so on.
> `include/`: Kernel header files.
> `init/`: Initialization and startup code.
> `ipc/`: Implementation of the inter-process communication (IPC) mechanisms, such as message queues, semaphores, and shared memory.
> `kernel/`: Architecture-independent portions of the base kernel.
> `lib/`: Library routines and some helper functions including generic **kernel object (kobject)** handlers and **cyclic redundancy code (CRC)** computation functions.
> `mm/`: Memory management code.
> `net/`: Networking (whatever network type it is) protocol code.
> `samples/`: Device driver samples for various subsystems.
> `scripts/`: Scripts and tools that are used alongside the kernel.
> `security/`: Security framework code.
> `sound/`: Audio subsystem code.
> `tools/`: Linux kernel development and testing tools for various subsystems, such as USB, vhost test modules, GPIO, IIO, and SPI, among others.
> `usr/`: `initramfs` implementation.
> `virt/`: Virtualization directory, which contains the kernel virtual machine (KVM) module for a hypervisor.

> Origin: 1

> References:
---
</details>

<details>
<summary>What assumptions and flags are enabled by <code>kbuild</code> infrastructure based on the target architecture?</summary>

> Cross-compiler prefix and the architecture of the target must be specified.
>
> ```sh
> ARCH=<XXXX> CROSS_COMPILE=<YYYY> make help
> ``````
>
> If these variables are not specified, the native host machine is going to be targeted.
>
> ```sh
> make help
> ``````
>
> When `ARCH` is omitted or not set, it will default to the host where `make` is executed. It will default to `$(uname -m)`.  
> When `CROSS_COMPILE` is omitted or not set, `$(CROSS_COMPILE)gcc` will result in `gcc`, and will be the same for other tools, for example `$(CROSS_COMPILE)ld` will result in `ld`.

> Origin: 1

> References:
---
</details>

<details>
<summary>What <code>make</code> target options can be used to configure the kernel?</summary>

> ```sh
> make menuconfig   # ncurses-based interface
> make xconfig      # X-based interface
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>Where will be the kernel configurations stored?</summary>

> Selected options will be stored in `.config` file, at the root of the source tree.

> Origin: 1

> References:
---
</details>

<details>
<summary>How to generate a preconfigured <code>.config</code> file tuned for a specific platform in the kernel source tree?</summary>

> It is very difficult to know which configuration is going to work on your platform.
> In most cases, there will be no need to start a configuration from scratch.
> There are default and functional configuration files available in each arch directory that you can use as a starting point (it is important to start with a configuration that already works):
>
> ```sh
> ls arch/<arch>/configs/
> ``````
>
> The kernel configuration command, given a default configuration file, is as follows:
>
> ```sh
> ARCH=<arch> make <defconfig>
> ARCH=x86_64 make defconfig
> ARCH=arm64 CROSS_COMPILE=aarch64-unknown-linux-gnueabi- make defconfig
> ARCH=arm CROSS_COMPILE=armv6-unknown-linux-gnueabihf- make bcm2835_defconfig
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>How to revert configuration changes in kernel source tree after generating new <code>.config</code> file?</summary>

> Running `make defconfig` or any alternatives will generate a new `.config` file in the main (root) directory, while the old `.config` will be renamed `.config.old`.

> Origin: 1

> References:
---
</details>

<details>
<summary>How to create a new default configuration target in kernel source tree?</summary>

> ```sh
> make savedefconfig
> ``````
>
> This command will create a minimal (since it won't store non-default settings) configuration file.
> The generated default configuration file will be called `defconfig` and stored at the root of the source tree.
> You can store it in another location using the following command:
>
> ```sh
> mv defconfig arch/<arch>/configs/myown_defconfig
> ``````
>
> This way, you can share a reference configuration inside the kernel sources and other developers can now get the same `.config` file as you by running the following command:
>
> ```sh
> ARCH=<arch> make myown_defconfig
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>How to generate a default configuration file for <code>x86_64</code> target in the kernel source tree?</summary>

> Assuming that host is a 64bit machine, `ARCH` is set to `x86`:
>
> ```sh
> make x86_64_defconfig
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>How to generate a default configuration file for <code>BeagleBone Black</code> target in kernel source tree?</summary>

> ```sh
> make ARCH=arm64 CROSS_COMPILE=aarch64-unknown-linux-gnueabihf- make defconfig
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>How to include new kernel configurations into an old <code>.config</code> file?</summary>

> Following target prompts for every new configuration option:
>
> ```sh
> make oldconfig
> ``````
>
> You can avoid prompting new configuration options by setting their default values:
>
> ```sh
> make olddefconfig
> ``````
>
> Or you can say no to every new option by:
>
> ```sh
> make oldnoconfig
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>How to use the kernel configuration file on a running machine as an initial configurtion?</summary>

> Debian and Ubuntu Linux distributions save the `.config` file in the `/boot` directory:
>
> ```sh
> cp /boot/config-$(uname -r) .config
> ``````
>
> The other distributions may not do this.
>
> When `IKCONFIG` and `IKCONFIG_PROC` kernel configuration options enabled, the configuration file can also be found in:
>
> ```sh
> /proc/configs.gz
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration options allows accessing kernel configuration file on runtime?</summary>

> * `IKCONFIG`: This is a boolean option to enable this feature.
> * `IKCONFIG_PROC`: Boolean option, when set to `y` the `config.gz` file becomes available in `/proc`.

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option allows extending the kernel command line from within the configuration?</summary>

> * `CMDLINE_EXTEND`: This is a boolean option to enable this feature.
> * `CMDLINE`: This options is a string containing the actual command-line extension value.
>
> For example:
>
> ```
> CMDLINE="noinitrd usbcore.authorized_default=0"
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option makes the kernel symbol table available in <code>/proc/kallsyms</code>?</summary>

> `CONFIG_KALLSYMS`: This is very useful for tracers and other tools that need to map kernel symbols to addresses. It is used while you're printing oops messages. Without this, oops listings would produce hexadecimal output, which is difficult to interpret.

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option enables timing information while printing messages from the kernel?</summary>

> `CONFIG_PRINTK_TIME`: This is a boolean option to enable this feature.

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option allows debugging input devices?</summary>

> `CONFIG_INPUT_EVBUG`

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option enables system request key combinations to recover system after crash?</summary>

> `CONFIG_MAGIC_SYSRQ`: This is a boolean option to enable this feature.

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option enables the <code>ftrace</code> tracer support?</summary>

> `FTRACE` and `DYNAMIC_FTRACE`

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option allows tracing any non-inline function in the kernel?</summary>

> * `FUNCTION_TRACER`: allows tracing functions.
> * `FUNCTION_GRAPH_TRACER`: This also shows a call graph.

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option allows tracking off periods of IRQs in the kernel?</summary>

> `IRQSOFF_TRACER`

> Origin: 1

> References:
---
</details>

<details>
<summary>What kernel configuration option allows measuring preemption off latency and schedule latency tracing?</summary>

> * `PREEMPT_TRACER`
> * `SCHED_TRACER`

> Origin: 1

> References:
---
</details>

<details>
<summary>What <code>make</code> target should be used to build the kernel in the source tree?</summary>

> If not specified, the `make` target is `all`.
>
> ```sh
> ARCH=aarch64 CROSS_COMPILE=aarch64-unknown-linux-gnueabihf- make
> ``````
>
> For `x86` architectures, this target points to `vmlinux`, `bzImage`, and `modules` targets.  
> For ARM or aarch64 architectures, it corresponds to `vmlinuz`, `zImage`, `modules`, and `dtbs` targets.
>
> `make` can leverage the host's CPU performance by running multiple jobs in parallel:
>
> ```sh
> make -j8
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>Where do kernel build artifact will be stored in the source tree?</summary>

> * `arch/<arch>/boot/Image`: An uncompressed kernel image that can be booted.
> * `arch/<arch>/boot/*Image*`: A compressed kernel image that can also be booted.
> * `arch/<arch>/boot/dts/*.dtb`: Provides compiled device tree blobs for the selected CPU variant.
> * `vmlinux`: A raw, uncompressed, and unstripped kernel image in ELF format. It's useful for debugging purposes but generally not used for booting purposes.

> Origin: 1

> References:
---
</details>

<details>
<summary>How to install the kernel binary file on native and non-native targets?</summary>

> In native installation following command copies artifacts like `/boot/vmlinuz-<version>`, `/boot/System.map-<version>`, and `/boot/config-<version>` files on the host.
>
> ```sh
> sudo make install
> ``````
>
> However, an embedded installation usually uses a single file kernel.

> Origin: 1

> References:
---
</details>

<details>
<summary>How to install kernel modules?</summary>

> ```sh
> make modules
> sudo make modules_install
> ``````
>
> The resulting modules will be installed in `/lib/modules/$(uname -r)/kernel/`, in the same directory structure as their corresponding source.
>

> Origin: 1

> References:
---
</details>

<details>
<summary>How to override the installation path of compiled module binaries after the <code>make</code> target <code>modules_install</code> is executed?</summary>

> The resulting modules will be installed in `/lib/modules/$(uname -r)/kernel/`, in the same directory structure as their corresponding source.
>
> ```sh
> ARCH=arm CROSS_COMPILE=armv6-unknown-linux-gnueabihf- make modules
> ``````
>
> However, this can be changed by specifying modules path with `INSTALL_MOD_PATH`:
>
> ```sh
> ARCH=arm CROSS_COMPILE=armv6-unknown-linux-gnueabihf- INSTALL_MOD_PATH=<dir> make modules_install
> ``````

> Origin: 1

> References:
---
</details>

<details>
<summary>What artifacts does <code>make modules_install</code> command generate on the host machine?</summary>

> Module files are installed in `/lib/modules/<version>/`:
>
> * `modules.builtin`: This lists all the kernel objects (.ko) that are built into the kernel. It is used by the module loading utility (modprobe, for example) so that it does not fail when it's trying to load something that's already built in. `modules.builtin.bin` is its binary counterpart.
> * `modules.alias`: This contains the aliases for module loading utilities, which are used to match drivers and devices.
> * `modules.dep`: This lists modules, along with their dependencies. `modules.dep.bin` is its binary counterpart.
> * `modules.symbols`: This tells us which module a given symbol belongs to. They are in the form of `alias symbol:<symbol> <modulename>`. An example is `alias symbol:v4l2_async_notifier_register videodev`. `modules.symbols.bin` is the binary counterpart of this file.
>
> And the rest of module files will be stored in `/lib/modules/<version>/kernel/` in the same directory structure as their corresponding source.

> Origin: 1

> References:
---
</details>

## Chapter 2/17

<details>
<summary>What kernel configuration option enables module loading on runtime?</summary>

> `CONFIG_MODULES=y`

> Origin: 2

> References:
---
</details>

<details>
<summary>What kernel configuration option enables unloading modules on runtime?</summary>

> `CONFIG_MODULE_UNLOAD=y`

> Origin: 2

> References:
---
</details>

<details>
<summary>What kernel configuration option ignores safely unloading modules having dependencies?</summary>

> `CONFIG_MODULE_FORCE_UNLOAD=y`

> Origin: 2

> References:
---
</details>

<details>
<summary>What is the basic skeleton of a kernel module?</summary>

> ```c
#include <linux/module.h>
#include <linux/init.h>

static int __init sample_init(void)
{
    pr_info("Sample module loaded");
    return 0;
}

static void __exit sample_exit(void)
{
    pr_info("Sample module unloaded");
}

module_init(sample_init);
module_exit(sample_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Brian Salehi <salehibrian@gmail.com>");
MODULE_DESCRIPTION("Sample module to do nothing");
> ``````

> Origin: 2

> References:
---
</details>

<details>
<summary>What functions are the entry points of all kernel modules?</summary>

> `module_init()` is used to declare the function that should be called when the module is loaded.
> `module_exit()` is used only when the module can be built as a loadable kernel module.
>
> Both methods are invoked only once, whatever the number of devices currently handled by the module, provided the module is a device driver.

> Origin: 2

> References:
---
</details>

<details>
<summary>What are the <code>\_\_init</code> and <code>\_\_exit</code> function prefixes in kernel modules?</summary>

> `__init` and `__exit` are kernel macros, defined in `include/linux/init.h`.
> They are Linux directives (macros) that wrap GNU C compiler attributes used for symbol placement.
> They instruct the compiler to put the code they prefix in the `.init.text` and `.exit.text` sections.
>
> ```c
#define __init __section(.init.text)
#define __exit __section(.exit.text)
> ``````
>
> * `__init`:
>
> The `__init` keyword tells the linker to place the symbols (variables or functions)
> they prefix in a dedicated section in the resulting kernel object file.
> This section is known in advance to the kernel and freed when the module is loaded
> and the initialization function has finished.
> This applies only to built-in modules, not to loadable ones.
> Since the driver cannot be unloaded, its initialization function will never be called
> again until the next reboot.
> There is no need to keep references on this initialization function anymore.
>
> `__exit`:
>
> It is the same for the `__exit` keyword and the exit method, whose corresponding code
> is omitted when the module is compiled statically into the kernel or when module
> unloading support is not enabled because, in both cases, the exit function
> is never called.
> `__exit` has no effect on loadable modules.

> Origin: 2

> References:
---
</details>

<details>
<summary>Where are module information stored in kernel modules?</summary>

> A kernel module uses its `.modinfo` section to store information about the module.

> Origin: 2

> References:
---
</details>

<details>
<summary>What are the common macros used in kernel modules to store module information?</summary>

> Any `MODULE_*` macro will update the content of `.modinfo` section with the values passed as parameters.
> Some of these macros are `MODULE_DESCRIPTION()`, `MODULE_AUTHOR()`, and `MODULE_LICENSE()`.

> Origin: 2

> References:
---
</details>

<details>
<summary>What is the real underlying macro provided by the kernel to add an entry to the module information section?</summary>

> ```c
> MODULE_INFO(tag, info);
> ``````

> Origin: 2

> References:
---
</details>

<details>
<summary>Where does the content of the <code>.modinfo</code> section of a kernel module can be seen?</summary>

> You can dump the content of the `.modeinfo` section of a kernel module using the following command on the given module:
>
> ```sh
> ${CROSS_COMPILE}objdump -d -j .modinfo
> ``````

> Origin: 2

> References:
---
</details>

<details>
<summary>What are the differences of <code>EXPORT\_SYMBOL</code> and <code>EXPORT\_SYMBOL\_GPL</code> macros exporting symbols based on license?</summary>

> The license will define how your source code should be shared (or not) with other developers.
> `MODULE_LICENSE()` tells the kernel what license our module is under.
> It has an effect on your module behavior, since a license that is not compatible with
> **GPL (General Public License)** will result in your module not being able to see/use
> symbols exported by the kernel through the `EXPORT_SYMBOL_GPL()` macro,
> which shows the symbols for GPL-compatible modules only.
> This is the opposite of `EXPORT_SYMBOL()`, which exports functions for modules with any license.

> Origin: 2

> References:
---
</details>

<details>
<summary>Why does licensing kernel modules with <b>GPL</b> matter in kernel community?</summary>

> Loading a non-GPL-compatible module will result in a tainted kernel; that means non-open source or untrusted code has been loaded, and you will likely have no support from the community.
>
> Remember that the module without `MODULE_LICENSE()` is not considered open source and will taint the kernel too.
>
> Available licenses can be found in `include/linux/module.h`, describing the license supported by the kernel.

> Origin: 2

> References:
---
</details>

<details>
<summary>What is the <b>out-of-tree</b> kernel module building?</summary>

> When code is outside of the kernel source tree, it is known as out-of-tree building.
>
> Building a module this way does not allow integration into the kernel configuration/compilation process, and the module needs to be built separately.
>
> It must be noted that with this solution, the module cannot be statically linked in the final kernel image – that is, it cannot be built in.
>
> Out-of-tree compilation only allows loadable kernel modules to be produced.

> Origin: 2

> References:
---
</details>

<details>
<summary>What is the <b>built-in</b> kernel module building?</summary>

> With this building method the code is inside the kernel tree, which allows you to upstream your code, since it is well integrated into the kernel configuration/compilation process.
> This solution allows you to produce either a statically linked module (also known as built-in) or a loadable kernel module.

> Origin: 2

> References:
---
</details>

<details>
<summary>What command is used to build a kernel module?</summary>

> Using `make` tool, a kernel module build command pattern resembles the following:
>
> ```sh
> make -C $KERNEL_SRC M=$(shell pwd) [target]
> ``````
>
> In the preceding pattern, `$KERNEL_SRC` refers to the path of the prebuilt kernel directory.
>
> And `M=$(shell pwd)` instructs the kernel build system to move back into this directory to find the module that is being built.

> Origin: 2

> References:
---
</details>

<details>
<summary>What <code>make</code> targets are available when building a kernel module?</summary>

> * `modules`: This is the default target for external modules. It has the same functionality as if no target was specified.
> * `modules_install`: This installs the external module(s). The default location is `/lib/modules/<kernel_release>/extra/`. This path can be overridden by `INSTALL_MOD_PATH` option.
> * `clean`: This removes all generated files.

> Origin: 2

> References:
---
</details>

<details>
<summary>How to tell the build system what object files to build or to link together when building a kernel module?</summary>

> We must specify the name of the module(s) to be built, along with the list of requisite source files:
>
> ```make
> obj-<X> := <module_name>.o
> ``````
>
> `<X>` can be either y, m, or left blank.
>
> In the preceding, the kernel build system will build `<module_name>.o` from `<module_name>.c` or `<module_name>.S`, and after linking, it will result in the `<module_name>.ko` kernel loadable module or will be part of the single-file kernel image.
>
> However, the `obj-$(CONFIG_XXX)` pattern is often used, where `CONFIG_XXX` is a kernel configuration option, set or not, during the kernel configuration process:
>
> ```make
> obj-$(CONFIG_MYMODULE) += mymodule.o
> ``````
>
> `$(CONFIG_MYMODULE)` evaluates to either y, m, or nothing (blank), according to its value during the kernel configuration.

> Origin: 2

> References:
---
</details>

<details>
<summary>How to specify multiple source files in <code>Makefile</code> for a kernel module?</summary>

> ```make
> <module_name>-y := <file1>.o <file2>.o
> ``````
>
> The `<module_name>.ko` will be built from two files, `file1.c` and `file2.c`.
> However, if you wanted to build two modules, let's say `foo.ko` and `bar.ko`, the Makefile line would be as follows:
>
> ```make
> obj-m := foo.o bar.o
> ``````
>
> If `foo.o` and `bar.o` are made of source files other than `foo.c` and `bar.c`, you can specify the appropriate source files of each object file, as shown here:
>
> ```make
> obj-m := foo.o bar.o
> foo-y := foo1.o foo2.o . . .
> bar-y := bar1.o bar2.o bar3.o . . .
> ``````
>
> The following is another example of listing the requisite source files to build a given module:
> 
> ```make
> obj-m := 8123.o
> 8123-y := 8123_if.o 8123_pci.o 8123_bin.o
> ``````

> Origin: 2

> References:
---
</details>

<details>
<summary>How to specify compiler and linker flags in <code>Makefile</code> for kernel module building?</summary>

> ```make
> ccflags-y := -I$(src)/include
> ccflags-y += -I$(src)/src/hal/include
> ldflags-y := -T$(src)foo_sections.lds
> ``````

> Origin: 2

> References:
---
</details>

<details>
<summary>How to include a directories containing <code>Makefile</code> or <code>Kbuild</code> files inside when writing kernel module <code>Makefile</code>?</summary>

> ```make
> obj-<X> += somedir/
> ``````
>
> This means that the kernel build system should go into the directory named somedir and look for any Makefile or Kbuild files inside, processing it in order to decide what objects should be built.

> Origin: 2

> References:
---
</details>

<details>
<summary>What does a minimal <code>Makefile</code> for kernel module look like?</summary>

> ```make
obj-m := helloworld.o

KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build

all default: modules
install: modules_install

modules modules_install help clean:
    $(MAKE) -C $(KERNEL_SRC) M=$(shell pwd) $@
> ``````
>
> `KERNEL_SRC= /lib/modules/$(shell uname -r)/build`: `KERNEL_SRC` is the location of the prebuilt kernel source. As we said earlier, we need a prebuilt kernel in order to build any module. If you have built your kernel from the source, you should set this variable with the absolute path of the built source directory. `–C` instructs the make utility to change into the specified directory reading the makefiles.
>
> `M=$(shell pwd)`: This is relevant to the kernel build system. The `Makefile` kernel uses this variable to locate the directory of an external module to build. Your `.c` files should be placed in that directory.
>
> `$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@`: This is the rule to be executed for each of the targets enumerated previously. Using this kind of magic word prevents us from writing as many (identical) lines as there are targets.

> Origin: 2

> References:
---
</details>

<details>
<summary>How many ways are there to obtain a prebuilt kernel for building <b>out-of-tree</b> module?</summary>

> * Building the kernel from source.
>
> * Installing the `linux-headers-*` package from the distribution package feed. (x86 only)
>
> This will install preconfigured and prebuilt kernel headers (not the whole source tree) in `/usr/src/linux-headers-$(uname -r)`.
> There will be a symbolic link, `/lib/modules/$(uname -r)/build`, pointing to the previously installed headers.
> It is the path you should specify as the kernel directory in Makefile.

> Origin: 2

> References:
---
</details>

<details>
<summary>How to build an <b>out-of-tree</b> kernel module having a prebuilt kernel available in <code>KERNEL\_SRC</code> path?</summary>

> ```sh
> make
> ``````
>
> This will result the following output as an example:
>
> ```
> make -C /lib/modules/ 5.11.0-37-generic/build \
>   M=/home/john/driver/helloworld modules
> ``````
>
> To test:
>
> ```sh
> sudo insmod helloworld.ko
> sudo rmmod helloworld
> dmesg
> ``````

> Origin: 2

> References:
---
</details>

## Chapter 3/17
## Chapter 4/17
## Chapter 5/17
## Chapter 6/17
## Chapter 7/17
## Chapter 8/17
## Chapter 9/17
## Chapter 10/17
## Chapter 11/17
## Chapter 12/17
## Chapter 13/17
## Chapter 14/17
## Chapter 15/17
## Chapter 16/17
## Chapter 17/17

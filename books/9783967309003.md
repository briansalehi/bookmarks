# [C++ Move Semantics: The Complete Guide](https://www.amazon.com/Move-Semantics-Complete-Guide-First/dp/3967309002/ref=d_pd_sbs_sccl_2_1/135-3266014-6825219?pd_rd_w=N5nO9&content-id=amzn1.sym.3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_p=3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_r=H0GGED0Y9YFS2H3EYNDM&pd_rd_wg=rcVK4&pd_rd_r=a7164440-01e1-49bb-834a-e59ca725a1e1&pd_rd_i=3967309002&psc=1)
<img alt="9783967309003" src="../covers/9783967309003.jpg" width="200"/>


## Chapter 1/15

<details>
<summary>Inspect the behaviour of a program when unnecessary copies are omitted:</summary>

> ```cpp
> #include <vector>
> #include <string>
> 
> std::vector<std::string> f()
> {
>     std::vector<std::string> cells; // default constructed vector without allocations
>     cells.reserve(3); // allocate 3 elements of std::string
>     std::string s{"data"}; // default constructed std::string
>     cells.push_back(s); // 1st vector element copy constructed
>     cells.push_back(s+s); // default construction of temporary object
>                           // and move construction of 2nd vector element
>     cells.push_back(std::move(s)); // move constructed 3rd vector element
>                                    // empty out s object
>     return cells; // optimize out vector as return value
> }
> 
> int main()
> {
>     std::vector<std::string> v;
>     v = f(); // move assigned constructed vector by return value
> }
> ``````

> Origin:
> -

> References:
> - [std::move](https://en.cppreference.com/w/cpp/utility/move)
---
</details>

<details>
<summary>Implement move semantics for an object:</summary>

> ```cpp
> #include <utility>
> 
> class bag
> {
> private:
>     unsigned int _count;
>     int* _storage;
> 
> public:
>     bag(int const& number): _count{0}, _storage{nullptr}
>     {
>         _count++;
>         _storage = new int{number};
>     }
> 
>     virtual ~bag()
>     {
>         if (_count)
>             delete _storage;
>     }
> 
>     bag(bag const& other): _count{other._count}
>     {
>         _storage = new int{*other._storage};
>     }
> 
>     bag(bag&& other): _count{other._count}, _storage{other._storage}
>     {
>         other._count = 0;
>         other._storage = nullptr;
>     }
> };
> 
> int main()
> {
>     bag a{1};
>     bag b{std::move(a)};
> }
> ``````

> Origin:
> -

> References:
> - [Move constructors](https://en.cppreference.com/w/cpp/language/move_constructor "cpp/language/move_constructor")
> - [Move assignment operator](https://en.cppreference.com/w/cpp/language/move_assignment "cpp/language/move_assignment")
---
</details>

## Chapter 2/15
## Chapter 3/15

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>copy constructor</b> automatically generated?</summary>

> The copy constructor is automatically generated when all of the following conditions are met:
> * No <b>move constructor</b> is user-declared
> * No <b>move assignment operator</b> is user-declared

> Origin:
> - 3.3.8

> References:
> - [Copy Constructors](https://en.cppreference.com/w/cpp/language/copy_constructor)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>move constructor</b> automatically generated?</summary>

> The move constructor is automatically generated when all of the following conditions are met:
> * No <b>copy constructor</b> is user-declared
> * No <b>copy assignment operator</b> is user-declared
> * No <b>move assignment operator</b> is user-declared
> * No <b>destructor</b> is user-declared

> Origin:
> - 3.3.8

> References:
> - [Move Constructor](https://en.cppreference.com/w/cpp/language/move_constructor)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>copy assignment operator</b> automatically generated?</summary>

> The copy assignment operator is automatically generated when all of the following conditions are met:
> * No <b>move constructor</b> is user-declared
> * No <b>move assignment operator</b> is user-declared

> Origin:
> - 3.3.8

> References:
> [Copy Assignment Operator](https://en.cppreference.com/w/cpp/language/copy_assignment)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>move assignment operator</b> automatically generated?</summary>

> The move constructor is automatically generated when all of the following conditions are met:
> * No <b>copy constructor</b> is user-declared
> * No <b>move constructor</b> is user-declared
> * No <b>copy assignment operator</b> is user-declared
> * No <b>destructor</b> is user-declared

> Origin:
> - 3.3.8

> References:
> [Move Assignment Operator](https://en.cppreference.com/w/cpp/language/move_assignment)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when does the <b>destructor</b> disable automatic move operations?</summary>

> Declaring destructors in anyway disables the automatic generation of move operations.

> Origin:
> - 3.3.8

> References:
> [Destructor](https://en.cppreference.com/w/cpp/language/destructor)
---
</details>

<details>
<summary>What declarations does the <b>Rule of Five</b> formulate to simplify special member functions generation?</summary>

> The guideline is to either declare all five (copy constructor, move constructor, copy assignment operator, move assignment operator, and destructor) or none of them.
> Declaration means either to implement, set as default, or set as deleted.

> Origin:
> - 3.4

> References:
> - [The Rule of Three/Five/Zero](https://en.cppreference.com/w/cpp/language/rule_of_three)
---
</details>

## Chapter 4/15

<details>
<summary>Why should we avoid using <code>std::move</code> when returning a local object?</summary>

> Returning a local object by value automatically uses move semantics if supported.
> On the other hand, `std::move` is just a `static_cast` to an rvalue reference,
> therefore disables **return value optimization**, which usually allows the returned
> object to be used as a return value instead.
>
> ```cpp
> std::string foo()
> {
>     std::string s;
>     return std::move(s); // BAD, returns std::string&&
> }
> ``````

> Origin:
> - 4.2

> References:
> - [std::move](https://en.cppreference.com/w/cpp/utility/move)
</details>

<details>
<summary>Does <code>virtual</code> destructor in a base class disable automatic move operations in its derived classes?</summary>

> Usually, in polymorphic derived classes there is no need to declare special member functions, especially virtual destructor.
>
> ```cpp
class Base
{
public:
    virtual void do_something() const = 0;
    virtual ~Base() = default;
};

class Derived: public Base
{
public:
    virtual void do_something() const override;
    virtual ~Derived() = default; // BAD, redundant, disables move
};
> ``````

> Origin:
> - 4.4.2

> References:
> - [Destructors](https://en.cppreference.com/w/cpp/language/destructor)
</details>

## Chapter 5/15

<details>
<summary>How to implement getter member functions using move semantics and reference semantics in order to avoid expensive copy of returned object?</summary>

> A getter returning by value is safe but each time we call it we might make a copy:
>
> ```cpp
> class Recipients
> {
> private:
>     std::vector<std::string> _names;
> public:
>     std::vector<std::string> names() const {
>         return _names;
>     }
> };
> ``````
>
> A getter returning by reference is fast but unsafe because the caller has to ensure
> that the object the returned reference refers to lives long enough.
>
> ```cpp
> class Recipients
> {
> private:
>     std::vector<std::string> _names;
> public:
>     std::vector<std::string> const& names() const {
>         return _names;
>     }
> };
> ``````
>
> This will fail when object is an rvalue reference:
>
> ```cpp
> for (std::string name: returnRecipients().names()) // undefined behavior
> {
>     if (name == "manager")
>         ...
> };
> ``````
>
> Using move semantics we can return by reference if it is safe to do so, and return
> by value if we might run into lifetime issues:
>
> ```cpp
> class Recipients
> {
> private:
>     std::vector<std::string> _names;
> public:
>     std::vector<std::string> names() && { // where we no longer need the value
>         return std::move(_names); // we steal and return by value
>     }
>     std::vector<std::string> const& names() const& { // in all other cases
>         return _names; // we give access to the member
>     }
> };
> ``````
>
> We overload the getter with different reference qualifiers in the same way as
> when overloading a function for `&&` and `const&` parameters.
>
> The version with the `&&` qualifier is used when we have an object where we
> no longer need the value, an object that is about to die or that we have marked
> with `std::move()`.
>
> The version with `const&` qualifier is used in all other cases. It is only the
> fallback if we cannot take the `&&` version. Thus this function is used if we have
> an object that is not about to die or marked with `std::move()`.
>
> We now have both good performance and safety.

> Origin:
> - 5.1.3

> References:
> - [Non-static member functions](https://en.cppreference.com/w/cpp/language/member_functions)
</details>

<details>
<summary>How many reference qualified member functions can we implement and how would each of them be called?</summary>

> Since C++98 we can overload member functions for implementing a const and non-const version.
>
> ```cpp
> class C
> {
> public:
>     void foo();
>     void foo() const;
> };
> ``````
>
> Now with move semantics we have new ways to overload functions with qualifiers because
> we have different reference qualifiers.
> ```cpp
> class C
> {
> public:
>     void foo() const&;
>     void foo() &&;
>     void foo() &;
>     void foo() const&&;
> };
> 
> int main()
> {
>     C x;
>     x.foo();                // foo() &
>     C{}.foo();              // foo() &&
>     std::move(x).foo();     // foo() &&
> 
>     const C cx;
>     cx.foo();               // foo() const&
>     std::move(cx).foo();    // foo() const&&
> }
> ``````
>
> Usually, we have only two or three of these overloads, such as using `&&` and `const&`
> (and `&`) for getters.

> Origin:
> - 5.2

> References:
> - [Non-static member functions](https://en.cppreference.com/w/cpp/language/member_functions)
</details>

<details>
<summary>Is it possible to overload for both reference and non-reference qualifiers?</summary>

> Overloading for both reference and value qualifiers is not allowed.
>
> ```cpp
> class C
> {
> public:
>     void foo() &&;
>     void foo() const; // ERROR
> };
> ``````

> Origin:
> - 5.2

> References:
> - [Non-static member functions](https://en.cppreference.com/w/cpp/language/member_functions)
</details>

<details>
<summary>Why should we use reference qualifiers?</summary>

> Reference qualifiers allow us to implement functions differently when they are called
> for objects of a specific value category.
>
> Although we do have this feature, it is not used as much as it could be.
> In particular, we should use it to ensure that operations that modify objects are not
> called for temporary objects that are about to die.

> Origin:
> - 5.3

> References:
> - [Non-static member functions](https://en.cppreference.com/w/cpp/language/member_functions)
</details>

<details>
<summary>What references qualifiers should be used for assignment operators to prevent accidental assignment of a new value to a temporary object?</summary>

> The assignment operators for strings are declared as follows:
>
> ```cpp
> namespace std {
>     template<typename charT, ...>
>     class basic_string {
>     public:
>         constexpr basic_string& operator=(const basic_string& str);
>         constexpr basic_string& operator=(basic_string&& str) noexcept(...);
>         constexpr basic_string& operator=(const charT* s);
>     };
> }
> ``````
>
> This enables accidental assignment of a new value to a temporary string:
>
> ```cpp
> std::string getString();
> getString() = "sample";     // Okay
> foo(getString() = "");      // Okay, accidental assignment instead of comparison
> ``````
>
> Accidental assignments can be prevented by using reference qualifiers:
>
> ```cpp
> namespace std {
>     template<typename charT, ...>
>     class basic_string {
>     public:
>         constexpr basic_string& operator=(const basic_string& str) &;
>         constexpr basic_string& operator=(basic_string&& str) & noexcept(...);
>         constexpr basic_string& operator=(const charT* s) &;
>     };
> }
> ``````
>
> Code like this will no longer compile:
>
> ```cpp
> std::string getString();
> getString() = "sample";     // Error
> foo(getString() = "");      // Error
> ``````
>
> In general, you should do this for every member function that might modify an object.
>
> ```cpp
> class MyType {
>     public:
>         // disable assigning value to temporary objects
>         MyType& operator=(const MyType&) & = default;
>         MyType& operator=(MyType&&) & = default;
> 
>         // enable these because they were disabled by assignment operators
>         MyType(MyType const&) = default;
>         MyType(MyType&&) = default;
> };
> ``````

> Origin:
> - 5.3.1

> References:
> - [Assignment operators](https://en.cppreference.com/w/cpp/language/operator_assignment)
</details>

## Chapter 6/15
## Chapter 7/15
## Chapter 8/15
## Chapter 9/15
## Chapter 10/15
## Chapter 11/15
## Chapter 12/15
## Chapter 13/15
## Chapter 14/15
## Chapter 15/15

# [C++ Move Semantics: The Complete Guide](https://www.amazon.com/Move-Semantics-Complete-Guide-First/dp/3967309002/ref=d_pd_sbs_sccl_2_1/135-3266014-6825219?pd_rd_w=N5nO9&content-id=amzn1.sym.3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_p=3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_r=H0GGED0Y9YFS2H3EYNDM&pd_rd_wg=rcVK4&pd_rd_r=a7164440-01e1-49bb-834a-e59ca725a1e1&pd_rd_i=3967309002&psc=1)
<img alt="9783967309003" src="../covers/9783967309003.jpg" width="200"/>


## Chapter 1/15

<details>
<summary>Inspect the behaviour of a program when unnecessary copies are omitted:</summary>

```cpp
#include <vector>
#include <string>

std::vector<std::string> f()
{
    std::vector<std::string> cells; // default constructed vector without allocations
    cells.reserve(3); // allocate 3 elements of std::string
    std::string s{"data"}; // default constructed std::string
    cells.push_back(s); // 1st vector element copy constructed
    cells.push_back(s+s); // default construction of temporary object
                          // and move construction of 2nd vector element
    cells.push_back(std::move(s)); // move constructed 3rd vector element
                                   // empty out s object
    return cells; // optimize out vector as return value
}

int main()
{
    std::vector<std::string> v;
    v = f(); // move assigned constructed vector by return value
}
```
</details>

* [std::move](https://en.cppreference.com/w/cpp/utility/move "cpp/utility/move")

<details>
<summary>Implement move semantics for an object:</summary>

```cpp
#include <utility>

class bag
{
private:
    unsigned int _count;
    int* _storage;

public:
    bag(int const& number): _count{0}, _storage{nullptr}
    {
        _count++;
        _storage = new int{number};
    }

    virtual ~bag()
    {
        if (_count)
            delete _storage;
    }

    bag(bag const& other): _count{other._count}
    {
        _storage = new int{*other._storage};
    }

    bag(bag&& other): _count{other._count}, _storage{other._storage}
    {
        other._count = 0;
        other._storage = nullptr;
    }
};

int main()
{
    bag a{1};
    bag b{std::move(a)};
}
```
</details>

* [Move constructors](https://en.cppreference.com/w/cpp/language/move_constructor "cpp/language/move_constructor")
* [Move assignment operator](https://en.cppreference.com/w/cpp/language/move_assignment "cpp/language/move_assignment")

## Chapter 2/15
## Chapter 3/15

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>copy constructor</b> automatically generated?</summary>

> The copy constructor is automatically generated when all of the following conditions are met:
> * No <b>move constructor</b> is user-declared
> * No <b>move assignment operator</b> is user-declared

> Origin:
> - 3.3.8

> References:
> - [Copy Constructors](https://en.cppreference.com/w/cpp/language/copy_constructor)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>move constructor</b> automatically generated?</summary>

> The move constructor is automatically generated when all of the following conditions are met:
> * No <b>copy constructor</b> is user-declared
> * No <b>copy assignment operator</b> is user-declared
> * No <b>move assignment operator</b> is user-declared
> * No <b>destructor</b> is user-declared

> Origin:
> - 3.3.8

> References:
> - [Move Constructor](https://en.cppreference.com/w/cpp/language/move_constructor)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>copy assignment operator</b> automatically generated?</summary>

> The copy assignment operator is automatically generated when all of the following conditions are met:
> * No <b>move constructor</b> is user-declared
> * No <b>move assignment operator</b> is user-declared

> Origin:
> - 3.3.8

> References:
> [Copy Assignment Operator](https://en.cppreference.com/w/cpp/language/copy_assignment)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when is the <b>move assignment operator</b> automatically generated?</summary>

> The move constructor is automatically generated when all of the following conditions are met:
> * No <b>copy constructor</b> is user-declared
> * No <b>move constructor</b> is user-declared
> * No <b>copy assignment operator</b> is user-declared
> * No <b>destructor</b> is user-declared

> Origin:
> - 3.3.8

> References:
> [Move Assignment Operator](https://en.cppreference.com/w/cpp/language/move_assignment)
---
</details>

<details>
<summary>According to the exact rules for <b>generated special member functions</b>, when does the <b>destructor</b> disable automatic move operations?</summary>

> Declaring destructors in anyway disables the automatic generation of move operations.

> Origin:
> - 3.3.8

> References:
> [Destructor](https://en.cppreference.com/w/cpp/language/destructor)
---
</details>

<details>
<summary>What declarations does the <b>Rule of Five</b> formulate to simplify special member functions generation?</summary>

> The guideline is to either declare all five (copy constructor, move constructor, copy assignment operator, move assignment operator, and destructor) or none of them.
> Declaration means either to implement, set as default, or set as deleted.

> Origin:
> - 3.4

> References:
> - [The Rule of Three/Five/Zero](https://en.cppreference.com/w/cpp/language/rule_of_three)
---
</details>

## Chapter 4/15

<details>
<summary>Why should we avoid using <code>std::move</code> when returning a local object?</summary>

> Returning a local object by value automatically uses move semantics if supported.
> On the other hand, `std::move` is just a `static_cast` to an rvalue reference,
> therefore disables **return value optimization**, which usually allows the returned
> object to be used as a return value instead.
>
> ```cpp
> std::string foo()
> {
>     std::string s;
>     return std::move(s); // BAD, returns std::string&&
> }
> ``````

> Origin:
> - 4.2

> References:
> - [std::move](https://en.cppreference.com/w/cpp/utility/move)
</details>

<details>
<summary>Does <code>virtual</code> destructor in a base class disable automatic move operations in its derived classes?</summary>

> Usually, in polymorphic derived classes there is no need to declare special member functions, especially virtual destructor.
>
> ```cpp
class Base
{
public:
    virtual void do_something() const = 0;
    virtual ~Base() = default;
};

class Derived: public Base
{
public:
    virtual void do_something() const override;
    virtual ~Derived() = default; // BAD, redundant, disables move
};
> ``````

> Origin:
> - 4.4.2

> References:
> - [Destructors](https://en.cppreference.com/w/cpp/language/destructor)
</details>

## Chapter 5/15
## Chapter 6/15
## Chapter 7/15
## Chapter 8/15
## Chapter 9/15
## Chapter 10/15
## Chapter 11/15
## Chapter 12/15
## Chapter 13/15
## Chapter 14/15
## Chapter 15/15

# [Modern C++ Programming Cookbook](https://www.amazon.com/Modern-Programming-Cookbook-language-standard/dp/1800208987/ref=sr_1_1?crid=6DI3CP10K434&keywords=9781800208988&qid=1656945065&sprefix=%2Caps%2C309&sr=8-1)
<img alt="9781800208988" src="../covers/9781800208988.jpg" width="200"/>

> You cannot know how much you need to read this book until you do.
> Consider this book essential if you are a junior or middle C++ programmer.

- - -

## Chapter 1/12

<details>
<summary>Use auto to initialize objects in different forms:</summary>

Benefits of using `auto`:

* It is not possible to leave a variable uninitialized with `auto`.
* It prevents narrowing conversion of data types. (?)
* It makes generic programming easy.
* It can be used where we don't care about types.

Preconditions of using `auto`:

* `auto` does not retain cv-ref qualifiers.
* `auto` cannot be used for non-movable objects.
* `auto` cannot be used for multi-word types like long long.

```cpp
#include <string>
#include <vector>
#include <memory>

int main()
{
    auto i = 42; // int
    auto d = 42.5; // double
    auto c = "text"; // char const*
    auto z = {1, 2, 3}; // std::initializer_list<int>

    auto b = new char[10]{0}; // char*
    auto s = std::string{"text}; // std::string
    auto v = std::vector<int>{1, 2, 3}; // std::vector<int>
    auto p = std::make_shared<int>(42); // std::shared_ptr<int>

    auto upper = [](char const c) { return toupper(c); };
    auto add = [](auto const a, auto const b) { return a + b; };

    template <typename F, typename F>
    auto apply(F&& f, T value)
    {
        return f(value);
    }
}

class foo
{
    int _x;
public:
    foo(int const x = 0): _x{x} {}
    int& get() { return _x; }
};

decltype(auto) proxy_gen(foo& f) { return f.get(); }
// ^__ decltype() preserves cv-ref qualification of return type
```
</details>

<details>
<summary>Create type aliases:</summary>

```cpp
#include <bitset>

using byte = std::bitset<8>;
using fn = void(byte, double);
using fn_ptr = void(*)(byte, double);

void func(byte b, double d) { /* ... */ }

int main()
{
    byte b{001101001};
    fn* f = func;
    fn_ptr fp = func;
}
```
</details>

<details>
<summary>Create alias templates:</summary>

Preconditions of alias templates:

* Alias templates cannot be partially or explicitly specialized.
* Alias templates are never deduced by template argument deduction when deducing a template parameter.
* The type produced when specializing an alias template, is not allowed to directly or indirectly make use of its own type.

```cpp
#include <vector>

template <typename T>
class custom_allocator { /* ... */ };

template <typename T>
using vec_t = std::vector<T, custom_allocator<T>>;

int main()
{
    vec_t<int> vi;
    vec_t<std::string> vs;
}
```
</details>

<details>
<summary>Use uniform initialization to initialize objects of types:</summary>

* direct initialization initializes an object from an explicit set of constructor arguments.
* copy initialization initializes an object from another object.
* brace initialization prevents narrowing conversion of data types.
* all elements of list initialization should be of the same type.

```cpp
#include <iostream>
#include <initializer_list>
#include <string>
#include <vector>
#include <map>

void func(int const a, int const b, int const c)
{
    std::cout << a << b << c << '\n';
}

void func(std::initializer_list<int> const list)
{
    for (auto const& e: list)
        std::cout << e;
    std::cout << '\n';
}

int main()
{
    std::string s1("text"); // direct initialization
    std::string s2 = "text"; // copy initialization
    std::string s3{"text"}; // direct list-initialization
    std::string s4 = {"text"}; // copy list-initialization

    std::vector<int> v{1, 2, 3};
    std::map<int, std::string> m{{1, "one"}, {2, "two"}};

    func({1, 2, 3}); // call std::initializer_list<int> overload

    std::vector v1{4}; // size = 1
    std::vector v2(4); // size = 4

    auto a = {42}; // std::initializer_list<int>
    auto b{42}; // int
    auto c = {4, 2}; //std::initializer_list<int>
    auto d{4, 2}; // error, too many elements
```
</details>

<details>
<summary>Initialize non-static member variables:</summary>

```cpp
struct base
{
    // default member initialization
    const int height = 14;
    const int width = 80;

    vertical_alignment valign = vertical_alignment::middle;
    horizontal_alignment halign = horizontal_alignment::left;

    std::string text;

    // constructor initialization list
    base(std::string const& t): text{t}
    {}

    base(std::string const& t,
         vertical_alignment const va,
         horizontal_alignment const ha):
         text{t}, valign{va}, halign{ha}
    {}
};
```
</details>

<details>
<summary>Evaluate alignment of structures by considering theirs size of members:</summary>

* The alignment must match the size of the largest member in order to avoid performance issues.

```cpp
struct foo1         // size = 1, alignment = 1
{                   // foo1:    +-+
    char a;         // members: |a|
};

struct foo2         // size = 2, alignment = 1
{                   // foo1:    +-+-+
    char a;         // members: |a|b|
    char b;
};

struct foo3         // size = 8, alignment = 4
{                   // foo1:    +----+----+
    char a;         // members: |a...|bbbb|
    int  b;
};

struct foo3_
{
    char a;         // 1 byte
    char _pad0[3];  // 3 bytes
    int  b;         // 4 byte
};

struct foo4         // size = 24, alignment = 8
{                   // foo4:    +--------+--------+--------+--------+
    int a;          // members: |aaaa....|cccc....|dddddddd|e.......|
    char b;
    float c;
    double d;
    bool e;
};

struct foo4_
{
    int a;          // 4 bytes
    char b;         // 1 byte
    char _pad0[3];  // 3 bytes
    float c;        // 4 bytes
    char _pad1[4];  // 4 bytes
    double d;       // 8 bytes
    bool e;         // 1 byte
    char _pad2[7];  // 7 bytes
};
```
</details>

<details>
<summary>Query alignment of object types:</summary>

* `alignof` can only be applied to type-ids, and not to variables or class data members.

```cpp
struct alignas(4) foo
{
    char a;
    char b;
};

alignof(foo);   // 4
alignof(foo&);  // 4
alignof(char);  // 1
alignof(int);   // 4
alignof(int*);  // 8 (64-bit)
alignof(int[4]);// 4 (natural alignment of element is 4)
```
</details>

<details>
<summary>Set alignment of structures:</summary>

* `alignas` takes an expression evaluating 0 or valid value for alignment, a type-id, or a parameter pack.
* only valid values are the powers of two.
* program is ill-formed if largest `alignas` on a declaration is smaller than natural alignment without any `alignas` specifier.

```cpp
// alignas specifier applied to struct
struct alignas(4) foo1  // size = 4, aligned as = 4
{                       // foo1:    +----+
    char a;             // members: |a.b.|
    char b;
};

struct foo1_            // size = 4, aligned as = 1
{
    char a;             // 1 byte
    char b;             // 1 byte
    char _pad0[2];      // 2 bytes
};

// alignas specifier applied to member data declarations
struct foo2             // size = 16, aligned as = 8
{                       // foo2:    +--------+--------+
    alignas(2) char a;  // members: |aa......|bbbb....|
    alignas(8) int b;
};

struct foo2_            // size = 16, aligned as = 4
{
    char a;             // 2 bytes
    char _pad0[6];      // 6 bytes
    int b;              // 4 bytes
    char _pad1[4];      // 4 bytes
};

// the alignas specifier applied to the struct is less than alignas
// specifier applied to member data declaration, thus will be ignored.
struct alignas(4) foo3  // size = 16, aligned as = 8
{                       // foo3:    +--------+--------+
    alignas(2) char a;  // members: |aa......|bbbbbbbb|
    alignas(8) int b;
};

struct foo3_            // size = 16, aligned as = 4
{
    char a;             // 2 byte
    char _pad0[6];      // 6 bytes
    int b;              // 4 bytes
    char _pad1[4];      // 4 bytes
};

alignas(8) int a;       // size = 4, alignment = 8
alignas(256) long b[4]; // size = 32, alignment = 256
```
</details>

<details>
<summary>Use scoped enumerations<span style="color:green">(c++11)</span>:</summary>

* Scoped enumerations do not export their enumerators to the surrounding scope.
* Scoped enumerations have an underlying type so they can be forward declared.
* Values of scoped enumerations do not convert implicitly to int.

```cpp
enum class status: unsigned int; // forward declared

status do_something(); // function declaration/prototype

enum class status : unsigned int
{
    success = 0,
    failed = 1,
    unknown = 0xffff0000U
};

status do_something() { return status::success; }
```
</details>

<details>
<summary>Export enumerators of a scoped enumeration by `using` directive<span style="color:green">(c++20)</span>:</summary>

```cpp
#include <string>

enum class status : unsigned int
{
    success = 0,
    failure = 1,
    unknown = 0xffff0000U
};

std::string_view to_string(status const s)
{
    switch (s)
    {
        using enum status;
        case success: return "success";
        case failure: return "failure";
        case unknown: return "unknown";
    }
}
```
</details>

<details>
<summary>Use override to ensure correct declaration of virtual methods both in base and derived classes:</summary>

```cpp
class base
{
    virtual void foo() = 0;
    virtual void bar() {}
    virtual void baz() = 0;
};

class alpha: public base
{
    virtual void bar() override {}
    virtual void baz() override {}
};

class beta: public alpha
{
    virtual void foo() override {}
};

beta object;
```
</details>

<details>
<summary>Use final to prevent virtual method override:</summary>

```cpp
class base
{
    virtual void foo() = 0;
    virtual void bar() {}
    virtual void baz() = 0;
};

class alpha: public base
{
    virtual void foo() override {}
    virtual void baz() override final {}
};

class beta: public alpha
{
    // won't compile
    virtual void baz() override {}
};

int main()
{
    beta object;
}
```
</details>

<details>
<summary>Use final to prevent inheritance of a class:</summary>

```cpp
class base
{
    virtual void foo() = 0;
    virtual void bar() {}
    virtual void baz() = 0;
};

class derived final: public base
{
    virtual void foo() override {}
    virtual void baz() override {}
};

// won't compile
class prime: public derived
{
};
```
</details>

<details>
<summary>Use range-based for loop to iterate on a range<span style="color:green">(c++11)</span>:</summary>

```cpp
#include <vector>
#include <map>

std::vector<int> get_numbers()
{
    return std::vector<int>{1, 2, 3, 4, 5};
}

std::map<int, double> get_doubles()
{
    return std::map<int, double>{
        {0, 0.0},
        {1, 1.1},
        {2, 2.2}
    };
}

int main()
{
    auto numbers = std::vector<int>{1, 2, 3, 4, 5};
    auto copies = std::vector<int>(numbers.size() * 4);

    for (int element: numbers)
        copies.push_back(element);

    for (int& element: numbers)
        copies.push_back(element);

    for (auto&& element: get_numbers())
        copies.push_back(element);

    for (auto&& [key, value]: get_doubles())
        copies.push_back(key);
}
```
</details>

<details>
<summary>Enable range-based for loops for custom types:</summary>

```cpp
#include <iostream>
#include <stdexcept>
#include <iterator>

template <typename T, std::size_t const S>
class dummy_array
{
    T data[S] = {};

public:
    T const& at(std::size_t const index) const
    {
        if (index < S) return data[index];
        throw std::out_of_range("index out of range");
    }

    void insert(std::size_t const index, T const& value)
    {
        if (index < S) data[index] = value;
        else throw std::out_of_range("index out of range");
    }

    std::size_t size() const { return S; }
};

template <typename T, typename C, std::size_t const S>
class dummy_array_iterator_type
{
public:
    dummy_array_iterator_type(C& collection, std::size_t const index):
        index{index}, collection{collection}
    {}

    bool operator !=(dummy_array_iterator_type const& other) const
    {
        return index != other.index;
    }

    T const& operator *() const
    {
        return collection.at(index);
    }

    dummy_array_iterator_type& operator ++()
    {
        ++index;
        return *this;
    }

    dummy_array_iterator_type operator ++(int)
    {
        auto temp = *this;
        ++*temp;
        return temp;
    }

private:
    std::size_t index;
    C& collection;
};

template <typename T, std::size_t const S>
using dummy_array_iterator = dummy_array_iterator_type<T, dummy_array<T, S>, S>;

template <typename T, std::size_t const S>
using dummy_array_const_iterator = dummy_array_iterator_type<T, dummy_array<T, S> const, S>;

template <typename T, std::size_t const S>
inline dummy_array_iterator<T, S> begin(dummy_array<T, S>& collection)
{
    return dummy_array_iterator<T, S>(collection, 0);
}

template <typename T, std::size_t const S>
inline dummy_array_iterator<T, S> end(dummy_array<T, S>& collection)
{
    return dummy_array_iterator<T, S>(collection, collection.size());
}

template <typename T, std::size_t const S>
inline dummy_array_const_iterator<T, S> begin(dummy_array<T, S> const& collection)
{
    return dummy_array_const_iterator<T, S>(collection, 0);
}

template <typename T, std::size_t const S>
inline dummy_array_const_iterator<T, S> end(dummy_array<T, S> const& collection)
{
    return dummy_array_const_iterator<T, S>(collection, collection.size());
}

int main()
{
    dummy_array<int, 5> numbers;
    numbers.insert(0, 1);
    numbers.insert(1, 2);
    numbers.insert(2, 3);
    numbers.insert(3, 4);
    numbers.insert(4, 5);

    for (auto&& element: numbers)
        std::cout << element << ' ';
    std::cout << '\n';
}
```
</details>

<details>
<summary>Avoid implicit conversion of classes using explicit constructors and conversion operators:</summary>

```cpp
#include <memory>

class string_buffer
{
public:
    explicit string_buffer() {}
    explicit string_buffer(std::size_t const size) {}
    explicit string_buffer(char const* const ptr) {}
    explicit operator bool() const { return false; }
    explicit operator char* const () const { return nullptr; }
};

int main()
{
    std::shared_ptr<char> str;
    string_buffer b1;            // calls string_buffer()
    string_buffer b2(20);        // calls string_buffer(std::size_t const)
    string_buffer b3(str.get()); // calls string_buffer(char const*)

    enum item_size { small, medium, large };

    // implicit conversion cases when explicit not specified
    string_buffer b4 = 'a';      // would call string_buffer(std::size_t const)
    string_buffer b5 = small;    // would call string_buffer(std::size_t const)
}
```
</details>

<details>
<summary>Use unnamed namespaces instead of static globals:</summary>

* First, an unnamed namespaces will be expanded to a compiler defined unique name.
* Second, a `using` directive expands namespace.
* Third, the unnamed namespace will be named.
* Therefore, any function declared in it have local visibility but have external linkage.

*file1.cpp*
```cpp
#include <iostream>

namespace
{
    void print()
    {
        std::cout << "file1" << std::endl;
    }
}

print(); // external linkage, local visibility
```

*file2.cpp*
```cpp
#include <iostream>

namespace
{
    void print()
    {
        std::cout << "file2" << std::endl;
    }
}

print(); // external linkage, local visibility
```
</details>

<details>
<summary>Use an unnamed namespace to use an internal linkage variable as a non-type template argument:</summary>

* Prior to C++11, non-type template arguments could not be named with internal linkage, so `static` variables were not allowed. VC++ compiler still doesn't support it.

```cpp
template <int const& Size>
class test {};

tatic int Size1 = 10;

namespace
{
    int Size2 = 10;
}

test<Size1> t1; // error only on VC++
test<Size2> t2; // okay
```
</details>

<details>
<summary>Use inline namespaces for symbol versioning<span style="color:green">(c++11)</span>:</summary>

* Specialization of a template is required to be done in the same namespace where the template was declared.
* Define the content of the library inside a namespace
* Define each version of the library or parts of it inside an inner inline namespace
* Use preprocessor macros to enable a particular version of the library

```cpp
namespace incorrect_implementation
{
    namespace v1
    {
        template <typename T>
        int test(T value) { return 1; }
    }

    #ifndef _lib_version_1
    using namespace v1;
    #endif

    namespace v2
    {
        template <typename T>
        int test(T value) { return 2; }
    }

    #ifndef _lib_version_2
    using namespace v2;
    #endif
}

namespace broken_client_code
{
    // okay
    auto x = incorrect_implementation::test(42);

    struct foo { int a; };

    // breaks
    namespace incorrect_implementation
    {
        template <>
        int test(foo value) { return value.a; }
    }

    // won't compile
    auto y = incorrect_implementation::test(foor{42});

    // library leaks implementation details
    namespace incorrect_implementation
    {
        namespace version_2
        {
            template<>
            int test(foo value) { return value.a; }
        }
    }

    // okay, but client needs to be aware of implementation details
    auto y = incorrect_implementation::test(foor{42});
}
```

```cpp
namespace correct_implementation
{
    #ifndef _lib_version_1
    inline namespace v1
    {
        template <typename T>
        int test(T value) { return 1; }
    }
    #endif

    #ifndef _lib_version_2
    inline namespace v2
    {
        template <typename T>
        int test(T value) { return 2; }
    }
    #endif
}

namespace working_client_code
{
    // okay
    auto x = correct_implementation::test(42);

    struct foo { int a; };

    namespace correct_implementation
    {
        template <>
        int test(foo value) { return value.a; }
    }

    // okay
    auto y = correct_implementation::test(foor{42});
}
```
</details>

<details>
<summary>Use structured bindings to handle multi-return values<span style="color:green">(c++17)</span>:</summary>

* Only by C++20 structured bindings can include `static` or `thread_local` specifiers in the declaration.
* Only by C++20 `[[maybe_unused]]` attribute can be used in the declaration.
* Only by C++20 a lambda can capture structure binding identifiers.

```cpp
#include <iostream>
#include <set>

int main()
{
    std::set<int> numbers;

    if (auto const [iter, inserted] = numbers.insert(1); inserted)
        std::cout << std::distance(numbers.cbegin(), iter);
}
```
</details>

<details>
<summary>Simplify code with Class Template Argument Deduction<span style="color:green">(c++17)</span>:</summary>

* The type of objects without template arguments are not types, but act as a placeholder for a type that activates CTAD. When compiler encouters it, it builds a set of deduction guides which can be complemented by user with user defined deduction rules.
* CTAD does not occur if the template argument list is present.

```cpp
std::pair p{42, "demo"};    // std::pair<int, char const*>
std::vector v{1, 2};        // std::vector<int>
```
</details>

## Chapter 2/12

<details>
<summary>Regular expressions can be inspected in the following page:</summary>

</details>

* [Regular Expressions Library](https://cppreference.com/w/cpp/regex)

<details>
<summary>Validate a pattern using regular expression.</summary>

</details>

* [std::basic\_regex](https://cppreference.com/w/cpp/regex/basic_regex)
* [std::regex\_match]()

<details>
<summary>Make regular expression case insensitive:</summary>

</details>

* [std::regex\_constants](https://cppreference.com/w/cpp/regex/syntax_option_type)

<details>
<summary>Get pattern results from a regular expression match.</summary>

</details>

* [std::sub\_match]()
* [std::match\_results]()

<details>
<summary>Search for pattern in a file.</summary>

</details>

* [std::regex\_search]()

<details>
<summary>Replace all occurances of a pattern using regular expression.</summary>

</details>

* [std::regex\_replace]()

<details>
<summary>Iterate over all occurances of a regular expression match.</summary>

</details>

* [std::sregex\_iterator]()
* [std::sregex\_token\_iterator]()

## Chapter 3/12
## Chapter 4/12
## Chapter 5/12
## Chapter 6/12
## Chapter 7/12
## Chapter 8/12
## Chapter 9/12
## Chapter 10/12
## Chapter 11/12
## Chapter 12/12

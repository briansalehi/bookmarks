# [Modern C++ Programming Cookbook](https://www.amazon.com/Modern-Programming-Cookbook-language-standard/dp/1800208987/ref=sr_1_1?crid=6DI3CP10K434&keywords=9781800208988&qid=1656945065&sprefix=%2Caps%2C309&sr=8-1)
<img alt="9781800208988" src="../covers/9781800208988.jpg" width="200"/>

> You cannot know how much you need to read this book until you do.
> Consider this book essential if you are a junior or middle C++ programmer.

- - -

## Chapter 1/12

<details>
<summary>Use auto to initialize objects in different forms:</summary>

Benefits of using `auto`:

* It is not possible to leave a variable uninitialized with `auto`.
* It prevents narrowing conversion of data types. (?)
* It makes generic programming easy.
* It can be used where we don't care about types.

Preconditions of using `auto`:

* `auto` does not retain cv-ref qualifiers.
* `auto` cannot be used for non-movable objects.
* `auto` cannot be used for multi-word types like long long.

```cpp
#include <string>
#include <vector>
#include <memory>

int main()
{
    auto i = 42; // int
    auto d = 42.5; // double
    auto c = "text"; // char const*
    auto z = {1, 2, 3}; // std::initializer_list<int>

    auto b = new char[10]{0}; // char*
    auto s = std::string{"text}; // std::string
    auto v = std::vector<int>{1, 2, 3}; // std::vector<int>
    auto p = std::make_shared<int>(42); // std::shared_ptr<int>

    auto upper = [](char const c) { return toupper(c); };
    auto add = [](auto const a, auto const b) { return a + b; };

    template <typename F, typename F>
    auto apply(F&& f, T value)
    {
        return f(value);
    }
}

class foo
{
    int _x;
public:
    foo(int const x = 0): _x{x} {}
    int& get() { return _x; }
};

decltype(auto) proxy_gen(foo& f) { return f.get(); }
// ^__ decltype() preserves cv-ref qualification of return type
```
</details>

<details>
<summary>Create type aliases:</summary>

```cpp
#include <bitset>

using byte = std::bitset<8>;
using fn = void(byte, double);
using fn_ptr = void(*)(byte, double);

void func(byte b, double d) { /* ... */ }

int main()
{
    byte b{001101001};
    fn* f = func;
    fn_ptr fp = func;
}
```
</details>

<details>
<summary>Create alias templates:</summary>

Preconditions of alias templates:

* Alias templates cannot be partially or explicitly specialized.
* Alias templates are never deduced by template argument deduction when deducing a template parameter.
* The type produced when specializing an alias template, is not allowed to directly or indirectly make use of its own type.

```cpp
#include <vector>

template <typename T>
class custom_allocator { /* ... */ };

template <typename T>
using vec_t = std::vector<T, custom_allocator<T>>;

int main()
{
    vec_t<int> vi;
    vec_t<std::string> vs;
}
```
</details>

<details>
<summary>Use uniform initialization to initialize objects of types:</summary>

* direct initialization initializes an object from an explicit set of constructor arguments.
* copy initialization initializes an object from another object.
* brace initialization prevents narrowing conversion of data types.
* all elements of list initialization should be of the same type.

```cpp
#include <iostream>
#include <initializer_list>
#include <string>
#include <vector>
#include <map>

void func(int const a, int const b, int const c)
{
    std::cout << a << b << c << '\n';
}

void func(std::initializer_list<int> const list)
{
    for (auto const& e: list)
        std::cout << e;
    std::cout << '\n';
}

int main()
{
    std::string s1("text"); // direct initialization
    std::string s2 = "text"; // copy initialization
    std::string s3{"text"}; // direct list-initialization
    std::string s4 = {"text"}; // copy list-initialization

    std::vector<int> v{1, 2, 3};
    std::map<int, std::string> m{{1, "one"}, {2, "two"}};

    func({1, 2, 3}); // call std::initializer_list<int> overload

    std::vector v1{4}; // size = 1
    std::vector v2(4); // size = 4

    auto a = {42}; // std::initializer_list<int>
    auto b{42}; // int
    auto c = {4, 2}; //std::initializer_list<int>
    auto d{4, 2}; // error, too many elements
```
</details>

<details>
<summary>Initialize non-static member variables:</summary>

```cpp
struct base
{
    // default member initialization
    const int height = 14;
    const int width = 80;

    vertical_alignment valign = vertical_alignment::middle;
    horizontal_alignment halign = horizontal_alignment::left;

    std::string text;

    // constructor initialization list
    base(std::string const& t): text{t}
    {}

    base(std::string const& t,
         vertical_alignment const va,
         horizontal_alignment const ha):
         text{t}, valign{va}, halign{ha}
    {}
};
```
</details>

<details>
<summary>Evaluate alignment of structures by considering theirs size of members:</summary>

* The alignment must match the size of the largest member in order to avoid performance issues.

```cpp
struct foo1         // size = 1, alignment = 1
{                   // foo1:    +-+
    char a;         // members: |a|
};

struct foo2         // size = 2, alignment = 1
{                   // foo1:    +-+-+
    char a;         // members: |a|b|
    char b;
};

struct foo3         // size = 8, alignment = 4
{                   // foo1:    +----+----+
    char a;         // members: |a...|bbbb|
    int  b;
};

struct foo3_
{
    char a;         // 1 byte
    char _pad0[3];  // 3 bytes
    int  b;         // 4 byte
};

struct foo4         // size = 24, alignment = 8
{                   // foo4:    +--------+--------+--------+--------+
    int a;          // members: |aaaa....|cccc....|dddddddd|e.......|
    char b;
    float c;
    double d;
    bool e;
};

struct foo4_
{
    int a;          // 4 bytes
    char b;         // 1 byte
    char _pad0[3];  // 3 bytes
    float c;        // 4 bytes
    char _pad1[4];  // 4 bytes
    double d;       // 8 bytes
    bool e;         // 1 byte
    char _pad2[7];  // 7 bytes
};
```
</details>

<details>
<summary>Query alignment of object types:</summary>

* `alignof` can only be applied to type-ids, and not to variables or class data members.

```cpp
struct alignas(4) foo
{
    char a;
    char b;
};

alignof(foo);   // 4
alignof(foo&);  // 4
alignof(char);  // 1
alignof(int);   // 4
alignof(int*);  // 8 (64-bit)
alignof(int[4]);// 4 (natural alignment of element is 4)
```
</details>

<details>
<summary>Set alignment of structures:</summary>

* `alignas` takes an expression evaluating 0 or valid value for alignment, a type-id, or a parameter pack.
* only valid values are the powers of two.
* program is ill-formed if largest `alignas` on a declaration is smaller than natural alignment without any `alignas` specifier.

```cpp
// alignas specifier applied to struct
struct alignas(4) foo1  // size = 4, aligned as = 4
{                       // foo1:    +----+
    char a;             // members: |a.b.|
    char b;
};

struct foo1_            // size = 4, aligned as = 1
{
    char a;             // 1 byte
    char b;             // 1 byte
    char _pad0[2];      // 2 bytes
};

// alignas specifier applied to member data declarations
struct foo2             // size = 16, aligned as = 8
{                       // foo2:    +--------+--------+
    alignas(2) char a;  // members: |aa......|bbbb....|
    alignas(8) int b;
};

struct foo2_            // size = 16, aligned as = 4
{
    char a;             // 2 bytes
    char _pad0[6];      // 6 bytes
    int b;              // 4 bytes
    char _pad1[4];      // 4 bytes
};

// the alignas specifier applied to the struct is less than alignas
// specifier applied to member data declaration, thus will be ignored.
struct alignas(4) foo3  // size = 16, aligned as = 8
{                       // foo3:    +--------+--------+
    alignas(2) char a;  // members: |aa......|bbbbbbbb|
    alignas(8) int b;
};

struct foo3_            // size = 16, aligned as = 4
{
    char a;             // 2 byte
    char _pad0[6];      // 6 bytes
    int b;              // 4 bytes
    char _pad1[4];      // 4 bytes
};

alignas(8) int a;       // size = 4, alignment = 8
alignas(256) long b[4]; // size = 32, alignment = 256
```
</details>

<details>
<summary>Use scoped enumerations<span style="color:green">(c++11)</span>:</summary>

* Scoped enumerations do not export their enumerators to the surrounding scope.
* Scoped enumerations have an underlying type so they can be forward declared.
* Values of scoped enumerations do not convert implicitly to int.

```cpp
enum class status: unsigned int; // forward declared

status do_something(); // function declaration/prototype

enum class status : unsigned int
{
    success = 0,
    failed = 1,
    unknown = 0xffff0000U
};

status do_something() { return status::success; }
```
</details>

<details>
<summary>Export enumerators of a scoped enumeration by `using` directive<span style="color:green">(c++20)</span>:</summary>

```cpp
#include <string>

enum class status : unsigned int
{
    success = 0,
    failure = 1,
    unknown = 0xffff0000U
};

std::string_view to_string(status const s)
{
    switch (s)
    {
        using enum status;
        case success: return "success";
        case failure: return "failure";
        case unknown: return "unknown";
    }
}
```
</details>

<details>
<summary>Use override to ensure correct declaration of virtual methods both in base and derived classes:</summary>

```cpp
class base
{
    virtual void foo() = 0;
    virtual void bar() {}
    virtual void baz() = 0;
};

class alpha: public base
{
    virtual void bar() override {}
    virtual void baz() override {}
};

class beta: public alpha
{
    virtual void foo() override {}
};

beta object;
```
</details>

<details>
<summary>Use final to prevent virtual method override:</summary>

```cpp
class base
{
    virtual void foo() = 0;
    virtual void bar() {}
    virtual void baz() = 0;
};

class alpha: public base
{
    virtual void foo() override {}
    virtual void baz() override final {}
};

class beta: public alpha
{
    // won't compile
    virtual void baz() override {}
};

int main()
{
    beta object;
}
```
</details>

<details>
<summary>Use final to prevent inheritance of a class:</summary>

```cpp
class base
{
    virtual void foo() = 0;
    virtual void bar() {}
    virtual void baz() = 0;
};

class derived final: public base
{
    virtual void foo() override {}
    virtual void baz() override {}
};

// won't compile
class prime: public derived
{
};
```
</details>

<details>
<summary>Use range-based for loop to iterate on a range<span style="color:green">(c++11)</span>:</summary>

```cpp
#include <vector>
#include <map>

std::vector<int> get_numbers()
{
    return std::vector<int>{1, 2, 3, 4, 5};
}

std::map<int, double> get_doubles()
{
    return std::map<int, double>{
        {0, 0.0},
        {1, 1.1},
        {2, 2.2}
    };
}

int main()
{
    auto numbers = std::vector<int>{1, 2, 3, 4, 5};
    auto copies = std::vector<int>(numbers.size() * 4);

    for (int element: numbers)
        copies.push_back(element);

    for (int& element: numbers)
        copies.push_back(element);

    for (auto&& element: get_numbers())
        copies.push_back(element);

    for (auto&& [key, value]: get_doubles())
        copies.push_back(key);
}
```
</details>

<details>
<summary>Enable range-based for loops for custom types:</summary>

```cpp
#include <iostream>
#include <stdexcept>
#include <iterator>

template <typename T, std::size_t const S>
class dummy_array
{
    T data[S] = {};

public:
    T const& at(std::size_t const index) const
    {
        if (index < S) return data[index];
        throw std::out_of_range("index out of range");
    }

    void insert(std::size_t const index, T const& value)
    {
        if (index < S) data[index] = value;
        else throw std::out_of_range("index out of range");
    }

    std::size_t size() const { return S; }
};

template <typename T, typename C, std::size_t const S>
class dummy_array_iterator_type
{
public:
    dummy_array_iterator_type(C& collection, std::size_t const index):
        index{index}, collection{collection}
    {}

    bool operator !=(dummy_array_iterator_type const& other) const
    {
        return index != other.index;
    }

    T const& operator *() const
    {
        return collection.at(index);
    }

    dummy_array_iterator_type& operator ++()
    {
        ++index;
        return *this;
    }

    dummy_array_iterator_type operator ++(int)
    {
        auto temp = *this;
        ++*temp;
        return temp;
    }

private:
    std::size_t index;
    C& collection;
};

template <typename T, std::size_t const S>
using dummy_array_iterator = dummy_array_iterator_type<T, dummy_array<T, S>, S>;

template <typename T, std::size_t const S>
using dummy_array_const_iterator = dummy_array_iterator_type<T, dummy_array<T, S> const, S>;

template <typename T, std::size_t const S>
inline dummy_array_iterator<T, S> begin(dummy_array<T, S>& collection)
{
    return dummy_array_iterator<T, S>(collection, 0);
}

template <typename T, std::size_t const S>
inline dummy_array_iterator<T, S> end(dummy_array<T, S>& collection)
{
    return dummy_array_iterator<T, S>(collection, collection.size());
}

template <typename T, std::size_t const S>
inline dummy_array_const_iterator<T, S> begin(dummy_array<T, S> const& collection)
{
    return dummy_array_const_iterator<T, S>(collection, 0);
}

template <typename T, std::size_t const S>
inline dummy_array_const_iterator<T, S> end(dummy_array<T, S> const& collection)
{
    return dummy_array_const_iterator<T, S>(collection, collection.size());
}

int main()
{
    dummy_array<int, 5> numbers;
    numbers.insert(0, 1);
    numbers.insert(1, 2);
    numbers.insert(2, 3);
    numbers.insert(3, 4);
    numbers.insert(4, 5);

    for (auto&& element: numbers)
        std::cout << element << ' ';
    std::cout << '\n';
}
```
</details>

<details>
<summary>Avoid implicit conversion of classes using explicit constructors and conversion operators:</summary>

```cpp
#include <memory>

class string_buffer
{
public:
    explicit string_buffer() {}
    explicit string_buffer(std::size_t const size) {}
    explicit string_buffer(char const* const ptr) {}
    explicit operator bool() const { return false; }
    explicit operator char* const () const { return nullptr; }
};

int main()
{
    std::shared_ptr<char> str;
    string_buffer b1;            // calls string_buffer()
    string_buffer b2(20);        // calls string_buffer(std::size_t const)
    string_buffer b3(str.get()); // calls string_buffer(char const*)

    enum item_size { small, medium, large };

    // implicit conversion cases when explicit not specified
    string_buffer b4 = 'a';      // would call string_buffer(std::size_t const)
    string_buffer b5 = small;    // would call string_buffer(std::size_t const)
}
```
</details>

<details>
<summary>Use unnamed namespaces instead of static globals:</summary>

* First, an unnamed namespaces will be expanded to a compiler defined unique name.
* Second, a `using` directive expands namespace.
* Third, the unnamed namespace will be named.
* Therefore, any function declared in it have local visibility but have external linkage.

*file1.cpp*
```cpp
#include <iostream>

namespace
{
    void print()
    {
        std::cout << "file1" << std::endl;
    }
}

print(); // external linkage, local visibility
```

*file2.cpp*
```cpp
#include <iostream>

namespace
{
    void print()
    {
        std::cout << "file2" << std::endl;
    }
}

print(); // external linkage, local visibility
```
</details>

<details>
<summary>Use an unnamed namespace to use an internal linkage variable as a non-type template argument:</summary>

* Prior to C++11, non-type template arguments could not be named with internal linkage, so `static` variables were not allowed. VC++ compiler still doesn't support it.

```cpp
template <int const& Size>
class test {};

tatic int Size1 = 10;

namespace
{
    int Size2 = 10;
}

test<Size1> t1; // error only on VC++
test<Size2> t2; // okay
```
</details>

<details>
<summary>Use inline namespaces for symbol versioning<span style="color:green">(c++11)</span>:</summary>

* Specialization of a template is required to be done in the same namespace where the template was declared.
* Define the content of the library inside a namespace
* Define each version of the library or parts of it inside an inner inline namespace
* Use preprocessor macros to enable a particular version of the library

```cpp
namespace incorrect_implementation
{
    namespace v1
    {
        template <typename T>
        int test(T value) { return 1; }
    }

    #ifndef _lib_version_1
    using namespace v1;
    #endif

    namespace v2
    {
        template <typename T>
        int test(T value) { return 2; }
    }

    #ifndef _lib_version_2
    using namespace v2;
    #endif
}

namespace broken_client_code
{
    // okay
    auto x = incorrect_implementation::test(42);

    struct foo { int a; };

    // breaks
    namespace incorrect_implementation
    {
        template <>
        int test(foo value) { return value.a; }
    }

    // won't compile
    auto y = incorrect_implementation::test(foor{42});

    // library leaks implementation details
    namespace incorrect_implementation
    {
        namespace version_2
        {
            template<>
            int test(foo value) { return value.a; }
        }
    }

    // okay, but client needs to be aware of implementation details
    auto y = incorrect_implementation::test(foor{42});
}
```

```cpp
namespace correct_implementation
{
    #ifndef _lib_version_1
    inline namespace v1
    {
        template <typename T>
        int test(T value) { return 1; }
    }
    #endif

    #ifndef _lib_version_2
    inline namespace v2
    {
        template <typename T>
        int test(T value) { return 2; }
    }
    #endif
}

namespace working_client_code
{
    // okay
    auto x = correct_implementation::test(42);

    struct foo { int a; };

    namespace correct_implementation
    {
        template <>
        int test(foo value) { return value.a; }
    }

    // okay
    auto y = correct_implementation::test(foor{42});
}
```
</details>

<details>
<summary>Use structured bindings to handle multi-return values<span style="color:green">(c++17)</span>:</summary>

* Only by C++20 structured bindings can include `static` or `thread_local` specifiers in the declaration.
* Only by C++20 `[[maybe_unused]]` attribute can be used in the declaration.
* Only by C++20 a lambda can capture structure binding identifiers.

```cpp
#include <iostream>
#include <set>

int main()
{
    std::set<int> numbers;

    if (auto const [iter, inserted] = numbers.insert(1); inserted)
        std::cout << std::distance(numbers.cbegin(), iter);
}
```
</details>

<details>
<summary>Simplify code with Class Template Argument Deduction<span style="color:green">(c++17)</span>:</summary>

* The type of objects without template arguments are not types, but act as a placeholder for a type that activates CTAD. When compiler encouters it, it builds a set of deduction guides which can be complemented by user with user defined deduction rules.
* CTAD does not occur if the template argument list is present.

```cpp
std::pair p{42, "demo"};    // std::pair<int, char const*>
std::vector v{1, 2};        // std::vector<int>
```
</details>

## Chapter 2/12

<details>
<summary>What is the C++ approach for converting integers and floating-point numbers into strings?</summary>

```cpp
auto si  = std::to_string(42); // "42"
auto sl  = std::to_string(42L); // "42"
auto su  = std::to_string(42u); // "42"
auto sd  = std::to_wstring(42.0); // "42.000000"
auto sld = std::to_wstring(42.0L); // "42.000000"
```
</details>

<details>
<summary>How string represented numbers can be converted to numeric types in C++?</summary>

```cpp
auto i1 = std::stoi("42");
auto i2 = std::stoi("101010", nullptr, 2);
auto i3 = std::stoi("052", nullptr, 8);
auto i7 = std::stoi("052", nullptr, 0);
auto i4 = std::stoi("0x2A", nullptr, 16);
auto i9 = std::stoi("0x2A", nullptr, 0);
auto i10 = std::stoi("101010", nullptr, 2);
auto i11 = std::stoi("22", nullptr, 20);
auto i12 = std::stoi("-22", nullptr, 20);

auto d1 = std::stod("123.45"); // d1 = 123.45000000000000
auto d2 = std::stod("1.2345e+2"); // d2 = 123.45000000000000
auto d3 = std::stod("0xF.6E6666p3"); // d3 = 123.44999980926514
```
</details>

<details>
<summary>What is the second and third parameters of `std::ston` functions family?</summary>

* The input string.
* A pointer that, when not null, will receive the number of characters that were
processed. This can include any leading whitespaces that were discarded,
the sign, and the base prefix, so it should not be confused with the number
of digits the integral value has.
* A number indicating the base; by default, this is 10. Valid numbers of 2 to 36.

```cpp
template <typename T, typename = typename T = std::is_integral_v<T>>
T stoi(std::string const& str, std::size_t* pos = 0, T base = 10);

template <typename F, typename = typename F = std::is_floating_point_v<F>>
F stof(std::string const& str, std::size_t* pos = 0);
```
</details>

<details>
<summary>What characters a valid integral number can have in string to numeric conversion functions?</summary>

* A sign, plus (**+**) or minus (**-**) (optional)
* Prefix **0** to indicate an octal base (optional)
* Prefix **0x** or **0X** to indicate a hexadecimal base (optional)
* A sequence of digits

```cpp
auto i1 = std::stoi("42"); // 42
auto i2 = std::stoi("    42"); // 42
auto i3 = std::stoi("    42fortytwo"); // 42
auto i4 = std::stoi("+42"); // 42
auto i5 = std::stoi("-42"); // -42
```
</details>

<details>
<summary>What exceptions do numeric to string conversion functions throw when conversion fails?</summary>

* `std::invalid_argument`: conversion cannot be performed.
* `std::out_of_range`: converted value is outside the range of the result type.

```cpp
try
{
    auto i1 = std::stoi("");
}
catch (std::invalid_argument const& exp)
{
    std::cerr << exp.what() << '\n';
}

try
{
    auto i2 = std::stoi("12345678901234");
    auto i3 = std::stoi("12345678901234");
}
catch (std::out_of_range const& exp)
{
    std::cerr << exp.what() << '\n';
}
```
</details>

<details>
<summary>What are special floating-point values representing infinity and not-a-number in string to floating-point conversion functions?</summary>

* Decimal floating-point expression (optional sign, sequence of decimal digits with optional point, optional e or E, followed by exponent with optional sign).
* Binary floating-point expression (optional sign, 0x or 0X prefix, sequence of hexadecimal digits with optional point, optional p or P, followed by exponent with optional sign).
* Infinity expression (optional sign followed by case-insensitive INF or INFINITY).
* A non-number expression (optional sign followed by case-insensitive NAN and possibly other alphanumeric characters).

```cpp
auto d1 = std::stod("123.45");       // d1 = 123.45000000000000
auto d2 = std::stod("+123.45");      // d2 = 123.45000000000000
auto d3 = std::stod("-123.45");      // d3 = -123.45000000000000
auto d4 = std::stod(" 123.45");      // d4 = 123.45000000000000
auto d5 = std::stod(" -123.45abc");  // d5 = -123.45000000000000
auto d6 = std::stod("1.2345e+2");    // d6 = 123.45000000000000
auto d7 = std::stod("0xF.6E6666p3"); // d7 = 123.44999980926514
auto d8 = std::stod("INF");          // d8 = inf
auto d9 = std::stod("-infinity");    // d9 = -inf
auto d10 = std::stod("NAN");         // d10 = nan
auto d11 = std::stod("-nanabc");     // d11 = -nan
```
</details>

* [floating literal](https://en.cppreference.com/w/cpp/language/floating_literal "cpp/language/floating_literal")

<details>
<summary>How to get the smallest and largest finite numbers of a type using `std::numeric_limits<T>` class template?</summary>

> Standard types that are not arithmetic types, such as `std::complex<T>` or `std::nullptr_t`, do not have `std::numeric_limits` specializations.

```cpp
#include <limits>

auto min_int = std::numeric_limits<int>::min();
auto max_int = std::numeric_limits<int>::max();

auto min_double = std::numeric_limits<double>::min();
auto low_double = std::numeric_limits<double>::lowest();
auto max_double = std::numeric_limits<double::lowest();
```
</details>

* [\<limits\>](https://en.cppreference.com/w/cpp/headers/limits "cpp/headers/limits")

<details>
<summary>Specify a simple implementation of finding the minimum number in a range of a generic type?</summary>

> Objects in a range should have `<` comparison operator overloaded.

```cpp
#include <limits>

template <typename T, typename Iter>
T minimum(Iter const start, Iter const end)
{
    T latest_minimum = std::numeric_limits<T>::max();

    for (autp i = start; i < end; ++i)
        if (*i < latest_minimum)
            latest_minimum = *i;

    return latest_minimum;
}
```
</details>

<details>
<summary>How can we retrieve the number of bits excluding the sign bit if present, for integral types and the number of bits of the mantissa for floating-point types?</summary>

> `digits` represents the number of bits (excluding the sign bit if present) and padding bits (if any) for integral types and the number of bits of the mantissa for floating-point types.

```cpp
#include <limits>

auto s = std::numeric_limits<short>::digits;
auto d = std::numeric_limits<double>::digits;
```
</details>

<details>
<summary>How can we retrieve the longest possible digits of a decimal type that can be represented without a change?</summary>

```cpp
#include <limits>

auto s = std::numeric_limits<short>::digits10;
auto d = std::numeric_limits<double>::digits10;
```
</details>

<details>
<summary>How `std::numeric_limits<T>` class template can be used to identify if a numeric type is signed?</summary>

```cpp
#include <limits>

auto value_is_signed = std::numeric_limist<T>::is_signed;
```
</details>

<details>
<summary>How `std::numeric_limits<T>` class template can be used to verify a numeric type is an integer?</summary>

```cpp
#include <limits>

auto value_is_integer = std::numeric_limist<T>::is_integer;
```
</details>

<details>
<summary>How to make sure if a floating-point value is exact using `std::numeric_limits<T>` class template?</summary>

```cpp
#include <limits>

auto value_is_exact = std::numeric_limist<T>::is_exact;
```
</details>

<details>
<summary>How to verify if a floating-point value holds infinity value?</summary>

```cpp
#include <limits>

auto value_has_infinity = std::numeric_limist<T>::has_infinity;
```
</details>

<details>
<summary>How can we get the minimum and maximum value that a random engine can generate?</summary>

> Except for `random_device`, all engines produce numbers in a uniform distribution.

```cpp
#include <random>

auto min = std::mt19937::min();
auto max = std::mt19937::max();
```
</details>

<details>
<summary>How seed a random generator to initialize the algorithm corporated within it?</summary>

> Random generators can be seeded using their constructors or the `seed()` method.  
Note that `random_device` cannot be seeded.

```cpp
#include <random>

std::random_device seeder;
std::mt19937 generator1{seeder()};

std::mt19937 generator2;
generator2.seed(seeder());
```
</details>

<details>
<summary>What method does the random engines use to generate a random number?</summary>

> The function call operators of random engines are overloaded and generate a new number uniformly distributed between `min()` and `max()`:

```cpp
#include <random>

std::random_device seeder;
std::mt19937 generator{seeder()};
auto number = generator();
```
</details>

<details>
<summary>How can we discard generated number of a random engine?</summary>

```cpp
#include <random>

std::mt19937 generator{};
generator.discard(4); // discard 4 numbers
```
</details>

<details>
<summary>How to initialize all bits of internal state of a psudo-random number generator?</summary>

> The Mersenne twister engine has a bias toward producing some values repeatedly and omitting others, thus generating numbers not in a uniform distribution, but rather in a binomial or Poisson distribution.

```cpp
#include <random>
#include <functional>

int main()
{
    std::random_device seeder;

    std::array<int, std::mt19937::state_size> seed_data{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(seeder));
    std::seed_seq seeds(std::begin(seed_data), std::end(seed_data));
    std::mt19937 generator{seeds};
    std::uniform_int_distribution<> dist{0, 10}; // [0, 10)
    int random_number = dist(generator);
}
```
</details>

<details>
<summary>What types can be used to create a cooked user-defined literal?</summary>

```cpp
T operator "" _suffix(unsigned long long int);
T operator "" _suffix(long double);
T operator "" _suffix(char);
T operator "" _suffix(wchar_t);
T operator "" _suffix(char16_t);
T operator "" _suffix(char32_t);
T operator "" _suffix(char const *, std::size_t);
T operator "" _suffix(wchar_t const *, std::size_t);
T operator "" _suffix(char16_t const *, std::size_t);
T operator "" _suffix(char32_t const *, std::size_t);
```
</details>

<details>
<summary>How to create a user-defined literal in order to construct a type in compile time?</summary>

```cpp
namespace units
{
    inline namespace literals
    {
        inline namespace units_literals
        {
            constexpr size_t operator ""_KB(unsigned long long const size)
            {
                return static_cast<size_t>(size * 1024);
            }
        }
    }
}

int main()
{
    using namespace units::units_literals;

    size_t bytes = "1024"_KB;
}
```
</details>

<details>
<summary>Express different types of strings that string literals can generate?</summary>

```cpp
#include <string>

using namespace std::string_literals;

auto s1{ "text"s }; // std::string
auto s2{ L"text"s }; // std::wstring
auto s3{ u8"text"s }; // std::u8string
auto s3{ u"text"s }; // std::u16string
auto s4{ U"text"s }; // std::u32string

using namespace std::string_view_literals;

auto s5{ "text"sv }; // std::string_view
```
</details>

<details>
<summary>Express different types of chrono objects that chrono literals can generate?</summary>

```cpp
#include <chrono>

using namespace std::chrono_literals;

auto timer {2h + 42min + 15s}; // std::chrono::duration<long long>

auto year { 2035y }; // std::chrono::year (c++20)
auto day { 15d }; // std::chrono::day (c++20)
```
</details>

<details>
<summary>Express how literals can be used to construct a `std::complex` object?</summary>

```cpp
#include <complex>

using namespace std::complex_literals;

auto c{ 12.0 + 4.2i }; // std::complex<double>
```
</details>

<details>
<summary>What signatues can a literal operator or a literal operator template have to overload user-defined literals?</summary>

> Always define literals in a separate namespace to avoid name clashes.

```cpp
T operator ""_suffix(char const*);

template <char...>
T operator ""_suffix();
```
</details>

<details>
<summary>How literal operators or literal operator templates can be used to construct a numberic value by its binary representation?</summary>

```cpp
namespace binary
{
    using numeric = unsigned int;

    inline namespace binary_literals
    {
        namespace binary_internals
        {
            template <typename T, char... bits>
            struct bit_seq;

            template <typename T, '0', char... bits>
            struct bit_seq
            {
                static constexpr T value { bit_seq<T, bits...>::value };
            };

            template <typename T, '1', char... bits>
            struct bit_seq
            {
                static constexpr T value {
                    bit_seq<T, bits...>::value | static_cast<T>(1 << sizeof...(bits))
                };
            };

            template <typename T>
            struct bit_seq<T>
            {
                static constexpr T value{0};
            };
        }

        template <char... bits>
        constexpr numeric operator ""_byte()
        {
            static_assert(sizeof...(bits) <= 32, "binary literals only holds 32 bits");

            return binary_internals::bit_seq<numeric, bits...>::value;
        }
    }
}
```
</details>

<details>
<summary>How to create strings containing special characters without escaping them?</summary>

```cpp
#include <string>

using namespace std::string_literals;

auto filename { R"(C:\Users\Brian\Documents\)"s };
auto pattern { R"((\w[\w\d]*)=(\d+))"s };
```
</details>

<details>
<summary>Express different types of strings that raw string literals can generate?</summary>

```cpp
#include <string>

using namespace std::string_literals;

auto s1{ R"(text)"s }; // std::string
auto s2{ LR"(text)"s }; // std::wstring
auto s3{ u8R"(text)"s }; // std::u8string
auto s3{ uR"(text)"s }; // std::u16string
auto s4{ UR"(text)"s }; // std::u32string

using namespace std::string_view_literals;

auto s5{ R"text"sv }; // std::string_view
```
</details>

<details>
<summary>How to convert a string to lowercase or uppercase?</summary>

```cpp
#include <string>

template <typename CharT>
using tstring = std::basic_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
inline tstring<CharT> to_upper(tstring<CharT> text)
{
    std::transform(std::begin(text), std::end(text), std::begin(text), toupper);
    return text;
}

template <typename CharT>
inline tstring<CharT> to_upper(tstring<CharT>&& text)
{
    std::transform(std::begin(text), std::end(text), std::begin(text), toupper);
    return text;
}

template <typename CharT>
inline tstring<CharT> to_lower(tstring<CharT> text)
{
    std::transform(std::begin(text), std::end(text), std::begin(text), tolower);
    return text;
}

template <typename CharT>
inline tstring<CharT> to_lower(tstring<CharT>&& text)
{
    std::transform(std::begin(text), std::end(text), std::begin(text), tolower);
    return text;
}
```
</details>

<details>
<summary>How to reverse a string?</summary>

```cpp
#include <string>

template <typename CharT>
using tstring = std::basic_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
inline tstring<CharT> reverse(tstring<CharT> text)
{
    std::reverse(std::begin(text), std::end(text));
    return text;
}

template <typename CharT>
inline tstring<CharT> reverse(tstring<CharT>&& text)
{
    std::reverse(std::begin(text), std::end(text));
    return text;
}
```
</details>

<details>
<summary>How to trim a string?</summary>

```cpp
#include <string>
#include <utility>

template <typename CharT>
using tstring = std::basic_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
inline tstring<CharT> trim(tstring<CharT> const& text)
{
    tstring<CharT>::size first{text.find_first_not_of(' ')};
    tstring<CharT>::size last{text.find_last_not_of(' ')};
    return text.substr(first, (last - first + 1));
}
```
</details>

<details>
<summary>How to remove all occurances of a character from a string?</summary>

```cpp
#include <string>
#include <algorithm>

template <typename CharT>
using tstring = std::basic_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
inline tstring<CharT> remove(tstring<CharT> text, CharT const character)
{
    auto last = std::remove_if(std::begin(text), std::end(text), [character](CharT const c) { return c == character; });
    text.erase(last, std::end(text));
    return text;
}
```
</details>

<details>
<summary>How to split a string based on user specified delimiter?</summary>

```cpp
#include <string>
#include <sstream>
#include <vector>

template <typename CharT>
using tstring = std::basic_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
using tstringstream = std::basic_stringstream<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
inline std::vector<tstring<CharT>> split(tstring<CharT> text, CharT const delimiter)
{
    auto sstream = tstringstream<CharT>{text};
    auto tokens = std::vector<tstring<CharT>>{};
    auto token = tstring<CharT>{};

    while (std::getline(sstream, token, delimiter))
    {
        if (!token.empty())
            tokens.push_back(token);
    }

    return tokens;
}
```
</details>

<details>
<summary>How a `regex` object can be constructed?</summary>

```cpp
#include <string>
#include <regex>

using namespace std::string_literals;

std::string pattern{R"(...)"};

std::regex srx{pattern};
std::regex lrx{R"(...)"s};
```
</details>

* [Regular Expressions Library](https://cppreference.com/w/cpp/regex "cpp/regex")

<details>
<summary>How to make regular expressions case insensitive?</summary>

```cpp
std::regex irx{R"(...)"s, std::regex_constants::icase};
```
</details>

* [std::regex\_constants](https://cppreference.com/w/cpp/regex/syntax_option_type "cpp/regex/syntax_option_type")

<details>
<summary>How regular expressions can be used to verify the format of a string?</summary>

```cpp
#include <string>
#include <regex>

template <typename CharT>
using tstring = std::baisc_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>;

template <typename CharT>
using tregex = std::basic_regex<CharT>;

template <typename CharT>
bool matches(tstring<CharT> const& text, tstring<CharT const& pattern)
{
    std::basic_regex<CharT> rx{pattern, std::regex_constants::icase};
    return std::regex_match(text, rx);
}

int main()
{
    std::string text{R"(https://github.com/briansalehi/references)"};
    std::string pattern{R"((\w+)://([\w.]+)/([\w\d._-]+)/([\w\d._-]+)[.git]?)"};

    if(matches(text, pattern))
        std::cout << text << '\n';
    else
        std::cerr << "invalid repository link!\n";
}
```
</details>

* [std::basic\_regex](https://cppreference.com/w/cpp/regex/basic_regex "cpp/regex/basic_regex")
* [std::regex\_match](https://cppreference.com/w/cpp/regex/regex_match "cpp/regex/regex_match")

<details>
<summary>How to retrieve submatches of a regular expresssion matched with a string?</summary>

> The `std::regex_match()` method has overloads that take a reference to a `std::match_results` object to store the result of the match.

> If there is no match, then `std::match_results` is empty and its size is 0. Otherwise, its size is 1, plus the number of matched subexpressions.

> The class template `std::sub_match` represents a sequence of characters that matches a capture group; this class is actually derived from std::pair, and its first and second members represent iterators to the first and the one- past-end characters in the match sequence. If there is no match sequence, the two iterators are equal:

* `typedef sub_match<const char *> csub_match;`
* `typedef sub_match<const wchar_t *> wcsub_match;`
* `typedef sub_match<string::const_iterator> ssub_match;`
* `typedef sub_match<wstring::const_iterator> wssub_match;`

> The class template `std::match_results` is a collection of matches; the first element is always a full match in the target, while the other elements are matches of subexpressions:

* `typedef match_results<const char *> cmatch;`
* `typedef match_results<const wchar_t *> wcmatch;`
* `typedef match_results<string::const_iterator> smatch;`
* `typedef match_results<wstring::const_iterator> wsmatch;`

```cpp
#include <string>
#include <regex>

int main()
{
    std::string text{R"(https://github.com/briansalehi/references)"};
    std::string pattern{R"((\w+)://([\w.]+)/([\w\d._-]+)/([\w\d._-]+)[.git]?)"};

    std::regex rx{pattern, std::regex_constants::icase};
    std::smatch matches;
    bool matched = std::regex_match(text, matches, rx);

    if (auto [match, protocol, domain, username, project] = matches; matched)
        std::cout << project << " owned by " << username
                  << " hosted on " << domain
                  << " using " << protocol << " protocol\n";
```
</details>

* [std::sub\_match](https://cppreference.com/w/cpp/regex/sub_match "cpp/regex/sub_match")
* [std::match\_results](https://cppreference.com/w/cpp/regex/match_results "cpp/regex/match_results")

<details>
<summary>How can we use different regular expression engines?</summary>

> The C++ standard library supports six regular expression engines:

* ECMAScript (default)
* basic POSIX
* extended POSIX
* awk
* grep
* egrep (grep with the option -E)

```cpp
#include <regex>

std::regex pattern{R"(...)", std::regex_constants::egrep};
```
</details>

* [std::regex\_constants](https://cppreference.com/w/cpp/regex/syntax_option_type "cpp/regex/syntax_option_type")

<details>
<summary>How to search for the first occurance of a pattern in a string using regular expressions?</summary>

```cpp
#include <string>
#include <regex>

std::string text {
R"(
# server address
address = 123.40.94.215
port=22

# time to live
ttl = 5
)"};

int main()
{
    std::string pattern{R"(^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,:-]*)$)"};
    std::regex rx{pattern, std::regex_constants::icase};
    std::smatch match{};

    if (std::string variable, value; std::regex_search(text, match, rx))
    {
        variable = match[1];
        value = match[2];
    }
}
```
</details>

* [std::regex\_search](https://cppreference.com/w/cpp/regex/regex_search "cpp/regex/regex_search")

<details>
<summary>How to find all occurences of a regular expression in a given text?</summary>

> The iterators available in the regular expressions standard library are as follows:

* `std::regex_interator`: A constant forward iterator used to iterate through the occurrences of a pattern in a string. It has a pointer to an `std::basic_regex` that must live until the iterator is destroyed. Upon creation and when incremented, the iterator calls `std::regex_search()` and stores a copy of the `std::match_results` object returned by the algorithm.
* `std::regex_token_iterator`: A constant forward iterator used to iterate through the submatches of every match of a regular expression in a string. Internally, it uses a `std::regex_iterator` to step through the submatches. Since it stores a pointer to an `std::basic_regex` instance, the regular expression object must live until the iterator is destroyed.

> The token iterators can return the unmatched parts of the string if the index of the subexpressions is -1, in which case it returns an `std::match_results` object that corresponds to the sequence of characters between the last match and the end of the sequence:

```cpp
#include <string>
#include <regex>

std::string text {
R"(
# server address
address = 123.40.94.215
port=22

# time to live
ttl = 5
)"};

int main()
{
    std::string pattern{R"(^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,:-]*)$)"};
    std::regex rx{pattern, std::regex_constants::icase};
    std::sregex_iterator end{};

    // iterate through regex matches
    for (auto it = std::sregex_iterator{std::begin(text), std::end(text), rx};
            it ! end; ++it)
    {
        std::string variable = (*it)[1];
        std::string value = (*it)[2];
    }

    // iterate through unmatched tokens
    for (auto it = std::sregex_iterator{std::begin(text), std::end(text), rx, -1};
            it ! end; ++it)
    {
        std::string variable = (*it)[1];
        std::string value = (*it)[2];
    }

    // iterate through tokens of regex matches
    std::sregex_token_iterator tend{};
    for (auto it = std::sregex_token_iterator{std::begin(text), std::end(text), rx};
            it ! tend; ++it)
    {
        std::string token = *it;
    }
}
```
</details>

* [std::sregex\_iterator](https://cppreference.com/w/cpp/regex/sregex_iterator "cpp/regex/sregex_iterator")
* [std::sregex\_token\_iterator](https://cppreference.com/w/cpp/regex/sregex_token_iterator "cpp/regex/sregex_token_iterator")

<details>
<summary>How to replace the content of a string using regular expressions?</summary>

```cpp
#include <string>
#include <regex>

int main()
{
    std::string text{"this is a example with a error"};
    std::regex rx{R"(\ba ((a|e|i|o|u)\w+))"};
    std::regex_replace(text, rx, "an $1");
}
```
</details>

* [std::regex\_replace](https://cppreference.com/w/cpp/regex/regex_replace "cpp/regex/regex_replace")

<details>
<summary>How to reposition submatches of a string using regular expressions?</summary>

> Apart from the identifiers of the subexpressions (`$1`, `$2`, and so on), there are other identifiers for the entire match (`$&`), the part of the string before the first match ($\`), and the part of the string after the last match (`$'`).

```cpp
#include <string>
#include <regex>

int main()
{
    std::string text{"current date: 3 10 2022"};
    std::regex pattern{R"((\d{1,2})\s*(\d{1,2})\s*(\d{2,4}))"};
    std::string reformatted = std::regex_replace(text, pattern, R"([$`] $2 $1 $3 [$'])");
}
```
</details>

<details>
<summary>How `std::string_view` can be used to prevent string copy?</summary>

> Passing `std::basic_string_view` to functions and returning `std::basic_string_view` still creates temporaries of this type, but these are small-sized objects on the stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore, they should incur fewer performance costs than allocating heap space and copying data.

```cpp
#include <string_view>

std::string_view trim_view(std::string_view str)
{
    auto const pos1{ str.find_first_not_of(" ") };
    auto const pos2{ str.find_last_not_of(" ") };
    str.remove_suffix(str.length() - pos2 - 1);
    str.remove_prefix(pos1);
    return str;
}

auto sv1{ trim_view("sample") };
auto sv2{ trim_view(" sample") };
auto sv3{ trim_view("sample ") };
auto sv4{ trim_view(" sample ") };

std::string s1{ sv1 };
std::string s2{ sv2 };
std::string s3{ sv3 };
std::string s4{ sv4 };
```
</details>

<details>
<summary>How to construct a `std::basic_string` from a `std::basic_string_view`?</summary>

> Converting from an `std::basic_string_view` to an `std::basic_string` is not possible. You must explicitly construct an `std::basic_string` object from a `std::basic_string_view`.

```cpp
std::string_view sv{ "demo" };
std::string s{ sv };
```
</details>

<details>
<summary>`std::format` will be written when supported by all compilers.</summary>

</details>

## Chapter 3/12
## Chapter 4/12
## Chapter 5/12
## Chapter 6/12
## Chapter 7/12
## Chapter 8/12
## Chapter 9/12
## Chapter 10/12
## Chapter 11/12
## Chapter 12/12

<details>
<summary>Specify module behaviors:</summary>

* Modules are only imported once and the order they're imported in does not matter.
* Modules do not require splitting interfaces and implementation in different source files, although this is still possible.
* Modules reduce compilation time. The entities exported from a module are described in a binary file that the compiler can process faster than traditional precompiled headers.
* Exported files can potentially be used to build integrations with C++ code from other languages.
</details>

<details>
<summary>Express module parts:</summary>

* Global module fragment
* Module declaration
* Module purview

```cpp
module;

// global module fragment
#define X
#include "code.h"

// module declaration
export module demo;

// module preamble
import std.core;
import :part;

// module purview
export void print() { std::cout << "demo\n"; }
```
</details>

<details>
<summary>Specify requirements on template arguments with concepts:</summary>

```cpp
```
</details>


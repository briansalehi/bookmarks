# Beginning x64 Assembly Programming
<img src="covers/9781484250761.jpg" width="200"/>

## Chapter 1/43 <sup>(published)</sup>

<details>
<summary>Compile an x64 assembly program?</summary>

> ```nasm
> section .data
>     message db "sample assembly program", 10, 0
>     length equ $ - message
>
> section .bss
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     mov rax, 1
>     mov rdi, 1
>     mov rsi, message
>     mov rdx, length
>     syscall
>
>     mov rsp, rbp
>     pop rbp
>
>     mov rax, 60
>     mov rdi, 0
>     syscall
> ``````
>
> ```make
> sample: sample.o
>     gcc -Wall -g3 -Og -no-pie sample.o -o sample
> sample.o: sample.asm
>     nasm -f elf64 -g -F dwarf sample.asm -l sample.lst
> ``````
>
> ---
> **Resources**
> ---
> **References**
> - [nasm reference manual](https://www.nasm.us/doc/)
> - [gcc reference manual](https://gcc.gnu.org/onlinedocs/)
> - [make reference manual](https://www.gnu.org/software/make/manual/html_node/)
> ---
</details>

<details>
<summary>Write exit procedure in x64 Assembly?</summary>

> ```nasm
> section .data
> section .bss
> section .text
>     global main
>
> main:
>     mov rax, 60
>     mov rdi, 0
>     syscall
> ``````
>
> ---
> **Resources**
> - 1
> ---
> **References**
> ---
</details>

## Chapter 2/43 <sup>(published)</sup>

<details>
<summary>Convert decimal, binary, and hexadecimal representations of integral and floating point numbers?</summary>

>
>
> ---
> **Resources**
> - 2
>
> ---
> **References**
> - [IEEE-754](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/)
---
</details>

<details>
<summary>Name x64 registers?</summary>

> * rax
> * rbx
> * rcx
> * rdx
> * rsi
> * rdi
> * rbp
> * rsp
> * r8
> * r9
> * r10
> * r11
> * r12
> * r13
> * r14
> * r15
>
> ---
> **Resources**
> - 2
>
> ---
> **References**
> ---
</details>

<details>
<summary>What is the name of <b>Instruction Pointer</b> register?</summary>

> `rip`
>
> ---
> **Resources**
> - 2
>
> ---
> **References**
> ---
</details>

<details>
<summary>Name the flag registers?</summary>

> Name|Symbol|Bit|Content
> ---|---|---|---
> Carry|CF|0|Previous instruction had a carry
> Parityp|F|2|Last byte has even number of 1s
> Adjust|AF|4|BCD operations
> Zero|ZF|6|Previous instruction resulted a zero
> Sign|SF|8|Previous instruction resulted in most significant bit equal to 1
> Direction|DF|10|Direction of string operations (increment or decrement)
> Overflow|OF|11|Previous instruction resulted in overflow
>
> ---
> **Resources**
> - 2
>
> ---
> **References**
> ---
</details>

<details>
<summary>Name SIMD registers?</summary>

> `xmm`
> `ymm`
> `zmm`
>
> ---
> **Resources**
> - 2
>
> ---
> **References**
> ---
</details>

## Chapter 3/43 <sup>(published)</sup>

<details>
<summary>Debug a compiled program with gdb?</summary>

> ```sh
> gdb --quiet executable
> ``````
>
> ---
> **Resources**
> - 3
>
> ---
> **References**
> - [GDB User Manual](https://sourceware.org/gdb/current/onlinedocs/gdb/)
> ---
</details>

<details>
<summary>List source lines in debugging?</summary>

> ```gdb
> list
> list 10
> `help list` or `h l`
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Change the line number of source listing?</summary>

> ```gdb
> show listsize
> set listsize 20
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Set disassembly flavor in gdb?</summary>

> ```gdb
> show disassembly-flavor
> set disassembly-flavor intel
> set disassembly-flavor att
> help set disassembly-flavor
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Store gdb configurations in file for future use?</summary>

> ```sh
> echo 'set disassembly-flavor intel' >> $HOME/.gdbinit
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Disassemble a function or line of source in gdb?</summary>

> ```gdb
> disassemble main
> disassemble 'path/to/source.cpp'::func
> help disassemble
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Examine an address in memory in gdb?</summary>

> ```gdb
> x/s 0x654321
> x/s &message
> x/d 0x654321
> x/x $rip
> help x
> ``````
>
> ---
> **Resources**
> - 3
>
> ---
> **References**
> ---
</details>

<details>
<summary>Set breakpoints in gdb?</summary>

> ```gdb
> break main
> help break
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Start execution of the debugging program in gdb?</summary>

> ```gdb
> run
> help run
> ``````
>
> ---
> **Resources**
> - 3
>
> ---
> **References**
> ---
</details>

<details>
<summary>Inspect registers in gdb?</summary>

> ```gdb
> info registers
> info all-registers
> help info registers
> help info all-registers
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Inspect the breakpoint, stack, threads and other resources of the debugging program in gdb?</summary>

> ```gdb
> info breakpoints
> info stack
> info threads
> info source
> help info breakpoints
> help info stack
> help info threads
> help info source
> ``````

> **Resources**
> - 3
>
> ---
> **References**
> ---
</details>

<details>
<summary>Manipulate breakpoints in gdb?</summary>

> ```gdb
> disable breakpoint 1
> enable breakpoint 1
> delete breakpoint 1
> help disable breakpoint
> help enable breakpoint
> help delete breakpoint
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Change executation of the debugging program in gdb?</summary>

> ```gdb
> continue
> next
> step
> help continue
> help next
> help step
> help finish
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Print variables through debugging session?</summary>

> ```gdb
> print
> help print
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

<details>
<summary>Enable TUI in gdb:</summary>

> ```gdb
> tui enable
> help tui
> ``````
>
> ---
> **Resources**
> - 3
> ---
> **References**
> ---
</details>

## Chapter 4/43 <sup>(published)</sup>

<details>
<summary>Create values in data section of memory?</summary>

> ```nasm
> section .data
>     message db "sample program", 10, 0
>     message_length equ $ - message - 1
>     pi dq 3.14
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; write
>     mov rax, 1
>     mov rdi, 1
>     mov rsi, message
>     mov rdx, message_length
>     syscall
>
>     mov rsp, rbp
>     pop rbp
>
>     ; exit
>     mov rax, 60
>     mov rdi, 0
>     syscall
> ``````
>
> ---
> **Resources**
> - 4
> ---
> **References**
> ---
</details>

<details>
<summary>Use external functions from C in x64 assembly code?</summary>

> ```nasm
> extern printf
>
> section .data
>     string_fmtstr db "%s", 10, 0
>     string db "sample program", 0
>
>     integer_fmtstr db "%d", 10, 0
>     number dd 37
>
>     float_fmtstr db "%2.6f", 10, 0
>     pi dq 3.141592
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; printf
>     mov rax, 0 ; do not use xmm registers
>     mov rdi, string_fmtstr
>     mov rsi, string
>     call printf
>
>     ; printf
>     mov rax, 0 ; do not use xmm registers
>     mov rdi, integer_fmtstr
>     mov rsi, [number]
>     call printf
>
>     ; printf
>     mov rax, 1 ; use xmm registers
>     movq xmm0, [pi]
>     mov rdi, float_fmtstr
>     call printf
>
>     ; exit
>     mov rax, 60
>     mov rdi, 0
>     syscall
> ``````
>
> ---
> **Resources**
> - 4
>
> ---
> **References**
> ---
</details>

<details>
<summary>Exit program without directly writing the exit syscall?</summary>

> ```nasm
> section .text
>     global main
>
> main:
>     ret
> ``````
>
> ---
> **Resources**
> - 4
> ---
> **References**
> ---
</details>

## Chapter 5/43

<details>
<summary>Nothing to import.</summary>

</details>

## Chapter 6/43

<details>
<summary>Nothing to import.</summary>

</details>

## Chapter 7/43 <sup>(published)</sup>

<details>
<summary>Conditionally change the execution flow?</summary>

* je: jump if equal
* jne: jump if not equal
* jg: jump if greater
* jge: jump if greater or equal
* jl: jump if lower
* jle: jump if lower or equal
* ja: jump if above
* jae: jump if above or equal
* jb: jump if below
* jbe: jump if below or equal

```nasm
extern printf

section .data
    numerator dq 5
    denominator dq 6
    greater_str db "greater", 10, 0
    less_str db "less", 10, 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    mov rax, [numerator]
    mov rbx, [denominator]
    cmp rax, rbx
    jge greater

    mov rax, 0
    mov rdi, greater_str
    call printf
    jmp exit

greater:
    mov rax, 0
    mov rdi, less_str
    call printf

exit:
    xor rax, rax
    mov rsp, rbp
    pop rbp
    ret
```

```gdb
break main
run
next
info rflags
```
</details>

<details>
<summary>Repeat execution of a code section by manually counting down?</summary>

```nasm
extern printf

section .data
    counter dq 3
    fmt db "%d", 10, 0

section .text
    global main

main:
    ; make stack frame
    push rbp
    mov rbp, rsp

    ; store initial value
    mov rcx, [counter]

    ; print initial value
    mov rax, 0
    mov rdi, fmt
    mov rsi, rcx
    call printf

repeat:
    ; repeat decrementing until value reached zero
    dec rcx
    cmp rcx, 0
    jne repeat

    ; print result
    mov rax, 0
    mov rdi, fmt
    mov rsi, rcx
    call printf

    ; remove stack frame
    mov rsp, rbp
    pop rbp

    ; return zero value
    xor rax, rax
    ret
```
</details>

<details>
<summary>Repeat execution of a code section by automatically counting down?</summary>

```nasm
extern printf

section .data
    fmt db "%i", 10, 0
    initial dq 3

section .text
    global main

main:
    ; make stack frame
    push rbp
    mov rbp, rsp

    ; assign initial value
    mov rcx, [initial]

    ; print initial value
    xor rax, rax
    mov rdi, fmt
    mov rsi, rcx
    call printf

    ; printf modified rcx
    mov rcx, [initial]

repeat:
    ; decrement rcx until reached zero
    loop repeat

    ; print result
    xor rax, rax
    mov rdi, fmt
    mov rsi, rcx
    call printf

    ; remove stack frame
    mov rsp, rbp
    pop rbp

    ; return value
    xor rax, rax
    xor rdi, rdi
    ret
```
</details>

## Chapter 8/43 <sup>(published)</sup>

<details>
<summary>Consecutively store a sequence of data into read-only memory section?</summary>

> ```nasm
> section .data
>     word_array times 5 dw 0 ; array of 5 words containing 0
> ``````
>
> ---
> **Resources**
> - 8
> ---
> **References**
> ---
</details>

<details>
<summary>Preserve uninitialized variables in a writable memory section?</summary>

> ```nasm
> section .bss
>     bvar resb 10
>     wvar resw 5
>     dvar resd 1
>     qvar resq 100
> ``````
>
> ---
> **Resources**
> - 8
>
> ---
> **References**
> ---
</details>

<details>
<summary>Load the address of an array into a register to run operations on?</summary>

> ```nasm
> section .data
>     text db "abc", 0
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; load address of first character
>     lea al, [text]
>
>     ; point of second character
>     inc rax
>
>     ; load address of third character
>     lea al, [text + 2]
>
>     mov rsp, rbp
>     pop rbp
>
>     xor rax, rax
>     ret
> ``````
>
> ---
> **Resources**
> - 8
> ---
> **References**
> ---
</details>

<details>
<summary>Read the ELF header of an executable object?</summary>

> ```sh
> readelf --file-header ./program
> ``````
>
> ---
> **Resources**
> - 8
> ---
> **References**
> ---
</details>

<details>
<summary>Read symbols of an executable object?</summary>

> ```sh
> readelf --symbols ./program | grep -E 'main|start|Num:.*' --color
> ``````
>
> ---
> **Resources**
> - 8
>
> ---
> **References**
> ---
</details>

<details>
<summary>Sort executable object symbols based on its memory locations?</summary>

> ```sh
> readelf --symbols ./program | sort -k 2 -r
> ``````
>
> ---
> **Resources**
> - 8
>
> ---
> **References**
> ---
</details>

## Chapter 9/43 <sup>(published)</sup>

<details>
<summary>Make arithmetic operations on integers?</summary>

> * `mul` multiplies unsigned integers
> * `imul` multiplies signed integers
> * `imul` will store the lower 64 bits of the resulting product in rax and the upper 64 bits in rdx.
> * `idiv` will divide the dividen in rdx:rax by the divisor in the source operand and store the integer result in rax.
>
> ```nasm
> section .data
>     number1 dq 36
>     number2 dq 3
>
> section .bss
>     result resq 1
>     modulo resq 1
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; addition
>     mov rax, [number1]
>     add rax, [number2]
>     mov [result], rax ; 39
>
>     ; subtration
>     mov rax, [number1]
>     sub rax, [number2]
>     mov [result], rax ; 33
>
>     ; increment
>     mov rax, [number1]
>     inc rax
>     mov [result], rax
>
>     ; shift arithmetic left
>     mov rax, [number1]
>     sal rax, 2 ; multiply by 4
>     mov [result], rax
>
>     ; shift arithmetic right
>     mov rax, [number1]
>     sar rax, 2 ; divide by 4
>     mov [result], rax
>
>     ; multiply
>     mov rax, [number2]
>     imul qword[number2] ; multiplly rax with number2
>     mov [result], rax
>
>     ; divide
>     mov rax, [number1]
>     mov rdx, 0 ; division uses rdx:rax convention
>     idiv qword[number2]
>     mov [result], rax
>     mov [modulo], rdx
>
>     mov rsp, rbp
>     pop rbp
>
>     xor rax, rax
>     ret
> ``````
>
> ---
> **Resources**
> - 9
> ---
> **References**
> ---
</details>

## Chapter 10/43 <sup>(published)</sup>

<details>
<summary>Monitor `rsp` register and watch the changes after pushing into and popping from the stack to reverse a string:</summary>

```nasm
section .data
    text db "Brian Salehi", 10, 0
    length equ $ - text - 1

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; print initial sequence
    mov rax, 1
    mov rdi, 1
    mov rsi, text
    mov rdx, length
    syscall

    ; prepare for reverse operation
    xor rax, rax
    mov rbx, text
    mov rcx, length
    xor r12, r12 ; to store index

store_loop:
    ; push sequence to stack
    mov al, byte [rbx+r12]
    push rax
    inc r12
    loop store_loop

    xor rax, rax
    mov rbx, text
    mov rcx, length
    xor r12, r12

reverse_loop:
    ; pop sequence from stack
    pop rax
    mov byte [rbx+r12], al
    inc r12
    loop reverse_loop
    mov byte [rbx+r12], 0

    ; print reversed string
    mov rax, 1
    mov rdi, 1
    mov rsi, text
    mov rdx, length
    syscall

    mov rsp, rbp
    pop rbp

    xor rax, rax
    ret
```
</details>

## Chapter 11/43 <sup>(published)</sup>

<details>
<summary>Specify how many bits each floating point number occupies for exponent and fraction?</summary>

* A single-precision number is 32 bits, 1 sign bit, 8 exponent bits, and 23 fraction bits.

```txt
S   EEEEEEEE        FFFFFFFFFFFFFFFFFFFFFFF
0   1      8        9                     31
```

* A double-precision number is 64 bits, 1 sign bit, 11 exponent bits, and 52 fraction bits.

```
S   EEEEEEEEEEE     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
0   1         11    12                                                 63
```
</details>

<details>
<summary>Do arithmetic operations with floating point numbers in assembly:</summary>

* Single precision floating point arithmetic instructions are postfixed with ss
* Double precision floating point arithmetic instructions are postfixed with sd

```nasm
extern printf

section .data
    number1 dq 9.0
    number2 dq 73.0
    fmt db "%f %f", 10, 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    ; print floating-point numbers
    movsd xmm0, [number1]
    movsd xmm1, [number2]
    mov rax, 2 ; two floats
    mov rdi, fmt
    call printf

    ; sum floating-point numbers
    movsd xmm0, [number1]
    addsd xmm0, [number2]

    ; difference
    movsd xmm0, [number1]
    subsd xmm0, [number2]

    ; multiplication
    movsd xmm0, [number1]
    mulsd xmm0, [number2]

    ; division
    movsd xmm0, [number1]
    divsd xmm0, [number2]

    ; square root
    sqrtsd xmm0, [number1]

    mov rsp, rbp
    pop rbp

    xor rax, rax
    ret
```
</details>

## Chapter 12/43 <sup>(published)</sup>

<details>
<summary>Abbreviate function epilogue by using `leave` instruction:</summary>

> ```nasm
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 12
>
> ---
> **References**
> ---
</details>

<details>
<summary>Call a procedure enclosed with a stack frame?</summary>

> ```nasm
> section .data
>     radius dq 10.0
>     pi dq 3.14
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     call area
>     movsd xmm1, [radius]
>
>     xor rax, rax
>     leave
>     ret
>
> area:
>     push rbp
>     mov rbp, rsp
>
>     movsd xmm0, [radius]
>     mulsd xmm0, [radius]
>     mulsd xmm0, [pi]
>
>     xor rax, rax
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 12
> ---
> **References**
> ---
</details>

<details>
<summary>Return integral or floating-point values from functions:</summary>

* Use `xmm0` register for floating-point values and `rax` register for other values.

```nasm
section .data
    val dq 0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    call fail_func
    xor rax, rax

    call success_func
    xor rax, rax

    leave
    ret

fail_func:
    push rbp
    mov rbp, rsp

    mov rax, 1

    leave
    ret

success_func:
    push rbp
    mov rbp, rsp

    mov rax, 0

    leave
    ret
```
</details>

<details>
<summary>Use local sections in a function to declare local variables:</summary>

```nasm
extern printf

section .data
    radius dq 10.0

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    call area
    call print

    xor rax, rax
    leave
    ret

area:
section .data
    .pi dq 3.141592     ; local to area

section .text
    push rbp
    mov rbp, rsp

    movsd xmm0, [.pi]
    mulsd xmm0, [radius]
    mulsd xmm0, [radius]

    leave
    ret

print:
section .data
    .fmt db "%f", 10, 0

section .text
    push rbp
    mov rbp, rsp

    mov rax, 1
    mov rdi, .fmt
    call printf

    leave
    ret
```
</details>

## Chapter 13/43 <sup>(published)</sup>

<details>
<summary>Align the stack after function call with stack frame:</summary>

* Each function call results in 8 bytes return address being pushed on the stack.
* It is necessary to make sure to restore the stack to the appropriate value before we leave a function.

```nasm
section .text
    global main

main:
    push rbp
    call func1
    pop rbp
    ret

func1:
    push rbp
    call func2
    pop rbp
    ret

func2:
    push rbp
    call func3
    pop rbp
    ret

func3:
    push rbp
    pop rbp
    ret
```
</details>

## Chapter 14/43 <sup>(published)</sup>

<details>
<summary>Expose a function to external linkage?</summary>

> *arithmetic.asm*
> ```nasm
> section .text
>     global sum
>     global difference
>     global area
>
> sum:
>     push rbp
>     mov rbp, rsp
>
>     mov rax, rdi
>     add rax, rsi
>
>     mov rsp, rbp
>     pop rbp
>     ret
>
> difference:
>     push rbp
>     mov rbp, rsp
>
>     mov rax, rdi
>     sub rax, rsi
>
>     mov rsp, rbp
>     pop rbp
>     ret
>
> area:
>     section .data
>         .pi dq 3.141592
>
>     section .text
>         push rbp
>         mov rbp, rsp
>
>         movsd xmm1, qword[.pi]
>         mulsd xmm0, xmm0
>         mulsd xmm0, xmm1
>
>         mov rsp, rbp
>         pop rbp
>         ret
> ``````
>
> *main.asm*
> ```nasm
> extern sum
> extern difference
> extern area
>
> section .data
>     format_integral db "%i", 10, 0
>     format_floating db "%f", 10, 0
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; use and print the results of sum function
>     mov rdi, 1
>     mov rsi, 3
>     call sum
>
>     mov rdi, format_integral
>     mov rsi, rax
>     xor rax, rax
>     call printf
>
>     ; use and print the results of difference function
>     mov rdi, 7
>     mov rsi, 5
>     call difference
>
>     mov rdi, format_integral
>     mov rsi, rax
>     xor rax, rax
>     call printf
>
>     ; use and print the results of area function
>     mov xmm0, qword[radius]
>     call area
>
>     mov rdi, format_floating
>     mov rax, 1
>     call printf
>
>     mov rsp, rbp
>     pop rbp
>     ret
> ``````
>
> ---
> **Resources**
> - 14
> ---
> **References**
> ---
</details>

<details>
<summary>Expose a variable to external linkage?</summary>

> *header.nasm*
> ```nasm
> global pi
>
> section .data
>     pi dq 3.141592
>
> section .text
>     ...
> ``````
>
> *main.nasm*>
> ```nasm
> extern pi
>
> section .text
>     ...
> ``````
>
> ---
> **Resources**
> - 14
> ---
> **References**
> ---
</details>

## Chapter 15/43 <sup>(published)</sup>

<details>
<summary>Use calling conventions to transfer variables from callee to caller functions?</summary>

* Following calling conventions are for System V AMD64 ABI:
* For integral types, registers are `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9` respectively, and additional arguments are passed via the stack and in reverse order so that we can pop off in the right order.
* Function's return address `rip` is pushed on the stack, just after the arguments.
* In function, then `rbp` is pushed, there maybe another 8 bytes needed to be pushed to align the stack in 16 bytes.
* For floating point types, registers are `xmm0` to `xmm7`, additional arguments are passed via the stack but not with `push` instruction. Will be discussed later.

```nasm
section .text
    global main

main:
    section .data
        .first   dq 1
        .second  dq 2
        .third   dq 3
        .forth   dq 4
        .fifth   dq 5
        .sixth   dq 6
        .seventh dq 7
        .eighth  dq 8
        .ninth   dq 9
        .tenth   dq 10

    section .text
        push rbp
        mov rbp, rsp

        mov rdi, .first
        mov rsi, .second
        mov rdx, .third
        mov rcx, .forth
        mov r8, .fifth
        mov r9, .sixth
        push .tenth
        push .ninth
        push .eighth
        push .seventh
        call func

sum:
    section .text
                        ; first value on stack
                        ; 8 bytes rip pushed onto stack
        push rbp        ; 8 bytes rbp pushed onto stack
        mov rbp, rsp

        xor rax, rax

        add rax, rdi
        add rax, rsi
        add rax, rdx
        add rax, rcx
        add rax, r8
        add rax, r9

        push rbx        ; preserve callee register
        xor rbx, rbx

        mov rbx, qword[rbp+16]  ; first value on stack: + rip + rbp
        add rax, rbx    ; seventh

        mov rbx, qword[rbp+24]
        add rax, rbx    ; eighth

        mov rbx, qword[rbp+32]
        add rax, rbx    ; ningth

        mov rbx, qword[rbp+40]
        add rax, rbx    ; tenth

        pop rbx         ; restore callee register

        mov rsp, rbp
        pop rbp
        ret
```
</details>

## Chapter 16/43 <sup>(published)</sup>

<details>
<summary>Evaluate bit-wise operations?</summary>

* `shl` and `sal` shift left but `sal` has sign extension.
* `shr` and `sar` shift right but `sar` has sign extension.

```nasm
section .data
    number1 db 6        ; 00000110
    number2 db 10       ; 00001010

section .text
    global main

main:
    push rbp
    mov rbp, rsp

    mov rax, number1
    xor rax, number2    ; 00001100

    mov rax, number1
    or  rax, number2    ; 00001110

    mov rax, number1
    and rax, number2    ; 00000010

    mov rax, number1
    not rax             ; 11111001

    mov rax, number1
    shl rax, 5          ; 11000000

    mov rax, number1
    shr rax, 3          ; 00000001

    mov rax, number1
    sal rax, 2          ; 00001100

    mov rax, number1
    sar rax, 2          ; 00000011

    mov rax, number1
    rol rax, 3          ; 00011000

    mov rax, number1
    ror rax, 3          ; 10000001

    mov rsp, rbp
    pop rbp
    ret
```
</details>

## Chapter 17/43 <sup>(published)</sup>

<details>
 <summary>Set and reset specific bits of numeric variable?</summary>

> ```nasm
> section .data
>    variable dq 0
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; set bit 4
>     bts qword [variable], 4
>
>     ; set bit 7
>     bts qword [variable], 7
>
>     ; set bit 8
>     bts qword [variable], 8
>
>     ; reset bit 7
>     btr qword [variable], 7
>
>     xor rax, rax
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 17
> ---
> **References**
> ---
</details>

<details>
<summary>Check if its 8th bit of a quadword variable is set?</summary>

> ```nasm
> section .data
>     variable dq 0
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; reset higher memory to use lower memory for comparison
>     xor rdi, rdi
>     mov rax, 8
>
>     ; check if 8th bit is set by checking carry flag
>     ; 1 if bit is set and 0 otherwise
>     bt [variable], rax
>     setc dil
>
>     xor rax, rax
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 17
> ---
> **References**
> ---
</details>

## Chapter 18/43 <sup>(published)</sup>

<details>
<summary>Use inline procedures to avoid runtime overhead of function calls?</summary>

> ```nasm
> extern printf
>
> ; multiply value v by shifting it n times
> %define multiply(v, n) sal v, n
>
> ; having two arguments
> %macro print 2
>     section .data
>         %%detail db %1, 0
>         %%format_string db "%s: %i", 10, 0
>     section .text
>         xor rax, rax
>         mov rdi, %%format_string
>         mov rsi, %%detail
>         mov rdx, %2
>         call printf
> %endmacro
>
> section .data
>     number dq 42
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     print "value is", number
>     multiply(number, 2)
>     print "multiplication result", number
>
>     xor rax, rax
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 18
>
> ---
> **References**
> ---
</details>

<details>
<summary>How can it be verified if defined macros are replaced in executable object using `objdump` command?</summary>

```sh
objdump -M intel -d macro
```
</details>

## Chapter 19/43 <sup>(published)</sup>

<details>
<summary>Write into standard output stream directly using system calls?</summary>

```nasm
section .text
    global write

; preconditions:
; address of string be set to rsi
; length of string be set to rdx
write:
    push rbp
    mov rbp, rsp

    mov rax, 1  ; write system call number
    mov rdi, 1  ; stdout
    syscall

    xor rax, rax
    leave
    ret
```
</details>

<details>
<summary>Read from standard input stream directly using system calls?</summary>

```nasm
section .text
    global read

; preconditions:
; address of buffer be set to rsi
; length of buffer be set to rdx
read:
    push rbp
    mov rbp, rsp

    mov rax, 0  ; read system call number
    mov rdi, 0  ; stdin

    xor rax, rax
    leave
    ret
```
</details>

<details>
<summary>Count input string before printing so that stack overflow is prevented?</summary>

```nasm
section .text
    global read

print:
    push rbp
    mov rbp, rsp

    push r12        ; callee saved

    xor rdx, rdx    ; character counter
    mov r12, rdi    ; string address

.counter:
    cmp byte[r12], 0
    je .print

    inc rdx
    inc r12
    jmp .counter

.print:
    cmp rdx, 0
    je .exit

    mov rsi, rdi    ; string address
                    ; rdx holds string length
    mov rax, 1      ; write
    mov rdi, 1      ; stdout
    syscall

.exit:
    pop r12
    xor rax, rax
    leave
    ret
```
</details>

<details>
<summary>Limit reading from standard input by a maximum length to prevent stack overflows?</summary>

```nasm
section .text
    global read

; \pre rdi address of string placeholder
; \pre rsi maximum characters to read
; \post rax error code
read:
    section .data
        newline db 0xa

    section .bss
        .buffer resb 1      ; hold 1 character from input

    section .text
        push rbp
        mov rbp, rsp

        push r12            ; callee saved
        push r13            ; callee saved
        push r14            ; callee saved

        mov r12, rdi        ; input string address
        mov r13, rsi        ; max count
        xor r14, r14        ; character counter

    .read:
        mov rax, 0          ; read
        mov rdi, 1          ; stdin
        lea rsi, [.buffer]  ; input address
        mov rdx, 1          ; characters to read
        syscall

        mov al, [.buffer]   ; check if reached NL
        cmp al, byte[newline]
        je .check_exit

        cmp al, 97          ; check if input character is lower than 'a'
        jl .read            ; ignore this and read next character

        cmp al, 122         ; check if input character is greater than 'z'
        jg .read            ; ignore this and read next character

        inc r14             ; increment counter

        cmp r14, r13        ; check if number of characters reached maximum
        ja .read            ; don't put input charater into buffer
                            ; but keep reading from stdin to read newline

        mov byte[r12], al   ; put input character into buffer
        inc r12             ; point to next character placeholder in buffer
        jmp .read           ; read next input character

    .check_exit
        cmp r14, 0          ; check if anything was read
        ja .exit_success

        mov rax, 1          ; return 1 when failed to read anything
        jmp .exit

    .exit_success
        xor rax, rax        ; return 0 when read at least 0 character

    .exit
        inc r12             ; counter null character
        mov byte[r12], 0    ; close string by putting null at the end
        pop r14             ; restore for callee
        pop r13             ; restore for callee
        pop r12             ; restore for callee

        leave
        ret
```
</details>

## Chapter 20/43 <sup>(incomplete)</sup>

<details>
<summary>What header contains Linux system calls?</summary>

> `/usr/include/asm/unistd_64.h`
>
> ---
> **Resources**
> - 20
>
> ---
> **References**
> ---
</details>

<details>
<summary>What header contains file operation constants?</summary>

> `/usr/include/asm-generic/fcntl.h`
>
> ---
> **Resources**
> - 20
>
> ---
> **References**
> ---
</details>

<details>
<summary>Specify an octal number?</summary>

> By appending `q` to the number.
>
> ```nasm
> section .data
>     O_CREATE equ 00000100q
> ``````
>
> ---
> **Resources**
> - 20
> ---
> **References**
> ---
</details>

<details>
<summary>Use preprocessor directives to conditionally compile a part of x64 assembly program?</summary>

> ```nasm
> section .data
>     CONDITION equ 1
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
> %IF CONDITION
>     xor rdi, rdi
> %ELSE
>     mov rdi, 1
> %ENDIF
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 20
>
> ---
> **References**
> ---
</details>

<details>
<summary>Open and close a file in x64 assembly?</summary>

> ```nasm
> section .data
>     CREATE equ 1            ; use for conditional assembly
>     NR_create equ 85        ; create system call
>
> section .text
>     global create
>
> ; \pre rdi address of filename string
> ; \post rax error code
> create:
>     push rbp
>     mov rbp, rsp
>
>     mov rax, NR_create
>     mov rsi, S_IRUSR | S_IWUSR
>     syscall
>
>     leave
>     ret
> ``````
>
> ```nasm
> section .data
>     CREATE equ 1            ; use for conditional assembly
>     NR_create equ 85        ; create system call
>
> section .text
>     global create
>
> ; \pre rdi file descriptor
> ; \post rax error code
> create:
>     push rbp
>     mov rbp, rsp
>
>     mov rax, NR_create
>     mov rsi, S_IRUSR | S_IWUSR
>     syscall
>
>     leave
>     ret
> ``````
>
> ```nasm
> extern create
> extern close
>
> section .text
>     global main
>
> main:
>     section .data
>         fd dq 0                 ; to hold file descriptor
>
>     section .text
>         push rbp
>         mov rbp, rsp
>
>     %IF CREATE
>         mov rdi, filename
>         call create
>         mov qword[fd], rax      ; save file descriptor
>     %ENDIF
>
>     %IF CLOSE
>         mov rdi, qword[fd]      ; file descriptor
>         call close
>     %ENDIF
> ``````
>
> ---
> **Resources**
> - 20
>
> ---
> **References**
> ---
</details>

<details>
<summary>Write content to a file in x64 assembly?</summary>

> ```nasm
> section .data
>     CREATE equ 1            ; use for conditional assembly
>
> section .text
>     global create
>
> create:
>     push rbp
>     mov rbp, rsp
>
>     leave
>     ret
> ``````
>
> ```nasm
> extern create
> extern close
> extern write
>
> section .text
>     global main
>
> main:
>     section .data
>         fd dq 0                 ; to hold file descriptor
>
>     section .text
>         push rbp
>         mov rbp, rsp
>
>     %IF CREATE
>         mov rdi, filename
>         call create
>         mov qword[fd], rax      ; save file descriptor
>     %ENDIF
>
>     %IF WRITE
>         mov rdi, qword[fd]      ; file descriptor
>         mov rsi, text           ; address of string
>         mov rdx, qword[length]  ; length of string
>         call write
>     %ENDIF
>
>     %IF CLOSE
>         mov rdi, qword[fd]      ; file descriptor
>         call close
>     %ENDIF
> ``````
>
> ---
> **Resources**
> - 20
> ---
> **References**
> ---
</details>

<details>
<summary>Truncate a file in x64 assembly?</summary>

> ```nasm
> section .data
>     CREATE equ 1            ; use for conditional assembly
>
> section .text
>     global create
>
> create:
>     push rbp
>     mov rbp, rsp
>
>     leave
>     ret
> ``````
>
> ```nasm
> extern create
> extern close
> extern write
>
> section .text
>     global main
>
> main:
>     section .data
>         fd dq 0                 ; to hold file descriptor
>
>     section .text
>         push rbp
>         mov rbp, rsp
>
>     %IF CREATE
>         mov rdi, filename
>         call create
>         mov qword[fd], rax      ; save file descriptor
>     %ENDIF
>
>     %IF WRITE
>         mov rdi, qword[fd]      ; file descriptor
>         mov rsi, text           ; address of string
>         mov rdx, qword[length]  ; length of string
>         call write
>     %ENDIF
>
>     %IF CLOSE
>         mov rdi, qword[fd]      ; file descriptor
>         call close
>     %ENDIF
> ``````
>
> ---
> **Resources**
> - 20
> ---
> **References**
> ---
</details>

<details>
<summary>Append into a file in x64 assembly?</summary>

> ```nasm
> ``````
>
> ---
> **Resources**
> - 20
> ---
> **References**
> ---
</details>

<details>
<summary>Write to a specific offset of a file in x64 assembly?</summary>

> ```nasm
> ``````
>
> ---
> **Resources**
> - 20
>
> ---
> **References**
> ---
</details>

<details>
<summary>Read from a file in x64 assembly?</summary>

> ```nasm
> ``````
>
> ---
> **Resources**
> - 20
>
> ---
> **References**
> ---
</details>

<details>
<summary>Read from a specific offset of a file in x64 assembly?</summary>

> ```nasm
> ``````
>
> ---
> **Resources**
> - 20
> ---
> **References**
> ---
</details>

<details>
<summary>Delete a file in x64 assembly?</summary>

> ```nasm
> ``````
>
> ---
> **Resources**
> - 20
> ---
> **References**
> ---
</details>

## Chapter 21/43 <sup>(complete)</sup>

<details>
<summary>What registers are used to read command line arguments from an x64 assembly program?</summary>

> * `rdi`: argc or number of arguments
> * `rsi`: argv or address of array each, cell is an 8bytes of address to an argument string
>
> ---
> **Resources**
> - 21
> ---
> **References**
> ---
</details>

<details>
<summary>Read command line arguments from an x64 assembly program?</summary>

> ```nasm
> extern printf
>
> section .data
>     fmt db "%s", 10, 0
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     mov r12, rdi
>     mov r13, rsi
>     xor r14, r14
>
> .arg:
>     mov rdi, fmt
>     mov rsi, qword[r13 + r14 * 8]
>     call printf
>
>     inc r14
>     cmp r14, r12
>     jl .arg
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 21
> ---
> **References**
> ---
</details>

<details>
<summary>How command line arguments stored in registers can be inspected in debugger?</summary>

> ```gdb
> info registers rdi rsi rsp
> x/1xg <the pointer in rdi>
> x/s <address where the pointer in rdi points to>
> x/s <address where the pointer in rdi points to + 8>
> x/s <address where the pointer in rdi points to + 16>
> ``````
>
> ---
> **Resources**
> - 21
> ---
> **References**
> ---
</details>

## Chapter 22/43 <sup>(complete)</sup>

<details>
<summary>Use an assembly function in a C source?</summary>

> ```nasm
> section .text
> 	global sum
>
> sum:
>     push rbp
>     mov rbp, rsp
>
>     mov rax, rdi
>     add rax, rsi
>
>     leave
>     ret
> ``````
>
> ```sh
> nasm -f elf64 -g -F dwarf sum.asm
> ``````
>
> ```c
> #include <stdio.h>
>
> extern int sum(int, int);
>
> int main(void)
> {
>     int result = sum(4, 2);
>     printf("%i\n", result);
> }
> ``````
>
> ```sh
> gcc -g -o program main.c sum.o
> ./program
> ``````
>
> ---
> **Resources**
> - 22
>
> ---
> **References**
> ---
</details>

## Chapter 23/43 <sup>(complete)</sup>

<details>
<summary>How many of inline assembly types are available and why should they be used?</summary>

> There are two types of inline assembly: **basic** and **extended**.
>
> Compilers will not optimize assembly parts of the program, so using inline assembly is not advices.
> There will be no error checking on inline assembly code.
>
> ---
> **Resources**
> - 23
> ---
> **References**
> ---
</details>

<details>
<summary>Write a basic inline assembly in C programs?</summary>

> Instructions should be terminated by `;`.
> `-mintel` compiler option is required.
> Switching to Intel assembly syntax is required as the first argument of `__asm__`.
>
> ```c
> int main(void)
> {
>     __asm__(
>         ".intel_syntax noprefix;"
>         "xor rax, rax;"
>     );
> }
> ``````
>
> ```sh
> gcc -o program main.c -masm=intel -no-pie
> ``````
>
> ---
> **Resources**
> - 23
> ---
> **References**
> ---
</details>

<details>
<summary>Write extended inline assembly in C programs? (needs work)</summary>

> General syntax of extended inline assembly is as follows:
>
> ```c
> __asm__(
>     assembler code
>     : output operands
>     : input operands
>     : list of clobbered registers
> );
> ``````
>
> * After the assembler code, additional and optional information is used.
> * Instruction orders must be respected.
>
> ```c
> __asm__(
>     ".intel_syntax noprefix;"
>     "mov rbx, rdx;"
>     "imul rbx, rcx;"
>     "mov rax, rbx;"
>     :"=a"(eproduct)
>     :"d"(x), "c"(y)
>     :"rbx"
> );
>
> printf("The extended inline product is %i\n", eproduct);
> ``````
>
> `a`, `d`, `c` are register constraints, and they map to the registers `rax`, `rdx`, `rcx`, respectively.
> `:"=a"(eproduct)` means that the output will be in `rax`, and `rax` will refer to the variable `eproduct`. Register `rdx` refers to `x`, and `rcx` refers to `y`, which are the input variables.
> `rbx` is considered clobbered in the code and will be restored to its original value, because it was declared in the list of clobbering registers.
>
> ```txt
> a -> rax, eax, ax, al
> b -> rbx, ebx, bx, bl
> c -> rcx, ecx, cx, cl
> d -> rdx, edx, dx, dl
> S -> rsi, esi, si
> D -> rdi, edi, di
> r -> any register
> ``````
>
> ---
> **Resources**
> - 23
> ---
> **References**
> ---
</details>

## Chapter 24/43 <sup>(incomplete)</sup>

<details>
<summary>Fill a buffer with a value using a simple loop in x64 assembly?</summary>

> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; fill buffer with ascii letters using simple loop
>     mov rax, 32
>     mov rdi, buffer1
>     mov rcx, length
> .next1:
>     mov byte[rdi], al
>     inc rdi
>     inc al
>     loop .next
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
>
> ---
> **References**
> ---
</details>

<details>
<summary>Fill a buffer with a value using a simple loop and `stosb` instruction?</summary>

> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; fill buffer with ascii 0 using loop and stosb instruction
>     mov rax, 48
>     mov rdi, buffer1
>     mov rcx, length
> .next2:
>     stosb
>     loop .next2
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
>
> ---
> **References**
> ---
</details>

<details>
<summary>Fill a buffer with a value without using a loop?</summary>

> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; fill buffer with ascii 1 using rep stosb instruction without a loop
>     mov rax, 49
>     mov rdi, buffer1
>     mov rcx, length
>     rep stosb
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
> ---
> **References**
> ---
</details>

<details>
<summary>Copy contents of a buffer into another without a loop?</summary>

> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; copy buffer1 to buffer2 without a loop
>     mov rsi, buffer1    ; source
>     mov rdi, buffer2    ; destination
>     mov rcx, length
>     rep movsb
>
>     ; reverse copy the buffer1 into buffer2 without a loop
>     mov rax, 48         ; fill buffer2 with ascii 0
>     mov rdi, buffer2    ; we don't increment rdi with stosb
>     mov rcx, length     ; we don't decrement rcx or loop with stosb
>     rep stosb
>
>     lea rsi, [buffer1 + length - 4]
>     lea rdi, [buffer2 + length]
>     mov rcx, 27         ; copy only 27 characters
>     std                 ; std sets DF, cld clears DF
>     rep movsb
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
> ---
> **References**
> ---
</details>

<details>
<summary>Reverse copy the content of a buffer into another without a loop?</summary>

> When using `movsb`, the content of `DF` (the direction flag) is taken into account.
> When `DF=0`, `rsi` and `rdi` are increased by 1, pointing to the next higher memory address.
> When `DF=1`, `rsi` and `rdi` are decreased by 1, pointing to the next lower memory address.
> This means that in our example with `DF=1`, `rsi` needs to point to the address of the highest memory address to be copied and decrease from there. In addition, `rdi` needs to point to the highest destination address and decrease from there.
> The intention is to “walk backward” when copying, that is, decreasing `rsi` and `rdi` with every loop.
> **NOTE**: `rsi` and `rdi` both are decreased; you cannot use the `DF` to increase one register and decrease another (reversing the string).
>
> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     ; reverse copy the buffer1 into buffer2 without a loop
>     mov rax, 48         ; fill buffer2 with ascii 0
>     mov rdi, buffer2    ; we don't increment rdi with stosb
>     mov rcx, length     ; we don't decrement rcx or loop with stosb
>     rep stosb
>
>     lea rsi, [buffer1 + length - 4]
>     lea rdi, [buffer2 + length]
>     mov rcx, 27         ; copy only 27 characters
>     std                 ; std sets DF, cld clears DF which reverses direction
>     rep movsb           ; with DF set, decrements rsi and rdi until rcx reaches 0
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
> ---
> **References**
> ---
</details>

<details>
<summary>Compare two strings in x64 assembly without a loop? <span style="color:green">(needs work)</span></summary>

> Put the address of the first (source) string in `rsi`, the address of the second string (destination) in `rdi`, and the string length in `rcx`. Just to be sure, we clear the direction flag, `DF`, with `cld`. So, we walk forward in the strings.
>
> The instruction `cmpsb` compares two bytes and sets the status flag `ZF` to `1` if the two compared bytes are equal or to `0` if the 2 bytes are not equal. `rcx` is adjusted only at the end of a loop, which was never completed, so we have to adjust `rcx` (decrease it with 1). The resulting position is returned to main in `rax`.
>
> We will use repe, a version of `rep`, meaning “repeat while equal.” As before, `cmpsb` sets `ZF` according to the comparison, and `ZF=1` means the bytes are equal. As soon as `cmpsb` sets `ZF` equal to `0`, the `repe` loop is ended, and `rcx` can be used to compute the position where the differing character appeared. If the strings are completely the same, then `rcx` will be `0` and `ZF` will be `1`. After `repe`, the instruction `je` tests if `ZF` equals `1`. If `ZF` is `1`, the strings are equal; if `0`, the strings are not equal. We use `rcx` to calculate the differing position, so there’s no need to adjust `rcx`, because `repe` decreases `rcx` first in every loop.
>
> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
> ; method 1
> ;=====================
>     lea rdi, [buffer1]
>     lea rsi, [buffer2]
>     mov rdx, length
>
>     cld                 ; clear DF flag
>
> .str_loop:
>     cmpsb
>     jne .notequal
>     loop .str_loop
>
>     xor rax, rax
>
> ; method 2
> ;=====================
> .notequal:
>     mov rax, buffer2
>     dec rcx
>
>     sub rax, rcx
>
>     mov rcx, rdx
>     cld
>
>     repe cmpsb
>     je .equals
>
>     mov rax, buffer2
>     sub rax, rcx
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
>
> ---
> **References**
> ---
</details>

<details>
<summary>Scan a string if a character exists in it without a loop?</summary>

> The scanning works similar to comparing, but with `repne`, “repeat while not equal,” instead of `repe`. We also use `lodsb` and load the byte at address `rsi` into `rax`. The instruction `scasb` compares the byte in `al` with the byte pointed to by `rdi` and sets (1=equal) or resets (0=not equal) the `ZF` flag accordingly. The instruction `repne` looks at the status flag and continues if `ZF = 0`; that is, the 2 bytes are not equal. If the 2 bytes are equal, `scasb` sets `ZF` to `1`, the `repne` loop stops, and `rcx` can be used to compute the position of the byte in the string.
>
> ```nasm
> section .data
>     length equ 95
>     newline db 10
>
> section .bss
>     buffer1 resb length
>     buffer2 resb length
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     mov rcx, rdx
>     lodsb
>     cld
>     repne scasb
>     jne .charnotfound
>
>     mov rax, length
>
> .charnotfound:
>     sub rax, rcx
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 24
> ---
> **References**
> ---
</details>

## Chapter 25/43 <sup>(complete)</sup>

<details>
<summary>Indicate that a literal number is in hexadecimal base in x64 assembly?</summary>

> By appending an `h` at the end of a number:
>
> ```nasm
> 2000000h
> ``````
>
> ---
> **Resources**
> - 25
> ---
> **References**
> ---
</details>

<details>
<summary>Obtain the CPU information of the processor in x64 assembly?</summary>

> You first put a specific parameter in `eax`, then execute the instruction `cpuid`, and finally check the returned value in `ecx` and `edx`.
> Indeed, `cpuid` uses 32-bit registers.
>
> Based on processor manual, SSE bits are as follows:
>
> * **sse**: edx:25
> * **sse2**: edx:26
> * **sse3**: ecx:1
> * **ssse3**: ecx:1 and ecx:8
> * **sse4.1**: ecx:19
> * **sse4.2**: ecx:20
>
> ```nasm
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     mov eax, 1
>     cpuid
>
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 25
> ---
> **References**
> ---
</details>

<details>
<summary>Check the processors which version of SSE extensions do they support?</summary>

> ```nasm
> extern printf
>
> section .data
>     fmt_sse42 db "sse4_2", 10, 0
>     fmt_sse41 db "sse4_1", 10, 0
>     fmt_ssse3 db "ssse3", 10, 0
>     fmt_sse3 db "sse3", 10, 0
>     fmt_sse2 db "sse2", 10, 0
>     fmt_sse db "sse", 10, 0
>     fmt_sep db ",", 10, 0
>
> section .text
>     global main
>
> main:
>     push rbp
>     mov rbp, rsp
>
>     mov eax, 1
>     cpuid
>     mov r12, rcx      ; store the half result of cpuid
>     mov r13, rdx      ; store the half result of cpuid
>
>     call sse
>     call sse2
>     call sse3
>     call ssse3
>     call sse41
>     call sse42
>
>     xor rax, rax
>     leave
>     ret
>
> sse:
>     push rbp
>     mov rbp, rsp
>
>     ; call also be done with bt instruction: bt r13, 25
>     test r13, 2000000h  ; test bit 25
>     jz .sse_unsupported
>
>     xor rax, rax
>     mov rdi, fmt_sse
>     call printf
>
> .sse_unsupported:
>     leave
>     ret
>
> sse2:
>     push rbp
>     mov rbp, rsp
>
>     test r13, 4000000h  ; test bit 26
>     jz .sse2_unsupported
>
>     xor rax, rax
>     mov rdi, fmt_sse2
>     call printf
>
> .sse2_unsupported:
>     leave
>     ret
>
> sse3:
>     push rbp
>     mov rbp, rsp
>
>     test r12, 1         ; test bit 0
>     jz .sse3_unsupported
>
>     xor rax, rax
>     mov rdi, fmt_sse3
>     call printf
>
> .sse3_unsupported:
>     leave
>     ret
>
> ssse3:
>     push rbp
>     mov rbp, rsp
>
>     test r12, 9         ; test bit 0
>     jz .ssse3_unsupported
>
>     xor rax, rax
>     mov rdi, fmt_ssse3
>     call printf
>
> .ssse3_unsupported:
>     leave
>     ret
>
> sse41:
>     push rbp
>     mov rbp, rsp
>
>     test r12, 80000h    ; test bit 19
>     jz .sse41_unsupported
>
>     xor rax, rax
>     mov rdi, fmt_sse41
>     call printf
>
> .sse41_unsupported:
>     leave
>     ret
>
> sse42:
>     push rbp
>     mov rbp, rsp
>     test r12, 100000h   ; test bit 20
>     jz .sse42_unsupported
>
>     xor rax, rax
>     mov rdi, fmt_sse42
>     call printf
>
> .sse42_unsupported:
>     leave
>     ret
> ``````
>
> ---
> **Resources**
> - 25
> ---
> **References**
> ---
</details>

## Chapter 26/43 <sup>(complete)</sup>

<details>
<summary>How many registers of SSE are available on any processor supporting it?</summary>

> 16 additional 128-bit registers of `xmm`:
>
> * xmm0
> * ...
> * xmm15
>
> ---
> **Resources**
> - 26
> ---
> **References**
> - https://en.wikipedia.org/wiki/Flynn's_taxonomy
> ---
</details>

<details>
<summary>What are the two types of data that can be stored on SSE registers?</summary>

> The `xmm` registers can contain **scalar data** or **packed data**.
> Scalar data means just one value.
> Packed data means multiple values related to each other.
>
> ---
> **Resources**
> - 26
> ---
> **References**
> ---
</details>

<details>
<summary>What are AVX registers and how much data can they hold?</summary>

> The **AVX** registers are called `ymm` registers and have 256 bits, double the size of `xmm` registers.
>
> There is also **AVX-512** which provides 512 bits registers and are called `zmm` registers.
>
> ---
> **Resources**
> - 26
> ---
> **References**
> ---
</details>

<details>
<summary>How does alignment of data in `.data` and `.bss` sections can improve performance of a program?</summary>

> Data in section `.data` and `.bss` should be aligned on a 16-byte border so that registers can be filled with data once for each block of data.
>
> ---
> **Resources**
> - 26
>
> ---
> **References**
> ---
</details>

<details>
<summary>How can we align data in `.data` and `.bss` sections in specific byte sizes?</summary>

> In **NASM** the assembly directive `align 16` and `alignb 16` can be used in front of the data.
>
> For **AVX**, data should be aligned on a 32 bytes border and for **AVX-512**, data needs to be aligned on a 64 bytes border.
>
> ---
> **Resources**
> - 26
>
> ---
> **References**
> ---
</details>

## Chapter 27/43

<details>
<summary>What register is responsible for controlling the floating-point operations?</summary>

> **mxcsr**: MMX Control and Status Register
> ```nasm
> ``````
>
> ---
> **Resources**
> - 27
> ---
> **References**
> ---
</details>

## Chapter 28/43
## Chapter 29/43
## Chapter 30/43
## Chapter 31/43
## Chapter 32/43
## Chapter 33/43
## Chapter 34/43
## Chapter 35/43
## Chapter 36/43
## Chapter 37/43
## Chapter 38/43
## Chapter 39/43
## Chapter 40/43
## Chapter 41/43
## Chapter 42/43
## Chapter 43/43

# [Mastering Linux Security and Hardening](books/9781837630516.md)
<img alt="Mastering Linux Security and Hardening" src="../covers/9781837630516.jpg" width="200"/>

## Chapter 1/16

<details>
<summary>How to install a virtual machine in VirtualBox?</summary>

> Download and install VirtualBox and the VirtualBox Extension Pack from https://www.virtualbox.org/.
>
> Get version of installed VirtualBox:
>
> ```sh
> vbox_version="$(vboxmanage --version | sed 's/[^0-9.].*//')"
> ``````
>
> Check if extension pack is already installed:
>
> ```sh
> vboxmanage list extpacks | grep 'Version:' | awk '{print $2}' | grep -q "${vbox_version}" && echo "extpack for ${vbox_version} already exists"
> ``````
>
> Install extension pack otherwise:
>
> ```sh
> vbox_sum256="$(wget -O - -q "https://www.virtualbox.org/download/hashes/${vbox_version}/SHA256SUMS" | grep "${vbox_version}.vbox-extpack" | cut -d' ' -f1)"
> wget -c "https://download.virtualbox.org/virtualbox/${vbox_version}/Oracle_VM_VirtualBox_Extension_Pack-${vbox_version}.vbox-extpack" -O /tmp/${vbox_version}.vbox-extpack
> vboxmanage extpack install --replace --accept-license=${vbox_sum256} /tmp/${vbox_version}.vbox-extpack
> ``````
>
> Download the installation `.iso` files for Ubuntu Server 22.04, CentOS 7, AlmaLinux8, and AlmaLinux9 from https://ubuntu.com/, https://almalinux.org/, and https://www.centos.org/.
>
> Create a virtual machine and register it:
>
> ```sh
> vboxmanage createvm --name ubuntu --ostype archlinux_64 --basefolder $HOME/VMs --register
> ``````
>
> Increase the memory, virtual memory and cpu count:
>
> ```sh
> vboxmanage modifyvm ubuntu --cpus 2 --memory 2048 --vram 128
> ``````
>
> Create a virtual drive controller and medium and attach to the virtual machine:
>
> ```sh
> vboxmanage storagectl ubuntu --add SATA --type sata --controller IntelAhci
> vboxmanage createmedium disk --filename $HOME/VMs/ubuntu/ubuntu.vdi --size $((1024 * 20)) --format VDI
> vboxmanage storageattach sample --storagectl SATA --medium $HOME/VMs/ubuntu/ubuntu.vdi mtype normal --type hdd --port 0
> ``````
>
> Create a DVD drive, insert the `.iso` file into it and attach to the virtual machine:
>
> ```sh
> vboxmanage createmedium dvd --filename $HOME/VMs/ubuntu/ubuntu.dvd --size $((1024 * 4))
> vboxmanage storageattach ubuntu --storagectl SATA --medium $HOME/VMs/ubuntu/ubuntu.dvd --mtype normal --type dvddrive --port 1
> ``````
>
> Create a NAT network and enable port forwarding:
>
> ```sh
> ``````
>
> Start the new virtual machine:
>
> ```sh
> vboxmanage startvm ubuntu --type gui
> ``````
>
> Now install Ubuntu and take a snapshot after the clean setup:
>
> ```sh
> vboxmanage snapshot ubuntu take post-installation
> ``````

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to installing the EPEL repository on the CentOS and AlmaLinux virtual machines?</summary>

> While the **Ubuntu** package repositories have pretty much everything that you need, the **CentOS** and **AlmaLinux** package repositories are lacking.
> You’ll need to install the EPEL repository. (The EPEL project is run by the Fedora team.)  
> When you install third-party repositories on Red Hat 7 and CentOS 7 systems, you’ll also need to install a priorities package and edit the `.repo` files to set the proper priorities for each repository.
> This will prevent packages from the third-party repository from overwriting official Red Hat and CentOS packages if they just happen to have the same name.  
> The two packages that you’ll need to install EPEL are in the normal CentOS 7 repositories.
>
> ```sh
> sudo yum install yum-plugin-priorities epel-release
> ``````
>
> When the installation completes, navigate to the `/etc/yum.repos.d` directory, and open the `CentOS-Base.repo` file in your favorite text editor.  
> After the last line of the `base`, `updates`, and extras sections, add the line `priority=1`.  
> After the last line of the `centosplus` section, add the line `priority=2`.  
> Open the `epel.repo` file for editing.
> After the last line of the `epel` section, add the line `priority=10`.
> After the last line of each remaining section, add the line `priority=11`.  
> Update the system and then create a list of the installed and available packages:
>
> ```sh
> sudo yum upgrade sudo yum list > yum_list.txt
> ``````
>
> To install the EPEL repository on **AlmaLinux**, all you have to do is run this command:
>
> ```sh
> sudo dnf install epel-release
> ``````
>
> There’s no priorities package as there is on CentOS 7 and earlier, so we won’t have to worry about configuring the repository priorities.
> When the package installation is complete, update the system and create a list of available sof t ware packages with these two commands:
>
> ```sh
> sudo dnf upgrade sudo dnf list > dnf_list.txt
> ``````

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>Why should we keep the Linux systems updated?</summary>

> Spend some time perusing the Common Vulnerabilities and Exposures database on https://cve.mitre.org/ and you’ll soon see why it’s so important to keep your systems updated.

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to update Debian-based systems?</summary>

> run two commands:
>
> ```sh
> sudo apt update
> sudo apt dist-upgrade
> ``````

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to remove some old packages that are no longer needed on Debian-based systems?</summary>

> ```sh
> sudo apt auto-remove
> ``````

> **Resources**
> - 1

> **References**
---
</details>


<details>
<summary>How to configure auto updates for Ubuntu?</summary>

>

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to enable auto-update on Ubuntu?</summary>

> When you first install Ubuntu, automatic updates are turned on by default.
> To verify that, you’ll first check the status of the `unattended-upgrades` service:
>
> ```sh
> systemctl status unattended-upgrades
> ``````
>
> Then, look in the `/etc/apt/apt.conf.d/20auto-upgrades` file. If *auto-updating* is enabled, you’ll see this:
>
> ```
> APT::Periodic::Update-Package-Lists "1";
> APT::Periodic::Unattended-Upgrade "1";
> ``````

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to enable auto-reboot after unattended upgrades on Ubuntu?</summary>

> By default, Ubuntu systems don’t automatically reboot after an update is installed.
> If you keep it that way, you’ll see a message about it when you log into the system. 
> But if you prefer, you can set Ubuntu to automatically reboot after it automatically updates itself.
>
> Go into the `/etc/apt/apt.conf.d` directory and open the `50unattended-upgrades` file in your favorite text editor, you’ll see a line that says:
>
> ```sh
> Unattended-Upgrade::Automatic-Reboot "false";
> ``````
>
> With this new configuration, Ubuntu will now reboot itself immediately after the automatic update process has completed.
> If you’d rather have the machine reboot at a specific time, scroll down where you’ll see this:
>
> ```sh
> //Unattended-Upgrade::Automatic-Reboot-Time "02:00";
> ``````
>
> To disable automatic updates, just go into the `/etc/apt/apt.conf.d` directory and open the `20auto-upgrades` file in your favorite text editor, you’ll see:
>
> ```sh
> APT::Periodic::Update-Package-Lists "1";
> APT::Periodic::Unattended-Upgrade "1";
> ``````
>
> Change the parameter for that second line to 0, so that the file will now look like this:
>
> ```sh
> APT::Periodic::Update-Package-Lists "1";
> APT::Periodic::Unattended-Upgrade "0";
> ``````
>
> If you want to see if there are any security-related updates available, but don’t want to see any non-security updates, use the unattended-upgrade command, like so:
>
> ```sh
> sudo unattended-upgrade --dry-run -d
> ``````
>
> 8. To manually install the security-related updates without installing non-security updates, just run:
>
> ```sh
> sudo unattended-upgrade -d
> ``````
>
> Also, if you’re running a non-Ubuntu flavor of Debian, which would include Rasp-bian for the Raspberry Pi, you can give it the same functionality as Ubuntu by installing the unattended-upgrades package. Just run this command:
>
> ```sh
> sudo apt install unattended-upgrades
> ``````

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to auto-update Red Hat 7-based systems?</summary>

> There’s no automatic update mechanism on Red Hat-based systems, which include CentOS and Oracle Linux.
> So, with the default configuration, you’ll need to perform updates yourself:
>
> To update a Red Hat 7-based system, just run this one command:
>
> ```sh
> sudo yum upgrade
> ``````
>
> To see only security updates that are ready to be installed:
>
> ```sh
> sudo yum updateinfo list updates security
> ``````
>
> To only install the security updates:
>
> ```sh
> sudo yum upgrade --security
> ``````
>
> To make CentOS system automatically update itself, install and enable `yum-cron` service:
>
> ```sh
> sudo yum install yum-cron
> sudo systemctl enable --now yum-cron
> ``````
>
> To configure `yum-cron` service, edit `/etc/yum/yum-cron.conf` file:
>
> ```sh
> update_cmd = security
>
> download_updates = yes
> apply_updates = no
> ``````
>
> If you want the updates to get automatically installed, change the `apply_updates` parameter to `yes`.
>
> Note that unlike Ubuntu, there’s no setting to make Red Hat 7-based systems automatically reboot themselves after an update.

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to send mails containing update reports?</summary>

> Mail settings for yum-cron can be found in `/etc/yum/yum-cron.conf` file.
>
> The `email_to` line is set to send messages to the root user account.
> If you want to receive messages on your own account, just change it here.
>
> To see the messages, you’ll need to install a mail reader program like **mutt**, if one isn’t already installed. 
>
> ```sh
> sudo yum install mutt
> ``````

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to see if system needs to be restarted after an update?</summary>

> Make sure `needs-restarting` is installed:
>
> ```sh
> sudo yum install yum-utils
> ``````
>
> * `sudo needs-restarting`: This shows the services that need to be restarted, and the reasons why the system might need to be rebooted.
> * `sudo needs-restarting -s`: This only shows the services that need to be restarted.
> * `sudo needs-restarting -r`: This only shows the reasons why the system needs to be rebooted.

> **Resources**
> - 1

> **References**
---
</details>

<details>
<summary>How to enable auto-update on Red Hat 8/9-based systems?</summary>

> For the most part, you use `dnf` the same way that you’d use `yum`, with the same arguments and options.
>
> ```sh
> sudo dnf upgrade
> ``````
>
> The main functional difference between `yum` and `dnf` is that `dnf` has a different automatic update mechanism.
> Instead of installing the `yum-cron` package, you’ll now install the `dnf-automatic` package:
>
> ```sh
> sudo dnf install dnf-automatic
> ``````
>
> Configure the `/etc/dnf directory/automatic.conf` file the same way as you did the yum-cron.conf file for CentOS 7.  
>
> Instead of working as a cron job, as the old `yum-cron` did, `dnf-automatic` works with a systemd timer.
> When you first install `dnf-automatic`, the timer is disabled.
> Enable it and start it by running this command:
>
> ```sh
> sudo systemctl enable --now dnf-automatic.timer
> ``````
>
> To determine if a system needs to be restarted, just install the `yum-utils` package and run the `needs-restarting` command, the same as you did for CentOS 7.
> (For some reason, the Red Hat developers never bothered to change the package name to `dnf-utils`.)

> **Resources**
> - 1

> **References**
---
</details>

## Chapter 2/16

<details>
<summary>Why is it more secure to use <code>sudo</code> to do administrative tasks than logging in as root?</summary>

> Using `su -` to log in to the root command prompt does not let `sudo` to record user activity.
> For that reason, getting access to the root command prompt should be prevented.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to allow a user to do everything, including logging in to the root command prompt using <code>sudo</code>?</summary>

> The first method is to add users to a predefined administrators group and then, if it hasn’t already been done, to configure the sudo policy to allow that group to do its job.
> It’s simple enough to do except that different Linux distro families use different admin groups.
>
> On Unix, BSD, and most Linux systems, you would add users to the **wheel** group.
>
> Edit sudo policy file by doing `sudo visudo`:
>
> ```sudo
> %wheel ALL=(ALL) ALL
> ``````
>
> The percent sign indicates that we’re working with a group.
> The three appearances of *ALL* mean that members of that group can perform *ALL* commands, as *ALL* users, on *ALL* machines in the network on which this policy is deployed.
>
> ```sudo
> %wheel ALL=(ALL) NOPASSWD: ALL
> ``````
>
> The former snippet means that members of the **wheel** group would be able to perform all of their sudo tasks without ever having to enter any password.
> Avoid doing so, even for home use.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to add a user to the administrative group?</summary>

> On Red Hat distros add users to the **wheel** group:
>
> ```sudo
> sudo usermod -a -G wheel maggie
> ``````
>
> Use `-a` option in order to prevent removing the user from other groups to which he or she belongs.
>
> You can also add a user account to the wheel group as you create it.
>
> ```sudo
> sudo useradd -G wheel frank
> ``````
>
> For members of the Debian family, including Ubuntu, the procedure is the same, except that you would use the **sudo** group instead of the **wheel** group.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>What differences does <code>useradd</code> have in Red Hat and non-Red Hat distros?</summary>

> With a member of the Red Hat family, `useradd` comes with predefined default settings to create user accounts. 
> For non-Red Hat-type distros, you’d need to either reconfigure the default settings or use extra option switches in order to create the user’s home directory and to assign the correct shell:
>
> *Red Hat distros*
>
> ```sudo
> sudo useradd -G wheel frank
> ``````
>
> *non-Red Hat distros*
>
> ```sudo
> sudo useradd -G wheel -m -d /home/frank -s /bin/bash frank
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to lock <i>root</i> user account after a clear Linux setup?</summary>

> Create a normal user account and give it full `sudo` privileges.
> Then, log out of the *root* account and log back in with your normal user account and disable the *root* account:
>
> ```sh
> sudo passwd -l root
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to give members of a user group full sudo power in the sudo policy file?</summary>

> You can either create an entry for an individual user or create a user alias.
>
> ```sudo
> ADMINS ALL=(ALL) ALL
> ``````
>
> It’s also possible to add a sudo entry for just a single user, and you might need to do that under very special circumstances.
>
> ```sudo
> frank ALL=(ALL) ALL
> ``````

> **Resources**
> - 2

> **References**
---
</details>

How to deploy a sudo policy across a network with a mixed group of both Red Hat and Ubuntu machines?

<details>
<summary>How to assign specific software privileges on a group of users?</summary>

> You can, for example, create a `BACKUPADMINS` user alias for backup administrators, a `WEBADMINS` user alias for web server administrators, or whatever else you desire:
>
> ```sudo
> User_Alias SOFTWAREADMINS = vicky, cleopatra
> ``````
>
> Then assign some duties to the user alias:
>
> ```sudo
> Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum
> ``````
>
> Now, it’s just a simple matter of assigning the `SOFTWARE` command alias to the `SOFTWAREADMINS` user alias:
>
> ```sudo
> SOFTWAREADMINS ALL=(ALL) SOFTWARE
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to allow users to execute commands with specific subcommands, options or arguments as root?</summary>

> The way sudo works is that if a command is listed by itself, then the assigned user can use that command with any subcommands, options, or arguments.
>
> ```sudo
> Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig, /usr/bin/systemctl start, /usr/bin/systemctl stop, /usr/bin/systemctl reload, /usr/bin/systemctl restart, /usr/bin/systemctl status, /usr/bin/systemctl enable, /usr/bin/systemctl disable
> ``````
>
> But when a command is listed in the command alias with a subcommand, option, or argument, that’s all anyone who’s assigned to the command alias can run.
>
> You can eliminate all of the `systemctl` subcommands and make the `SERVICES` alias look like this:
>
> ```sudo
> Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig, /usr/bin/systemctl
> ``````
>
> But if you do that, Lionel and Charlie will also be able to shut down or reboot the system, edit the services files, or change the machine from one systemd target to another.
>
> Because the `systemctl` command covers a lot of different functions, you have to be careful not to allow delegated users to access too many of those functions.
> A better solution would be to add a wildcard to each of the systemctl subcommands:
>
> ```sudo
> Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig, /usr/bin/systemctl start *, /usr/bin/systemctl stop *, /usr/bin/systemctl reload *, /usr/bin/systemctl restart *, /usr/bin/systemctl status *, /usr/bin/systemctl enable *, /usr/bin/ systemctl disable *
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to assign privileges to either a Linux group or an individual user?</summary>

> ```sudo
> katelyn ALL=(ALL) STORAGE
> gunther ALL=(ALL) /sbin/fdisk -l
> %backup_admins ALL=(ALL) BACKUP
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to assign privileges on a group of users across a network?</summary>

> Each host alias consists of a list of server hostnames.
> This is what allows you to create one sudoers file on one machine and deploy it across the network.
> For example, you could create a `WEBSERVERS` host alias, a `WEBADMINS` user alias, and a `WEBCOMMANDS` command alias with the appropriate commands:
>
> ```sudo
> Host_Alias WEBSERVERS = webserver1, webserver2
> User_Alias WEBADMINS = junior, kayla
> Cmnd_Alias WEBCOMMANDS = /usr/bin/systemctl status httpd, /usr/bin/systemctl start httpd, /usr/bin/systemctl stop httpd, /usr/bin/systemctl restart httpd
> WEBADMINS WEBSERVERS=(ALL) WEBCOMMANDS
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to disable sudo timer in order to protect system from physical access to open terminal?</summary>

> Even though `sudo` is a security tool, certain things that you can do with it can make your system even more insecure than it was.
>
> By default, the sudo timer is set for 5 minutes.
> Although this is obviously handy, it can also be problematic if users were to walk away from their desks with a command terminal still open.
>
> You can easily disable this timer by adding a line to the *Defaults* section of the sudoers file:
>
> ```sudo
> Defaults timestamp_timeout = 0
> ``````
>
> If you need to leave your desk for a moment, your best action would be to log out of the server first.
> Short of that, you could just reset the sudo timer by running this command:
>
> ```sh
> sudo -k
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How users can view their <code>sudo</code> privileges?</summary>

> ```sh
> sudo -l
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to prevent users from shell escapes with sudo?</summary>

> By assigning shell commands to users in sudo policy file, you have effectively given them full `sudo` privileges.
>
> ```sudo
> maggie ALL=(ALL) /bin/bash, /bin/zsh
> ``````
>
> This should be avoided all the time.
>
> But certain programs, especially text editors like `vi` and pagers like `less`, also have a handy shell escape feature.
>
> Imagine that you want Frank to be able to edit the `sshd_config` file and only that file.
> You might be tempted to add a line to your sudo configuration that would look like this:
>
> ```sudo
> frank ALL=(ALL) /bin/vim /etc/ssh/sshd_config
> ``````
>
> Once Frank has opened the `sshd_config` file with his sudo privilege, he can then use Vim’s shell escape feature to perform other root-level commands, which includes being able to edit other configuration files, create new users, manipulate system services, or install malware.
>
> You can fix this problem by having users use sudoedit instead of vim:
>
> ```sudo
> frank ALL=(ALL) sudoedit /etc/ssh/sshd_config
> ``````
>
> Other programs that have a shell escape feature include the following:
>
> * vim
> * emacs
> * less
> * view
> * more
>
> To deal with them, use the `NOEXEC:` option when we set up our sudoers rules.
>
> ```sudo
> vicky ALL=(ALL) /usr/bin/less
> ``````
>
> ```sh
>  sudo less messages
> ``````
>
> To open a shell from within less, Vicky will type `!bash` instead of `:shell` and a new shell will be spawned.
>
> To fix that we use the `NOEXEC:` option to the sudoers rule:
>
> ```sudo
> vicky ALL=(ALL) NOEXEC: /usr/bin/less
> ``````
>
> This prevents Vicky from escaping to even her own shell.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to give users limited access to dangerous file editing commands when needed?</summary>

> Some programs that don’t have shell escapes can still be dangerous if you give users unrestricted privileges to use them.
>
> * cat
> * cut
> * awk
> * sed
>
> If you must give someone sudo privileges to use one of these programs, it’s best to limit their use to only specific files.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to deal with differences between the different Linux and Unix distributions on a network when writing in sudo policy file?</summary>

> You can use host aliases to ensure that servers will only allow the execution of commands that are appropriate for their operating systems.
> Also, be aware that some system services have different names on different Linux distributions.
> On Red Hat-type systems, the Secure Shell service is `sshd`. On Debian/Ubuntu systems, it’s just plain `ssh`.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to let users run commands as other users?</summary>

> In the following line, *(ALL)* means that Sylvester can run the `systemctl` commands as any user:
>
> ```sudo
> sylvester ALL=(ALL) /usr/bin/systemctl status sshd, /usr/bin/systemctl restart sshd
> ``````
>
> You could, if desired, change that *(ALL)* to *(root)* in order to specify that Sylvester can only run these commands as the root user:
>
> ```sudo
> sylvester ALL=(root) /usr/bin/systemctl status sshd, /usr/bin/systemctl restart sshd
> ``````
>
> Okay, there’s probably not much point in that because nothing changes.
>
> But there are more practical uses for this feature.
> Let’s say that Vicky is a database admin, and you want her to run as the database user:
>
> ```sudo
> vicky ALL=(database) /usr/local/sbin/some_database_script.sh
> ``````
>
> Vicky could then run the command as the database user by entering the following command:

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to prevent abuse via a user’s shell scripts?</summary>

> Let’s have Frank create the `frank_script.sh` shell script:
>
> ```sh
> sudo -u database some_database_script.sh
> ``````
>
> add this rule for Frank:
>
> ```sudo
> frank ALL=(ALL) /home/frank/frank_script.sh
> ``````
>
> Since this file is in Frank’s own home directory and he is its owner, he can edit it any way he wants.
>
> ```sh
> #!/bin/bash
>
> echo "This script belongs to Frank the Cat."
> sudo -i
> ``````
>
> What `sudo -i` does is to log a person in to the root user’s shell, the same way that `sudo su -` does.
> If Frank were to do `sudo -i` from his own command prompt, it would fail because he doesn’t have the privilege to do that.
>
> To remedy this, move Frank’s script to the `/usr/local/sbin/` directory and change the ownership to the root user so that Frank won’t be able to edit it.
> And of course, before I do that, I’ll make sure to delete that `sudo -i` line from it:
>
> ```sh
> mv frank_script.sh /usr/local/sbin
> chown root: /usr/local/sbin/frank_script.sh
> ``````
>
> Finally, I’ll open `visudo` and change his rule to reflect the new location of the script.
> The new rule looks like this:
>
> ```sudo
> frank ALL=(ALL) /usr/local/sbin/frank_script.sh
> ``````
>
> Frank can still run the script, but he can’t edit it.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to protect a system from default user accounts after a fresh setup?</summary>

> The first thing you want to do after setting up a system is to set up your own user account, give it a good password, and give it sudo privileges.
> Then get rid of that default account, because leaving it in place, especially if you leave the default password, is just asking for trouble.
>
> Look in the `/etc/password` file on *RaspEX*, and you’ll see the default user there:
>
> ```passwd
> raspex:x:1000:1000:,,,:/home/raspex:/bin/bash
> ``````
>
> Then, look in the `/etc/sudoers` file, and you’ll see this line, which allows the *raspex* user to do all `sudo` commands without having to enter a password:
>
> ```sudo
> raspex ALL=(ALL) NOPASSWD: ALL
> ``````
>
> Another thing to watch out for is that some Linux distributions for IoT devices have this rule in a separate file in the `/etc/sudoers.d` directory, instead of in the main sudoers file.
> Either way, you’ll want to delete this rule, as well as the default user account, when you set up your IoT device.
> And of course, you’ll also want to change the root user password, and then lock the root user account.

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to reconfigure <code>sudo</code> to ask user's password instead of root user in SUSE disto?</summary>

> When you install a SUSE distro you and the root user will both have the same password.
>
> When you do `sudo visudo` on a SUSE machine, you’ll see these two lines that you don’t see on any other Linux distro:
>
> ```sudo
> Defaults targetpw # ask for the password of the target user i.e.
> root ALL ALL=(ALL) ALL # WARNING! Only use this together with 'Defaults targetpw'!
> ``````
>
> Replace previous rules with:
>
> ```sudo
> %wheel ALL=(ALL:ALL) ALL
> ``````
>
> Add users to *wheel* group:
>
> ```sh
> usermod -a -G wheel frank
> ``````
>
> Then disable the *root* user:
>
> ```sh
> sudo passwd -l root
> ``````

> **Resources**
> - 2

> **References**
---
</details>

<details>
<summary>How to enable JSON formatted logging on <code>sudo</code>?</summary>

> ```sudo
> Defaults log_format=json
> ``````

> **Resources**
> - 2

> **References**
> - https://opensource.com/article/22/2/new-sudo-features-2022
---
</details>

<details>
<summary>How to collect logs from multiple machines centrally into a server?</summary>

> ```sudo
> Defaults log_server=172.16.167.150
> ``````
>
> If you want JSON-formatted log messages, you need the following setting in the `[eventlog]` section of the `/etc/sudo_logsrvd.conf` file:
>
> ```conf
> log_format = json
> ``````

> **Resources**
> - 2

> **References**
> - https://opensource.com/article/22/2/new-sudo-features-2022
---
</details>

<details>
<summary>How to record user activity within a shell session started through <code>sudo</code>?</summary>

> ```sudo
> Defaults log_subcmds
> ``````

> **Resources**
> - 2

> **References**
> - https://opensource.com/article/22/2/new-sudo-features-2022
---
</details>

<details>
<summary>How to prevent user from running a specific command even when they have shell access taken from <code>sudo</code>?</summary>

> Let's say the `who` command is dangerous.
>
> ```sudo
> Defaults intercept
> frank ALL = (ALL) ALL, !/usr/bin/who
> ``````
>
> Now users will be prevented to run the `who` command even when they try to run it within a shell opened by `sudo`.
>
> You can easily disable running shells altogether:
>
> ```sudo
> Defaults intercept
> Cmnd_Alias SHELLS=/usr/bin/bash, /usr/bin/sh, /usr/bin/csh
> frank ALL = (ALL) ALL, !SHELLS
> ``````
>
> Not only users cannot start shell sessions through `sudo`, also they cannot execute external commands from editors either.

> **Resources**
> - 2

> **References**
> - https://opensource.com/article/22/2/new-sudo-features-2022
---
</details>

## Chapter 3/16

<details>
<summary>Where is the configuration file for the command <code>useradd</code>?</summary>

> `/etc/login.defs` configuration file.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How configure <code>useradd</code> utility to set default user home directory permissions on Red Hat-based systems?</summary>

> By default, the `useradd` utility on Red Hat-type systems creates user home directories with a permissions setting of `700`, configured in `/etc/login.defs` file.
>
> ```conf
> CREATE_HOME yes
> UMASK 077
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>What configuration directive controls the default permissions of users' home directories?</summary>

> By default, `HOME_MODE` directive in `/etc/login.defs` configuration file is used to set permission for new user home directories.
> But if `HOME_MODE` is not set, the value of `UMASK` is used to create the mode.
>
> On RHEL 8 or RHEL 9-type distro, such as AlmaLinux, the `UMASK` is set for wide-open permissions:
>
> ```conf
> UMASK 022
> ``````
>
> But even though the `UMASK` is wide-open, when `HOME_MODE` is set properly, new user home directories still get properly locked down:
>
> ```conf
> HOME_MODE 0700
> ``````
>
> Either the `HOME_MODE` line or the `UMASK` line is in the login.defs file for all Linux distros, but until recently, Red Hat-type distros have been the only ones that have had them set to a restrictive value by default.
>
> ```conf
> UMASK 077
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How configure <code>useradd</code> utility to set default user home directory permissions on Debian-based systems?</summary>

> The default permission set to users' home directories on Debian-based systems is wide-open, it should be fixed:
>
> ```sh
> cd /home
> sudo chmod 700 *
> ``````
>
> To change the default permissions setting for home directories, edit `/etc/login.defs` configuration file and set directive values accordingly:
>
> ```conf
> UMASK 077
> HOME_MODE 0750
> ``````
>
> This includes access permissions for a user’s own personal group, but that’s okay. It still effectively means that only the respective owners of the various home directories can get into them.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to create a new user on Debian-based systems?</summary>

> Debian-based distros have two user creation utilities:
>
> * `useradd`
> * `adduser`
>
> The `useradd` utility on Debian-based systems does not create user home directory and does not set user shell by default.
> So the command should be used like this:
>
> ```sh
> sudo useradd -m -d /home/frank -s /bin/bash frank
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>What are the differences of <code>adduser</code> and <code>useradd</code> utilities?</summary>

> The `adduser` utility is an interactive way to create user accounts and passwords with a single command, which is unique to the Debian family of Linux distros.
>
> On Debian and Ubuntu 20.04, it creates user home directories with the wide-open 755 permissions value.
> Fix it by overwriting the `DIR_MODE` directive in `/etc/adduser.conf` file:
>
> ```conf
> DIR_MODE=700
> ``````
>
> One thing that `adduser` can do that `useradd` can’t is to automatically encrypt a user’s home directory as you create the account.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to encrypt user's home directory using <code>adduser</code> utility?</summary>

> You’ll first have to install the `ecryptfs-utils` package.
>
> ```sh
> sudo apt install ecryptfs-utils
> ``````
>
> Create a user account with an encrypted home directory for Cleopatra and then view the results:
>
> ```sh
> sudo adduser --encrypt-home cleopatra
> ``````
>
> Log in as Cleopatra and run the `ecryptfs-unwrap-passphrase` command:
>
> ```sh
> su - cleopatra
> ecryptfs-unwrap-passphrase
> exit
> ``````
>
> Note that some of the information that `adduser` asks for is optional, and you can just hit the *Enter* key for those items.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to enforce strong password criteria for users?</summary>

> We’ll be using the `pwquality` module for the **Pluggable Authentication Module (PAM)**.
> This is a newer technology that has replaced the old *cracklib* module.
> On any Red Hat 7 or newer type of system, and on SUSE and OpenSUSE, `pwquality` is installed by default, even if you do a minimal installation.
>
> If you `cd` into the `/etc/pam.d/` directory, you can do a `grep` operation to check that the PAM configuration files are already set up.
> `retry=3` means that a user will only have three tries to get the password right when logging in to the system:
>
> ```sh
> grep 'pwquality' *
> ``````
>
> On Debian and Ubuntu, you’ll need to install `pwquality` yourself:
>
> ```sh
> sudo apt install libpam-pwquality
> ``````
>
> The rest of the procedure is the same for all of our operating systems and consists of just editing the `/etc/security/pwquality.conf` file.
>
> No password complexity criteria are in effect after installation.
>
> The minimum length setting works on a credit system.
> This means that for every different type of character class in the password, the minimum required password length will be reduced by one character.
>
> For example, let’s set minlen to a value of 19 and try to assign Katelyn the password of *turkeylips*:
>
> ```conf
> minlen = 19
> ``````
>
> Because the lowercase characters in *turkeylips* count as credit for one type of character class, we’re only required to have 18 characters instead of 19.
> If we try this again with *TurkeyLips*, the uppercase T and uppercase L count as a second character class, so we only need to have 17 characters in the password.
>
> Let’s say that you don’t want lowercase letters to count toward your credits:
>
> ```conf
> lcredit = 1
> ``````
>
> change the 1 to a 0:
>
> ```conf
> lcredit = 0
> ``````
>
> Then, try assigning Katelyn *turkeylips* as a password.
>
> This time, the `pwquality` really does want 19 characters.
> If we set a credit value to something higher than 1, we would get credit for multiple characters of the same class type up to that value.
>
> We can also set the credit values to negative numbers in order to require a certain number of characters types in a password.
>
> ```conf
> dcredit = -3
> ``````
>
> This would require at least three digits in a password.
> However, it’s a really bad idea to use this feature, because someone who’s doing a password attack would soon find the patterns that you require,
> which would help the attacker to direct the attack more precisely.
> If you need to require that a password has multiple character types, it would be better to use the minclass parameter:
>
> ```conf
> minclass = 3
> ``````
>
> It’s already set to a value of 3, which would require characters from three different classes. To use this value, all you have to do is to remove the comment symbol.
>
> In the `/etc/login.defs` file on your CentOS 7 machine, you’ll see the line `PASS_MIN_LEN 5`.
> Supposedly, this is to set the minimum password length, but in reality, `pwquality` overrides it.
> So, you could set this value to anything at all, and it would have no effect. (Note that the `PASS_MIN_LEN` parameter is no longer supported on RHEL 8/9-type distros.)

> **Resources**
> - 3

> **References**
---
</details>


<details>
<summary>How to enforce password and account expiration on Linux?</summary>

> With the `chage` utility, you can either set password and account expiration data for other users or use the `-l` option to view expiration data.
> Any unprivileged user can use `chage -l` without `sudo` to view his or her own data.
>
> let’s first look at where the default settings are stored. 
> Default settings are stored in `/etc/login.defs` file.
>
> ```
> PASS_MAX_DAYS 99999
> PASS_MIN_DAYS 0
> PASS_WARN_AGE 7
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to configure default expiry data for `useradd` for Red Hat-type systems?</summary>

> The `/etc/default/useradd` file has the default settings.  
>
> Ubuntu also has the `useradd` configuration file, but it doesn’t work.
> No matter how you configure it, the Ubuntu version of useradd just won’t read it. So, the write-up about this file only applies to Red Hat-type systems.
>
> The `EXPIRE=` line sets the default expiration date for new user accounts.
>
> By default, there is no default expiration date.
> `INACTIVE=-1` means that user accounts won’t be automatically locked out after the users’ passwords expire.
> If we set this to a positive number, then any new users will have that many days to change an expired password before the account gets locked.
>
> To change the defaults in the `useradd` file, you can either hand-edit the file or use `useradd -D` with the appropriate option switch for the item that you want to change.
>
> For example, to set a default expiration date of December 31, 2025, the command would be as follows:
>
> ```sh
> sudo useradd -D -e 2025-12-31
> ``````
>
> To see the new configuration, you can either open the `useradd` file or just do `sudo useradd -D`.
>
> `useradd` doesn’t do any safety checks to ensure that the default shell that you’ve assigned is installed on the system.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to set expiry data on a user with <code>useradd</code> and <code>usermod</code> utility?</summary>

> There are three ways that you can do this:
>
> 1. Use `useradd` with the appropriate option switches to set expiry data as you create the accounts. 
> 2. Use `usermod` to modify expiry data on existing accounts.
> 3. Use `chage` to modify expiry data on existing accounts.
>
> You can use `useradd` and `usermod` to set account expiry data, but not to set password expiry data.
>
> * -e: Use this to set an expiration date for the account, in the form YYYY-MM-DD.
> * -f: Use this to set the number of days after the user’s password expires that you want for his or her account to get locked out.
>
> Let’s say that you want to create an account for Charlie that will expire at the end of 2025.
>
> ```sh
> sudo useradd -e 2025-12-31 charlie
> sudo useradd -m -d /home/charlie -s /bin/bash -e 2025-12-31 charlie
> ``````
>
> Verify what you’ve entered:
>
> ```sh
> sudo chage -l charlie
> ``````
>
> Now, let’s say that Charlie’s contract has been extended, and you need to change his account expiration to the end of January 2026.
>
> ```sh
> sudo usermod -e 2026-01-31 charlie
> ``````
>
> Optionally, you can set the number of days before an account with an expired password will get locked out:
>
> ```sh
> sudo usermod -f 5 charlie
> ``````
>
> But if you were to do that now, you wouldn’t see any difference in the `chage -l` output because we still haven’t set expiration data for Charlie’s password.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to set expiry data on a user with <code>chage</code> utility?</summary>

> You will only use `chage` to modify existing accounts, and you will use it for setting either an account expiration or a password expiration.
>
> * `-d` If you use the `-d` 0 option on someone’s account, you’ll force the user to change his or her password on their next login.
> * `-E` This is equivalent to the lowercase `-e` for useradd or usermod. It sets the expiration date for the user account.
> * `-I` This is equivalent to `-f` for useradd or usermod. It sets the number of days before an account with an expired password will be locked out.
> * `-m` This sets the minimum number of days between password changes. In other words, if Charlie changes his password today, the `-m 5` option will force him to wait five days before he can change his password again.
> * `-M` This sets the maximum number of days before a password expires. (Be aware, though, that if Charlie last set his password 89 days ago, using a `-m 90` option on his account will cause his password to expire tomorrow, not 90 days from now.)
> * -W This will set the number of warning days for passwords that are about to expire.
>
> ```sh
> sudo chage -E 2026-02-28 -I 4 -m 3 -M 90 -W 4 charlie
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to force users to change their password the first time they logs in?</summary>

> ```sh
> sudo chage -d 0 samson
> sudo passwd -e samson
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to prevent brute-force password attacks on Linux user accounts?</summary>

> Set the lockout value to something realistic, such as 100 failed login attempts.  
> This will provide good security, while still giving you enough time to gather information about the attackers.
>
> On RHEL 7-type systems and Ubuntu 18.04, you’ll do this by configuring the `pam_tally2` PAM.  
> On RHEL 8/9-type systems and Ubuntu 20.04/22.04, you’ll instead configure the `pam_faillock` PAM module.
>
> The `pam_tally2` module comes already installed on CentOS 7, but it isn’t configured.  
> We’ll begin by editing the `/etc/pam.d/login` file.
>
> If you’re working with a text-mode server, you’ll only need to configure the `/etc/pam.d/login` file.
> But if you’re working with a machine that’s running a graphical desktop environment, you’ll also need to configure the `/etc/pam.d/password.auth` and `/etc/pam.d/system.auth` files.
>
> In the second line of the example, we see that `pam_tally2` is set with the following parameters:
>
> * `deny=4`: This means that the user account under attack will get locked out after only four failed login attempts.
> * `even_deny_root`: This means that even the root user account will get locked if it’s under attack.
> * `unlock_time=1200`: The account will get automatically unlocked after 1,200 seconds, or 20 minutes.
>
> Once you’ve configured the login file and have had a failed login, you’ll see a new file created in the `/var/log` directory.
> You’ll view information from that file with the `pam_tally2` utility.
> You can also use `pam_tally2` to manually unlock a locked account if you don’t want to wait for the timeout period:
>
> ```sh
> sudo pam_tally2
> sudo pam_tally2 --user=charlie --reset
> sudo pam_tally2
> ``````
>
> Configuring `pam_tally2` is super easy because it only requires adding one line to the `/etc/pam.d/login`, `/etc/pam.d/password.auth`, and `/etc/pam.d/system.auth` files.
> To make things even easier, you can just copy and paste that line from the example on the `pam_tally2` man page.
>
> On the CentOS 7 virtual machine, open the `/etc/pam.d/login` file for editing.
> Look for the line that invokes the `pam_securetty` module. insert this line:
>
> ```
> auth required pam_tally2.so deny=4 even_deny_root unlock_time=1200
> ``````
>
> Place the same line at the top of the `/etc/pam.d/password.auth` and `/etc/pam.d/system`.
>
> `pam_tally2` doesn’t work with su.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to configure <code>pam_faillock</code> on AlmaLinux 8/9?</summary>

> The `pam_faillock` module is already installed on any RHEL 8 or RHEL 9-type of Linux distro.
>
> Although you can enable and configure `pam_faillock` by hand-editing the PAM configuration files, the RHEL distros provide an easier method, which is called `authselect`.
> On either an AlmaLinux 8 or AlmaLinux 9 VM, view the available `authselect` profiles by doing:
>
> ```sh
> sudo authselect list
> ``````
>
> For now, at least, we’re only dealing with local users.
> So, we’ll use the minimal profile.
> View the features of this profile like this:
>
> ```sh
> sudo authselect list-features minimal
> ``````
>
> Note that there are a lot of included features, but we’re only interested in the **with-faillock** feature.
>
> ```sh
> sudo authselect select minimal --force
> ``````
>
> After enabling a profile, we can now enable the `pam_faillock` module, like this:
>
> ```sh
> sudo authselect enable-feature with-faillock
> ``````
>
> In the `/etc/security/` directory, open the `faillock.conf` file in your favorite text editor.
>
> ```
> # silent
> # deny = 3
> # unlock_time = 600
> # even_deny_root
> ``````
>
> Remove the preceding comment symbols from all four lines, and save the file.
>
> Create a user account for Vicky by doing:
>
> ```sh
> sudo useradd vicky sudo passwd vicky
> ``````
>
> Open another terminal, and have Vicky deliberately make three failed login attempts.
> View the results in your own terminal, like this:
>
> ```sh
> sudo faillock
> sudo faillock --reset --user vicky
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to configure <code>pam_faillock</code> on Ubuntu 20.04 and Ubuntu 22.04?</summary>

> Sadly, the `authselect` utility isn’t available for Ubuntu, so we’ll just have to hand-edit the PAM configuration files.
>
> Open the `/etc/pam.d/common-auth` file in your favorite text editor.
> At the top of the file, insert these two lines:
>
> ```
> auth required pam_faillock.so preauth silent
> auth required pam_faillock.so authfail
> ``````
>
> Open the `/etc/pam.d/common-account` file in your text editor.
> At the bottom of the file, add this line:
>
> ```
> account required pam_faillock.so
> ``````
>
> Configure the `/etc/security/faillock.conf` file.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to lock Linux user accounts?</summary>

> There are two utilities that you can use to temporarily lock a user account:
>
> * usermod
> * passwd
>
> We can lock and unlock an account by doing:
>
> ```sh
> sudo usermod -L katelyn
> sudo usermod -U katelyn
> ``````
>
> Using `passwd` to lock and unlock user accounts:
>
> ```sh
> sudo passwd -l katelyn
> sudo passwd -u katelyn
> ``````
>
> This does the same job as `usermod -L`, but in a slightly different manner.
> For one thing, `passwd -l` will give you some feedback about what’s going on, whereas `usermod -L` gives you no feedback at all.

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to lock the root user account on Linux?</summary>

> The first thing that you want to do when you set up a cloud-based server is to create a normal user account for yourself and set it up with full sudo privileges.
> Then, log out of the `root` user account, log in to your new account, and do this:
>
> ```sh
> sudo passwd -l root
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to set up security banners on Linux systems?</summary>

> The `/etc/motd` file will present a message banner to anyone who logs in to a system through Secure Shell.
> On your CentOS or AlmaLinux machine, an empty motd file is already there.
> On your Ubuntu machine, the motd file isn’t there, but it’s a simple matter to create one.
>
> motd stands for **Message of the Day**.
>
> The issue file, also found in the /etc directory, shows a message on the local terminal, just above the login prompt.
> A default issue file will just contain macro code that shows information about the machine.
> Here’s an example from an Ubuntu machine:
>
> ```
> Ubuntu 22.04.1 LTS \n \l
> ``````
>
> On a Red Hat-type machine, it would look like this:
>
> ```
> \S Kernel \r on an \m
> ``````

> **Resources**
> - 3

> **References**
---
</details>

<details>
<summary>How to detect compromised passwords?</summary>

> You can check your password on https://haveibeenpwned.com, but it is not a good idea to send your raw password to somebody’s website.
> Instead, just send a hash value of the password.
> Better yet, let’s just send enough of the hash to allow the site to find the password in its database, but not so much that they can figure out what your exact password is.
> We’ll do that by using the *Have I Been Pwned?* Application Programming Interface (API):
>
> ```sh
> echo -n $candidate_password | sha1sum
> curl https://api.pwnedpasswords.com/range/21BD1
> ``````

> **Resources**
> - 3

> **References**
---
</details>

## Chapter 4/16

<details>
<summary>How to look at the current configuration of the <code>iptables</code> rules?</summary>

> You need a separate component of iptables to deal with IPv4 and IPv6.
>
> ```sh
> sudo iptables -L
> sudo ip6tables -L
> ``````
>
> To see port numbers instead of port names, we can use the `-n` switch:
>
> ```sh
> sudo iptables -L -n
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>What <code>iptables</code> rule allows incoming packets from servers that our host has requested a connection to?</summary>

> ```sh
> sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
> ``````
>
> * `-A INPUT`: Places the rule at the end of the specified chain.
> * `-m`: Calls in an iptables module. In this case, we’re calling in the conntrack module to track connection states.
> * `--ctstate`: The ctstate, or connection state, portion of our rule is looking for two things. First, it’s looking for a connection that the client established with a server. Then, it looks for the related connection that’s coming back from the server in order to allow it to connect to the client. So, if a user was to use a web browser to connect to a website, this rule would allow packets from the web server to pass through the firewall to get to the user’s browser.
> * `-j`: Rules jump to a specific target, which in this case is ACCEPT.

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to write <code>iptables</code> rules to open up a ports?</summary>

> To open port for **SSH** protocol following rule applies:
>
> ```sh
> sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT
> sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
> ``````
> When an option name consists of more than one letter, we need to precede it with two dashes, instead of just one.
>
> * `-A INPUT`: Place this rule at the end of the `INPUT` chain.
> * `-p tcp`: Indicates the protocol that this rule affects.
> * `--dport ssh`:  Specifies the destination port on which we want this rule to operate.
> * `-j ACCEPT`: Jump to ACCEPT target.
>
> To open port 53 for both the TCP and UDP protocols:
>
> ```sh
> sudo iptables -A INPUT -p tcp --dport 53 -j ACCEPT
> sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to add an <code>iptables</code> rule to allow loopback interface?</summary>

> ```sh
> sudo iptables -I INPUT 1 -i lo -j ACCEPT
> ``````
>
> `sudo` needs to know the machine’s hostname so that it can know which rules are allowed to run on a particular machine.
> It uses the loopback interface to help resolve the hostname.
> If the lo interface is blocked, it takes longer for `sudo` to resolve the hostname.

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to block ICMP packets by <code>iptables</code> rules?</summary>

> While blocking certain types of ICMP packets is good, blocking all ICMP packets is bad.
> The harsh reality is that certain types of ICMP messages are necessary for the proper functionality of the network.
> Since the drop all that’s not allowed rule that we’ll eventually create also blocks ICMP packets, we’ll need to create some rules that allow the types of ICMP messages that we have to have.
>
> ```sh
> sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 3 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
> sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 11 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
> sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 12 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
> ``````
>
> * `-m conntrack`: Use the conntrack module to allow packets that are in a certain state. This time, though, instead of just allowing packets from a host to which our server has been connected (`ESTABLISHED`,`RELATED`), we’re also allowing `NEW` packets that other hosts are sending to our server.
> * `-p icmp`: This refers to the ICMP protocol.
> * `--icmp-type`: There are quite a few types of ICMP messages:
>     + **type 3**: These are the **“destination unreachable”** messages. Not only can they tell your server that it can’t reach a certain host, but they can also tell it why. For example, if the server has sent out a packet that’s too large for a network switch to handle, the switch will send back an ICMP message that tells the server to fragment that large packet. Without ICMP, the server would have connectivity problems every time it tries to send out a large packet that needs to be broken up into fragments.
>     + **type 11**: **Time-exceeded** messages let your server know that a packet that it has sent out has either exceeded its **Time-to-Live (TTL)** value before it could reach its destination, or that a fragmented packet couldn’t be reassembled before the **TTL** expiration date.
>     + **type 12**: **Parameter problem** messages indicate that the server had sent a packet with a bad IP header. In other words, the IP header is either missing an option flag or it’s of an invalid length.
>     + **type 0** and **type 8**: These are the infamous ping packets. Actually, type 8 is the **echo request** packet that you would send out to ping a host, while type 0 is the **echo reply** that the host would return to let you know that it’s alive. Of course, allowing ping packets to get through could be a big help when troubleshooting network problems. If that scenario ever comes up, you could just add a couple of iptables rules to temporarily allow pings.
>     + **type 5**: Now, we have the infamous **redirect messages**. Allowing these could be handy if you have a router that can suggest more efficient paths for the server to use, but hackers can also use them to redirect you to someplace that you don’t want to go. So, just block them.

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to change the <code>iptables</code> default chain policy?</summary>

> We can set a default `DROP` or `REJECT` policy for the `INPUT` chain, or we can leave the policy set to `ACCEPT` and create a `DROP` or `REJECT` rule at the end of the `INPUT` chain.
> Which one you choose is really a matter of preference.
>
> To create a `DROP` rule at the end of the `INPUT` chain, use this command:
>
> ```sh
> sudo iptables -A INPUT -j DROP
> sudo iptables -P INPUT DROP
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to make iptables rules permanent?</summary>

> There are several ways to do this, but the simplest way to do this on an Ubuntu machine is to install the `iptables-persistent` package:
>
> ```sh
> sudo apt install iptables-persistent
> ``````
>
> You’ll now see two new rules files `rules.v4` and `rules.v6` in the `/etc/iptables/` directory.
>
> The `iptables-persistent` package won’t save subsequent changes to your iptables rules.
> To make these changes permanent, I’ll use the `iptables-save` command to save a new file in my own home directory.
> Then, I’ll copy the file over to the `/etc/iptables` directory, replacing the original one:
>
> ```sh
> sudo iptables-save > rules.v4
> sudo cp rules.v4 /etc/iptables/
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to block invalid packets before they travel through the entire <code>INPUT</code> chain in <code>iptables</code> rules?</summary>

> We could do that with a `PREROUTING` chain, but the filter table doesn’t have a `PREROUTING` chain.
> Therefore, we need to use the `PREROUTING` chain of the mangle table instead.
> Let’s start by adding these two rules:
>
> ```sh
> sudo iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP
> sudo iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to perform a port availability test on a machine when <code>iptables</code> blocks <code>INVALID</code> packets from <code>PREROUTING</code> chain?</summary>

> With our new mangle table rules in place, let’s perform an XMAS scan:
>
> ```sh
> sudo nmap -sX 192.168.0.15
> ``````
>
> The XMAS scan sends invalid packets that consist of the `FIN`, `PSH`, and `URG` flags.
>
> To see packats counter on the target machine run:
>
> ```sh
> sudo iptables -t mangle -L PREROUTING -v
> ``````
>
> The fact that all 1,000 scanned ports show as `open|filtered` means that the scan was blocked, and that Nmap can’t determine the true state of the ports.
> We can view the result to see which rule did the blocking.
> Here, you can see that the first rule — the `INVALID` rule — blocked 2,000 packets and 80,000 bytes.
>
> Now, let’s zero out the counter so that we can do another scan:
>
> ```sh
> sudo iptables -t mangle -Z PREROUTING
> ``````
>
> This time, let’s do a Window scan, which bombards the target machine with ACK packets:
>
> ```sh
> sudo nmap -sW 192.168.0.15
> ``````
>
> As before, the scan was blocked, as indicated by the message that all 1,000 scanned ports have been filtered.
>
> ```sh
> sudo iptables -t mangle -L PREROUTING -v
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to block ICMP packets over IPv6 by <code>iptables</code> rules?</summary>

> The biggest difference is that instead of using the `iptables` command, you’ll use the `ip6tables` command.
> The other big difference between IPv4 and IPv6 is that with IPv6, you must allow more types of ICMP messages than you need to for IPv4.
>
> ```sh
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 1 -j ACCEPT # Destination unreachable
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 2 -j ACCEPT # Packet too big
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 3 -j ACCEPT # Time exceeded
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 4 -j ACCEPT # Parameter problem with the packet header
> ``````
>
> Next, we’ll enable **echo requests** (type 128) and **echo responses** (type 129) so that IPv6 over IPv4 tunneling will work:
>
> ```sh
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 128 -j ACCEPT # Echo Requests
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 129 -j ACCEPT # Echo Responses
> ``````
>
> The next four ICMP message types that we need are for the **Link-local Multicast Receiver Notification** messages:
>
> ```sh
> sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 130 # Listener query
> sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 131 # Listener report
> sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 132 # Listener done
> sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 143 # Listener report v2
> ``````
>
> Next up are our neighbor and router discovery message types:
>
> ```sh
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 134 -j ACCEPT # Router solicitation
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 135 -j ACCEPT # Router advertisement
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 136 -j ACCEPT # Neighbor solicitation
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 141 -j ACCEPT # Neighbor advertisement
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 142 -j ACCEPT
> ``````
>
> For times when you’re using security certificates to authenticate the routers that are attached to your network, you’ll also need to allow **Secure Neighbor Discovery** (SEND) messages:
>
> ```sh
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 148 -j ACCEPT # Inverse neighbor discovery solicitation
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 149 -j ACCEPT # Inverse neighbor discovery advertisement
> ``````
>
> We need to allow **Multicast Router Discovery** messages:
>
> ```sh
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 151 -j ACCEPT
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 152 -j ACCEPT
> sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 153 -j ACCEPT
> ``````
>
> Finally, we’ll add our **DROP** rule to block everything else:
>
> ```sh
> sudo ip6tables -A INPUT -j DROP
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to list installed tables in <code>nftables</code>?</summary>

> ```sh
> sudo nft list tables
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to configure <code>nftables</code>?</summary>

> First, we’ll go into the directory where the sample configurations are stored and list the sample configuration files:
>
> ```sh
> cd /usr/share/doc/nftables/examples/
> ``````
>
> Next, we’ll copy the workstation file over to the `/etc` directory, changing its name to `nftables.conf`.
>
> ```sh
> sudo cp workstation.nft /etc/nftables.conf
> ``````
>
> * `flush ruleset`: We want to start with a clean slate, so we’ll flush out any rules that may have already been loaded.
> * `table inet filter`: This creates an inet family filter, which works for both IPv4 and IPv6.
> * `chain input`: Within the first pair of curly brackets, we have a chain called input.
> * `type filter hook input priority 0;`: Within the next pair of curly brackets, we define our chain and list the rules. This chain is defined as a filter type. hook input indicates that this chain is meant to process incoming packets. Because this chain has both a hook and a priority, it will accept packets directly from the network stack.
>
> Next is the standard connection tracking (ct) rule, which accepts traffic that’s in response to a connection request from this host.
>
> * `ct state new`: indicates that the firewall will allow other hosts to initiate connections to our server on these ports.
> * `meta nfproto ipv6`: accepts neighbor discovery packets, allowing IPv6 functionality.
> * `counter drop`: rule at the end silently blocks all other traffic and counts both the number of packets and the number of bytes that it blocks.
>
> let’s say that this is a DNS server, and we need to allow connections to port 22 and port 53.
>
> ```
> tcp dport { 22, 53 } ct state new accept
> udp dport 53 ct state new accept
> ``````
>
> ```sh
> sudo nft list ruleset
> ``````
>
> * The `counter drop` rule drops and counts unwanted packets.
>
> let’s say that we want to make a log entry when packets are dropped.
> Just add the log keyword to the drop rule, like so:
>
> ```
> counter log drop
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to prefix <code>nftables</code> log messages?</summary>

> To make these messages easier to find, add a tag to each log message, like this:
>
> ```
> counter log prefix "Dropped packet: " drop
> ``````
>
> Now, when you need to peruse the `/var/log/kern.log` file to see how many dropped packets you’ve had, just search for the Dropped packet text string.

> Origin:

> **References**
---
</details>

<details>
<summary>How to use <code>nftables</code> to block certain IP addresses from reaching specific ports?</summary>

> To do this, we can edit the file, placing a `drop rule` above the rule that opens port 22.
> The relevant section of the file will look like this:
>
> ```
> tcp dport 22
> ip saddr { 192.168.0.7, 192.168.0.10 } log prefix "Blocked SSH packets: "
> drop tcp dport { 22, 53 } ct state new accept
> ``````
>
> Next, we need to allow the desired types of ICMP packets, like so:
>
> ```
> ct state new,related,established icmp type { destination-unreachable, time-exceeded, parameter-problem } accept
> ct state established,related,new icmpv6 type { destination-unreachable, time-exceeded, parameter-problem } accept
> ``````
>
> Finally, we’ll block invalid packets by adding a new prerouting chain to the filter table, like so:
>
> ```
> chain prerouting {
>     type filter hook prerouting priority 0;
>     ct state invalid counter log prefix "Invalid Packets: " drop tcp flags & (fin|syn|rst|ack) != syn
>     ct state new
>     counter log drop
> }
> ``````
>
> ```sh
> sudo systemctl reload nftables
> ``````

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to IPv4 rules with IPv6 rules in the same <code>nftables</code> configuration file?</summary>

> Unless we specify otherwise, all the rules that we create in `inet` table will apply to both IPv4 and IPv6.

> **Resources**
> - 4

> **References**
---
</details>

<details>
<summary>How to stop an attack in progress quickly without bringing down the system?</summary>

> With an `nft` command, you can create a custom rule on the fly that will block the attack.
>
> First, let’s delete our previous configuration and create an inet table since we want something that works for both IPv4 and IPv6.
> We’ll want to give it a somewhat descriptive name, so let’s call it `ubuntu_filter`:
>
> ```sh
> sudo nft delete table inet filter
> sudo nft list tables
> sudo nft add table inet ubuntu_filter
> sudo nft list tables
> ``````
>
> Next, we’ll add an input filter chain to the table that we just created
>
> ```sh
> sudo nft add chain inet ubuntu_filter input { type filter hook input priority 0\; policy drop\; }
> ``````
>
> Each nftables protocol family has its own set of hooks, which define how the packets will be processed.
>
> For now, we’re only concerned with the ip/ip6/inet families, which have the following hooks:
>
> * Prerouting
> * Input
> * Forward
> * Output
> * Postrouting
>
> If we had not specified drop as the default policy, then the policy would have been accept by default.
>
> Let’s start with a connection tracking rule and a rule to open the Secure Shell port.
> Then, we’ll verify that they were added:
>
> ```
> sudo nft add rule inet ubuntu_filter input ct state established accept sudo nft add rule inet ubuntu_filter input tcp dport 22 ct state new accept sudo nft list table inet ubuntu_filter  table inet ubuntu_filter {  chain input {
> type filter hook input priority 0; policy drop;
> ct state established accept  tcp dport ssh ct state new accept  }  }
> ``````
>
> We forgot to create a rule to allow the loopback adapter to accept packets.
> Since we want this rule to be at the top of the rules list, we’ll use insert instead of add:
>
> ```
> sudo nft insert rule inet ubuntu_filter input iif lo accept sudo nft list table inet ubuntu_filter
> table inet ubuntu_filter {  chain input {  type filter hook input priority 0; policy drop;
> iif lo accept  ct state established accept  tcp dport ssh ct state new accept  }  }
> ``````
>
> What if we want to insert a rule at a specific location? For that, you’ll need to use list with the `-a` option to see the rule handles:
>
> ```sh
> sudo nft list table inet ubuntu_filter -a  table inet ubuntu_filter {  chain input {  type filter hook input priority 0; policy drop; iif lo accept # handle 4  ct state established accept # handle 2  tcp dport ssh ct state new accept # handle 3  }  }
> ``````
>
> There’s no real rhyme or reason for the way the handles are numbered.
>
> To delete a rule, we have to specify the rule’s handle number:
>
> ```sh
> sudo nft delete rule inet ubuntu_filter input handle 6 sudo nft list table inet ubuntu_filter -a  table inet ubuntu_filter {  chain input {  type filter hook input priority 0; policy drop; iif lo accept # handle 4  ct state established accept # handle 2  tcp dport ssh ct state new accept # handle 3  }  }
> ``````
>
> As is the case with iptables, everything you do from the command line will disappear once you reboot the machine. To make it permanent, let’s redirect the output of the list subcommand to the nftables.
> conf configuration file
>
> ```sh
> sudo sh -c "nft list table inet ubuntu_filter > /etc/nftables.conf"
> ``````
>
> We’re missing the flush rule and the shebang line to specify the shell that we want to interpret this script.
>
> ```
> #!/usr/sbin/nft -f flush ruleset table inet ubuntu_filter {  chain input {  type filter hook input priority 0; policy drop;
> iif lo accept  ct state established accept  tcp dport ssh ct state new accept  } }
> ``````
>
> ```sh
> sudo systemctl reload nftables sudo nft list table inet ubuntu_filter
> ``````

> **Resources**
> - 4

> **References**
---
</details>

## Chapter 5/16
## Chapter 6/16
## Chapter 7/16
## Chapter 8/16
## Chapter 9/16
## Chapter 10/16
## Chapter 11/16
## Chapter 12/16
## Chapter 13/16
## Chapter 14/16
## Chapter 15/16
## Chapter 16/16

# Linux Kernel Programming Part 2
<img src="../covers/9781801079518.jpg" width="200"/>

## Chapter 1/7 <sup>(writing)</sup>

<details>
<summary>Where is the documentation information on driver APIs?</summary>

> In kernel documentation, driver section.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
> - https://kernel.org/doc/html/latest/driver-api/index.html
---
</details>

<details>
<summary>What is a good starting step to learn writing a simple platform driver?</summary>

> Write a platform driver, register it with the kernel's `misc` framework and
> the **platform bus**, a pseudo-bus infrastructure that supports devices that
> do not physically reside on any physical bus. Several peripherals built into
> a modern **SoC** are not on any physical bus, and thus their drivers are
> typically platform drivers. To get started, look under the kernel source tree
> in `drivers/` for code invoking the `platform_driver_register()` API.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
> - https://kernel.org/doc/html/latest/driver-model/platform.html
---
</details>

<details>
<summary>What mechanisms are required for user space applications to gain access to the underlying device drivers within the kernel?</summary>

> In order for a user space application to gain access to the underlying device
> driver within the kernel, some I/O mechanism is required. The Unix (and thus
> Linux) design is to have the process open a special type of file, a **device
> file**, or **device node**. These files typically live in the `/dev`
> directory.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>What inode attributes are used to distinguish between device files?</summary>

> In order for the kernel to distinguish between device files, it uses two
> attributes within their inode data structure:
>
> * The type of file – either char or block
> * The major and minor number

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>What is a device driver namespace?</summary>

> A namespace contains the device type and major-minor pair, which form a
> hierarchy. Devices are organized within a tree-like hierarchy within the
> kernel. This hierarchy is first divided based on device type, block or char.
> Within that we have n major numbers for each type, and each major number is
> further classified via some m minor numbers.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
> - https://www.kernel.org/doc/Documentation/admin-guide/devices.txt
---
</details>

<details>
<summary>What is the difference between block and char devices in namespaces?</summary>

> Block devices have the kernel-level capability to be mounted and thus become
> part of the user-accessible filesystem. Character devices cannot be mounted;
> thus, storage devices tend to be block-based.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>What distinguishes device classes in the kernel?</summary>

> From 2.6 Linux onward, the `{major:minor}` pair is a single unsigned 32-bit
> quantity within the inode, a bitmask (it's the `dev_t i_rdev` member). Of
> these 32 bits, the MSB 12 bits represent the major number and the remaining
> LSB 20 bits represent the minor number.
>
> Only **Linux Assigned Names And Numbers Authority (LANANA)** can officially
> assign the device node (the type and `{major:minor}` numbers) to devices
>
> The minor number's meaning (interpretation) is left completely to the driver
> author; the kernel does not interfere.
>
> Here, the exception to the rule - that the kernel doesn't interpret the minor
> number – is the `misc` class (type character, major `#10`). It uses the minor
> numbers as second-level majors.
>
> A common problem is that of the namespace getting exhausted. Within the misc
> class (`#10`) live a lot of devices and their corresponding drivers. In
> effect, they share the same major number and rely on a unique minor number to
> identify themselves.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
> - https://www.kernel.org/doc/Documentation/admin-guide/devices.txt
---
</details>

<details>
<summary>Register a misc driver in the kernel?</summary>

> ```c
> #include <linux/miscdevice.h>
> #include <linux/fs.h>
>
> static struct miscdevice miscdev = {
>     .name = "miscdev",
>     .minor = MISC_DYNAMIC_MINOR,
>     .mode = 0666,
>     .fops = &misc_fops,
> };
>
> static int __init miscdev_init(void)
> {
>     pr_info("miscdev loaded\n");
> }
>
> module_init(miscdev_init);
> ``````

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>Propegate unsupported file operation error from kernel driver to user space proces?</summary>

> An appropriate value to return if you aren't supporting a function is `-ENOSYS`, which will have the user-mode process see the error `Function not implemented`.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>Register a misc driver in the kernel?</summary>

> ```c
> #include <linux/miscdevice.h>
> #include <linux/fs.h>
>
> static struct miscdevice miscdev = {
>     .name = "miscdev",
>     .minor = MISC_DYNAMIC_MINOR,
>     .mode = 0600,
>     .fops = &misc_fops,
> };
>
> static int __init miscdev_init(void)
> {
>     int ret = 0;
>     struct device *dev = NULL;
>
>     ret = misc_register(&miscdev);
>
>     if (ret != 0)
>     {
>         pr_notice("miscdev registration failed, aborting\n");
>         return ret;
>     }
>
>     dev = miscdev.this_device;
> }
>
> static void __exit miscdev_exit(void)
> { }
>
> module_init(miscdev_init);
> module_exit(miscdev_exit);
>
> MODULE_LICENSE("GPL");
> MODULE_AUTHOR("Brian Salehi <salehibrian@gmail.com");
> MODULE_DESCRIPTION("Sample misc device");
> MODULE_VERSION("0.1");
> ``````

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>What is the entry point of device drivers?</summary>

> A device driver is the interface between the OS and a peripheral hardware
> device. It can be written inline and compiled within the kernel image file or
> written outside of the kernel source tree as a kernel module.
>
> A device driver provides several entry points into the kernel known as the
> driver's methods. All possible methods the driver author can hook into are in
> `file_operations` kernel data structure defined in `include/linux/fs.h`
> header file.
>
> `device file`, or `device node` files typically live in the `/dev` directory,
> and on modern systems are dynamic and auto-populated. The device node serves
> as an entry point into the device driver.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>Assign file operations on a misc driver?</summary>

> The `file_operations` structure represents all possible `file_related` system
> calls that could be issued on a device file including `open`, `read`, `poll`,
> `mmap`, `release`, and several more members.
>
> Once your driver is registered with the kernel, when any user space process
> opens a device file registered to this driver, the kernel **Virtual
> Filesystem Switch (VFS)** layer will take over to allocate and initialize
> that process's open file data structure (`struct file`) for the device file.
>
> ```c
> #include <linux/miscdevice.h>
> #include <linux/fs.h>
>
> static const struct file_operations misc_fops = {
>     .open = open_miscdev,
>     .read = read_miscdev,
>     .write = write_miscdev,
>     .release = release_miscdev,
> };
>
> static struct miscdevice miscdev = {
>     .name = "miscdev",
>     .minor = MISC_DYNAMIC_MINOR,
>     .mode = 0600,
>     .fops = &misc_fops,
> };
>
> static int __init miscdev_init(void)
> {
>     int ret = 0;
>     struct device *dev = NULL;
>
>     ret = misc_register(&miscdev);
>
>     if (ret != 0)
>     {
>         pr_notice("miscdev registration failed, aborting\n");
>         return ret;
>     }
>
>     dev = miscdev.this_device;
>
>     if (!dev)
>     {
>         return 1;
>     }
>
>     dev_info(dev, "driver %d registered on /dev/%s\n", miscdev.minor, miscdev.name);
>     return 0;
> }
>
> static void __exit miscdev_exit(void)
> { }
>
> module_init(miscdev_init);
> module_exit(miscdev_exit);
>
> MODULE_LICENSE("GPL");
> MODULE_AUTHOR("Brian Salehi <salehibrian@gmail.com");
> MODULE_DESCRIPTION("Sample misc device");
> MODULE_VERSION("0.1");
> ``````

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>Where do device drivers should reside in the kernel?</summary>

> From the 2.6 kernel onward, the unified **Linux Device Model (LDM)** that
> among its many features, it creates a complex, hierarchical tree exposed to
> user space via the sysfs pseudo-filesystem and is typically mounted under
> `/sys` containing several directories that can be considered viewports into
> the LDM. A fundamental LDM tenet is that *every single device must reside on
> a bus* where buses are located in `/sys/bus` directory.

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>Implement open file operation function in device driver?</summary>

> The signature of functions should be identical to that of the `file_operation` structure.
>
> ```c
> static int miscdev_open(struct inode *inode, struct file *fp)
> {
>     char *kbuf = kzalloc(PATH_MAX, GFP_KERNEL);
>
>     if (unlikely(!kbuf))
>         return -ENOMEM;
>
>     PRINT_CTX(); // displays process (or atomic) context info
>     pr_info(" opening \"%s\": 0x%x\n", file_path(fp, kbuf, PATH_MAX), fp->f_flags);
>     kfree(kbuf);
>     return nonseekable_open(inode, fp);
> }
> ``````

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

<details>
<summary>Implement read file operation function in device driver?</summary>

> ```c
> #include <linux/miscdevice.h>
> #include <linux/fs.h>
>
> static const file_operations misc_fops = {
>     .read = misc_open,
> };
>
> static struct miscdevice misc_dev = {
>     .name = "misc_dev",
>     .minor = MISC_DYNAMIC_MINOR,
>     .mode = 0666,
>     .fops = &misc_fops,
> };
>
> static int misc_open(struct inode *inode, struct file *fp)
> {
>     char *kbuf = kzalloc(PATH_MAX, GFP_KERNEL);
>
>     if (unlikely(!kbuf))
>         return -ENOMEM;
>
>     pr_info("opening %s (0x%x)\n", file_path(fp, kbuf, PATH_MAX), fp->f_flags);
>     kfree(kbuf);
>     return nonseekable_open(inode, fp);
> }
>
> static int __init misc_init(void)
> {
>     int ret = 0;
>     struct device *dev = NULL;
>
>     ret = misc_register(&misc_dev);
>     if (ret != 0)
>     {
>         pr_notice("misc_dev registration failed\n");
>         return ret;
>     }
>
>     dev = misc_dev.this_device;
> }
>
> static void __exit misc_exit(void)
> {
>     misc_deregister(&misc_dev);
>     pr_info("misc_dev unloaded\n");
> }
>
> module_init(misc_init);
> module_exit(misc_exit);
>
> MODULE_LICENSE("GPL");
> MODULE_AUTHOR("Brian Salehi <salehibrian@gmail.com>");
> ``````

> Origins:
> - Linux Kernel Programming Part 2 - Chapter 1

> References:
---
</details>

## Chapter 2/7
## Chapter 3/7
## Chapter 4/7
## Chapter 5/7
## Chapter 6/7
## Chapter 7/7

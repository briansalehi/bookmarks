# C++17: The Complete Guide

<img alt="9783967300178" src="covers/9783967300178.jpg" width="200"/>

## Chapter 1/29 <sup>(writing)</sup>

<details>
<summary>Use structured binding to initialize multiple entities:</summary>

```cpp
#include <iostream>
#include <map>

int main()
{
    std::map<int, char const*> letters;
    letters.insert({0, "first"});
    letters.insert({1, "second"});
    letters.insert({2, "third"});

    for (const auto& [index, letter]: letters)
        std::cout << index << ": " << letter << "\n";
}
```
</details>

* [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding "cpp/language/structured_binding")

<details>
<summary>Use const and reference qualifiers with structured binding:</summary>

```cpp
struct some_data
{
    int age;
    char const* name;
};

int main()
{
    some_data personal_data{27, "Brian"};

    auto const& [a1, n1] = personal_data; // const reference
    auto const [a2, n2] = personal_data; // const
    auto& [a3, n3] = personal_data; // non-const reference
    auto [a4, n4] = personal_data; // copy
}
```
</details>

<details>
<summary>Use move semantics with structured bindings:</summary>

```cpp
#include <string>

struct some_data
{
    std::string text;
};

int main()
{
    some_data data{"long text"};

    // entity is rvalue reference to data.text
    auto&& [rv_text] = std::move(data);

    // new entity stole the membership of value from data.text
    std::string text = std::move(rv_text);

    // rv_text and data.text no longer hold values
}
```
</details>

<details>
<summary>Use class and structures in structured bindings:</summary>

* All non-static data members must be members of the same class definition.

```cpp
struct A
{
    int a = 1;
    int b = 2;
};

struct B : A
{
};

struct C : A
{
    int c = 3;
};

int main()
{
    auto [x, y] = B{};
    auto [i, j, k] = C{}; // ERROR
}
```
</details>

<details>
<summary>Use raw arrays in structured binding:</summary>

* For an array passed as argument, this is not possible because it decays to the corresponding pointer type.

```cpp
int main()
{
    int array[] = {1,2,3};
    auto [i, j, k] = array;
}
```
</details>

<details>
<summary>Use `std::pair`, `std::tuple`, and `std::array` in structured binding:</summary>

```cpp
#include <utility>
#include <string>
#include <tuple>
#include <array>

int main()
{
    std::array<int, 3> coordinates{1,0,1};
    auto [x, y, z] = coordinates;

    std::pair<int, std::string> letter{1, "some text"};
    auto& [index, text] = letter;

    std::tuple<long, std::string> book{9783967300178, "C++17: The Complete Guide"};
    auto const& [isbn, title] = book;
}
```
</details>

<details>
<summary>Make a custom type compatible with tuple interface to be used in structured binding<span style="color:red">(incomplete,page 14)</span>:</summary>

```cpp
```
</details>

## Chapter 2/29
## Chapter 3/29
## Chapter 4/29
## Chapter 5/29
## Chapter 6/29
## Chapter 7/29
## Chapter 8/29
## Chapter 9/29
## Chapter 10/29

<details>
<summary>Write a C++ function to decide at compile time wether it should return a passed string, call <code>std::to_string()</code> for a passed integral or floating-point value, or try to convert the passed argument to std::string.</summary>

> ```cpp
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 10

> References:
---
</details>

## Chapter 11/29
## Chapter 12/29
## Chapter 13/29
## Chapter 14/29
## Chapter 15/29

<details>
<summary>What object can be used in C++ STL to have a value with certain type or not have any value at all?</summary>

> `std::optional<>` model a nullable instance of an arbitrary type.
>
> ```cpp
> #include <optional>
>
> std::optional<int> oi{42};
> int i{*oi}; // 42
> ``````

> Origin: 15.1

> References:
---
</details>

<details>
<summary>How can <code>std::optional<></code> be used as return values?</summary>

> ```cpp
#include <optional>
#include <string_view>

std::optional<int> asInt(const std::string_view s)
{
    try
    {
        return std::stoi(s);
    }
    catch (...)
    {
        return std::nullopt;
    }
}

asInt("42");           // std::optional<int>(42)
asInt("077");          // std::optional<int>(42)
asInt("forty two");    // std::nullopt
asInt("0x33");         // std::optional<int>(42)
> ``````

> Origin: 15.1.1

> References:
---
</details>

## Chapter 16/29
## Chapter 17/29
## Chapter 18/29
## Chapter 19/29
## Chapter 20/29 <sup>(writing)</sup>

<details>
<summary>Check if a file is a regular file?</summary>

> ```cpp
> #include <iostream>
> #include <iomanip>
> #include <filesystem>
>
> int main()
> {
>     std::filesystem::path file{"/etc/passwd"};
>     std::cout << std::boolalpha << std::filesystem::is_regular_file(file) << std::endl;
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Check if a file is a directory?</summary>

> ```cpp
> #include <iostream>
> #include <iomanip>
> #include <filesystem>
>
> int main()
> {
>     std::filesystem::path directory{"/etc/default/"};
>     std::cout << std::boolalpha << std::filesystem::is_directory(directory) << std::endl;
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Get the type of a file?</summary>

> ```cpp
> #include <iostream>
> #include <filesystem>
>
> int main()
> {
>     std::filesystem::path file{"/etc/passwd"};
>     std::filesystem::file_status status{std::filesystem::status(file)};
>     std::cout << "file type: ";
>     switch (status.type())
>     {
>         using std::filesystem::file_type;
>         case (file_type::regular):      std::cout << "regular"; break;
>         case (file_type::directory):    std::cout << "directory"; break;
>         case (file_type::block):        std::cout << "block"; break;
>         case (file_type::character):    std::cout << "char"; break;
>         case (file_type::symlink):      std::cout << "symlink"; break;
>         case (file_type::socket):       std::cout << "socket"; break;
>         case (file_type::fifo):         std::cout << "fifo"; break;
>         case (file_type::not_found):    std::cout << "not found"; break;
>         case (file_type::unknown):      std::cout << "unknown"; break;
>         case (file_type::none):         std::cout << "none"; break;
>     }
>     std::cout << "\n";
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Check if a file exists?</summary>

> ```cpp
> #include <iostream>
> #include <iomanip>
> #include <filesystem>
>
> int main()
> {
>     std::filesystem::path existing_file{"/dev/random"};
>     std::filesystem::path non_existing_file{"/dev/none"};
>     std::cout << std::boolalpha << std::filesystem::exists(existing_file) << "\n";
>     std::cout << std::boolalpha << std::filesystem::exists(non_existing_file) << "\n";
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

Create a regular file?

Create a directory inside an existing directory?

Create a tree of nested directories?

Create a symbolic link to a regular file?

Create a symbolic link to a directory?

Iterate over the entries of a directory?

Recursively iterate over directories with following symbolic links?

Remove a file?

Recursively remove a directory and all of its contents?

<details>
<summary>What are the constituents of a path?</summary>

> It consists of an optional *root name*, an optional *root directory*, and a
> sequence of filenames separated by *directory separators*.
>
> `[root name] [root directory] [filenames]`

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>What path formats are available?</summary>

> The path can be **relative**, so that the file location depends on the current directory, or **absolute**.
>
> Two formats are possible for path objects:
>
> - A generic format, which is portable.
> - A native format, which is specific to the underlying file system.
>
> On POSIX compliant operating systems there is not difference between the
> generic and the native format. On Windows the generic format `/tmp/note.txt`
> is a valid native format besides `\tmp\note.txt` which is also supported are
> two native versions of the same path.
>
> The generic path format is as follows:
>
> `[root name] [root directory] [relative path]`
>
> - The optional root name is implementation specific (e.g. `//host` on POSIX systems, `C:` on WIndows systems)
> - The optional root root directory is a directory separator
> - The relative path is a sequence of file names separated by directory separators

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>What are the properties of a normalized path?</summary>

> In a normalized path:
>
> - Filenames are separated only by a single preferred directory separator.
> - The filename `.` is not used unless the whole path is nothing but `.`.
> - The filename does not contain `..` filenames unless they are at the
>   beginning of a relative path.
> - The path only ends with a directory separator if the trailing filename is a
>   directory with a name other than `.` or `..`.

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>What are the differences of member and free-standing functions of path?</summary>

> The filesystem library provides several functions, which can be both member
> and free-standing functions. **Member** functions are cheap because they are
> pure lexical operations that do not take the actual filesystem into account,
> so that no operating system calls are necessary, e.g. `mypath.is_absolute()`.
> **Free-standing** functions on the other hand are expensive, because they
> usually take the actual filesystem into account, e.g. `equivalent(path1,
> path2)`. Sometimes, the filesystem library provides the same functionality
> operating both lexically and by the actual filesystem into account, e.g.
> `path1.lexically_relative(path2)`.
>
> Because of **Argument Dependent Lookup (ADL)** usually we don't have to
> specify the full namespace `std::filesystem` when calling free-standing
> filesystem functions.
>
> ```cpp
> create_directory(std::filesystem::path{"/tmp/notes"}); // OK
> remove(std::filesystem::path{"/tmp/note.txt"}); // OK
>
> std::filesystem::create_directory("/tmp/note.txt"); // OK
> std::filesystem::remove("/tmp/note.txt"); // OK
>
> create_directory("/tmp/notes"); // ERROR
> remove("/tmp/note.txt"); // OOPS: calls C function remove()
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>How many error handling approaches are available on filesystem library?</summary>

> Because dealing with exception is not always appropriate, the filesystem
> library uses a mixed approach when dealing with the filesystem.
>
> Filesystem operations usually have two overloads for each operation.
>
> - By default, the operations throw `std::filesystem_error` exceptions on errors.
> - By passing an additional out parameter, an error code can be used instead.

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Handle a filesystem operation error with exceptions?</summary>

> ```cpp
> #include <iostream>
> #include <filesystem>
>
> int main()
> {
>     try
>     {
>         std::filesystem::create_directory("/tmp/");
>     }
>     catch (std::filesystem::filesystem_error const& exp)
>     {
>         std::cerr << exp.path1() << ": " << exp.what() << std::endl;
>     }
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Handle a filesystem operation error with error code?</summary>

> ```cpp
> #include <iostream>
> #include <filesystem>
>
> int main()
> {
>     std::error_code ec;
>     std::filesystem::create_directory("/tmp/", ec);
>     if (ec)
>     {
>         std::cerr << ec.message() << std::endl;
>     }
>
>     if (ec == std::errc::read_only_file_system)
>     {
>         std::cerr << "directory is read only\n";
>     }
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>What are the supporting different file types?</summary>

> The standard filesystem library defines an enumeration type `file_type`,
> which is standardized to have the following values:
>
> ```cpp
> namespace std::filesystem
> {
>     enum class file_type
>     {
>         regular, directory, symlink,
>         block, character, fifo, socket,
>         ...
>         none, not_found, unknown
>     };
> }
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Create a path with different string types?</summary>

> ```cpp
> #include <string>
> #include <filesystem>
>
> using namespace std::string_literals;
>
> std::filesystem::path{"/dev/null"s};    // std::string
> std::filesystem::path{L"/dev/null"s};   // std::wstring
> std::filesystem::path{u8"/dev/null"s};  // std::u8string
> std::filesystem::path{u16"/dev/null"s}; // std::u16string
> std::filesystem::path{u32"/dev/null"s}; // std::u32string
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Create a path with a range?</summary>

> ```cpp
> #include <string>
> #include <filesystem>
>
> std::string filename{"/dev/random"};
> std::filesystem::path{filename.begin(), filename.end()};
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Get current path of the executing process?</summary>

> Note that `current_path()` is an expensive operation because it is based on
> operating system calls.
>
> ```cpp
> #include <filesystem>
>
> auto working_directory{std::filesystem::current_path()};
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

<details>
<summary>Get the path of temporary directory?</summary>

> ```cpp
> #include <filesystem>
>
> auto temp{std::filesystem::temp_directory_path()};
> ``````

> Origins:
> - C++17: The Complete Guide - Chapter 20

> References:
---
</details>

page 210

## Chapter 21/29
## Chapter 22/29
## Chapter 23/29
## Chapter 24/29
## Chapter 25/29
## Chapter 26/29
## Chapter 27/29
## Chapter 28/29
## Chapter 29/29

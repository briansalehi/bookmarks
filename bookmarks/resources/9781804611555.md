# Hands-On Design Patterns with C++
<img src="covers/9781804611555.jpg" width="200"/>

## Chapter 1/18 <sup>(completed)</sup>

The public interface is like a contract, we promise to the clients of the
class that it supports certain operations, maintains some invariants, and
obeys the specified restrictions. By publicly inheriting from the base
class, we bind the derived class to the same contract (plus any extensions
of the contract, should we decide to define additional public interfaces).

*****

Because the derived class also respects the interface contract of the base
class, we could use a derived class in any place in the code where a base
class is expected, we would not be able to use any of the extensions to the
interface (the code expects the base class, we don't know about any
extensions at that point), but the base class interface and its
restrictions have to be valid.

*****

This is often expressed as the is-a principle, an instance of a derived
class is also an instance of the base class.

*****

A penguin isn't a bird in C++ if the bird interface includes flying. The
correct design for such cases usually includes a more abstract base class,
Bird, that doesn't make any promises that at least one derived class can't
keep (for example, a Bird object doesn't make a guarantee that it can fly).
Then, we create intermediate-based classes, such as FlyingBird and
FlightlessBird, that are derived from the common base class and serve as
base classes for the more specific classes such as Eagle or Penguin.

*****

Because the public inheritance implies the is-a relationship, the language
allows a wide range of conversions between references and pointers to
different classes in the same hierarchy. First of all, a conversion from a
pointer to a derived class into a pointer to the base class is implicit
(this is the same for references):

class Base { ... };
class Derived : public Base { ... };
Derived* d =3D new Derived;
Base* b =3D d;    // Implicit conversion
This conversion is always valid because an instance of the derived class is
also an instance of the base class. The inverse conversion is possible but
has to be made explicit:

Base* b =3D new Derived;     // *b is really Derived
Derived* d =3D b; // Does not compile, not implicit Derived*
Derived* d1 =3D
     static_cast<Derived*>(b);    // Explicit conversion

*****

The static (or implicit) conversion between pointers to base and derived
classes is not quite as straightforward as you might think. The first base
of any object always has the same address as the derived object itself, but
then it gets more complicated. There is generally no standard requirement
on the memory layout of derived classes with multiple bases:

class Base1 { ... };
class Base2 { ... };
class Derived : public Base1, public Base2 { ... };

*****

Derived d;Derived* p =3D &d;
std::cout << "Derived: " << (void*)(p) <<
  " Base1: " << (void*)(static_cast<Base1*>(p)) <<
  " Base2: " << (void*)(static_cast<Base2*>(p)) <<
  std::endl;

*****

The program prints something like this:

Derived: 0x7f97e550 Base1: 0x7f97e550 Base2: 0x7f97e560

*****

You can see that the Base1 object is located at the same address as the
Derived object, and Base2 starts with an offset (16 bytes, in our case).

*****

Now, what do you do if the pointer is null?

*****

void f(Base2* p) {
  if (p !=3D nullptr) do_work(*p);
}
Derived* p =3D nullptr;
f(p); // Will it try to dereference 0x10?

*****

Obviously, this would be very bad, so we can assume that null pointers
remain so.

*****

Derived* p =3D nullptr;
std::cout << "Derived: " << (void*)(p) <<
  " Base1: " << (void*)(static_cast<Base1*>(p)) <<
  " Base2: " << (void*)(static_cast<Base2*>(p)) <<
  std::endl;

*****

This prints the same values for all pointers:

Derived: 0x0 Base1: 0x0 Base2: 0x0

*****

This is the only way to do casts, but it implies that a simple implicit
cast from Derived* to Base* hides inside a conditional computation with a
nullpointer check.

*****

When inheriting privately, the derived classes don't extend the public
interface of the base class, all base class methods become private in the
derived class. Any public interface has to be created by the derived class,
starting from a clean slate. There's no assumption that an object of the
derived class can be used in place of an object of the base class. What the
derived class does get from the base class is the implementation
details, both the methods and the data members can be used by the derived
class to implement its own algorithms. It's said, therefore, that private
inheritance implements a has-a relationship, the derived object has an
instance of the base class contained inside of it.

*****

What, then, might be the reasons to use private inheritance? There are
several possibilities. First of all, it's possible, within the derived
class, to re-expose one of the public member functions of the base class
with the help of a using declaration:

class Container : private std::vector<int> {
  public:
  using std::vector<int>::size;
  ...
};

This can be useful in rare cases, but it's also equivalent to an inline
forwarding function:

class Container {
  private:
  std::vector<int> v_;
  public:
  size_t size() const { return v_.size(); }
  ...
};

*****

Second, a pointer or reference to a derived object can be converted into a
pointer or reference to the base object, but only inside a member function
of the derived class. Again, the equivalent functionality for composition
is provided by taking the address of a data member.

*****

One good reason to use private inheritance has to do with the size of the
composed or derived objects. It isn't uncommon to have base classes that
provide only methods but no data members. Such classes have no data of
their own and, therefore, should not occupy any memory.

*****

class Empty {  public:
  void useful_function();
};
class Derived : private Empty {
  int i;
};    // sizeof(Derived) =3D=3D 4
class Composed {
  int i;
  Empty e;
};    // sizeof(Composed) =3D=3D 8

*****

If we create many derived objects, the memory saved by the empty base
optimization can be significant.

*****

A virtual public function must be declared in the base class:

class FlyingBird : public Bird {  public:
  virtual void fly(double speed, double direction) {
    ... move the bird at the specified speed
        in the given direction ...
  }
  ...
};

*****

If the implementation meets the needs of the derived class, there's no need
to do anything more. But if the derived class needs to change the
implementation, it can override the implementation of the base class:

*****

class Vulture : public FlyingBird {
  public:
  virtual void fly(double speed, double direction) {
    ... move the bird but accumulate
        exhaustion if too fast ...
  }
};

*****

The real type of the object is determined at runtime:

void hunt(FlyingBird& b) {
  b.fly(...);    // Could be Vulture or Eagle
  ...
};
Eagle e;
hunt(e);   // Now b in hunt() is Eagle
           // FlyingBird::fly() is called
Vulture v;
hunt(v);   // Now b in hunt() is Vulture
           // Vulture::fly() is called

*****

In C++, polymorphic objects must have at least one virtual function, and
only the parts of their interface that use virtual functions for some or
all of the implementation are polymorphic.

*****

The declaration of the virtual function and its overrides should be
identical

*****

One exception is that if a virtual function in the base class returns a
pointer or a reference to an object of some type, the override can return a
pointer or a reference to an object derived from that type (this is known
as covariant return types).

*****

A very common special case of polymorphic hierarchies is one where the base
class doesn't have a good default implementation of the virtual function.

*****

In C++, we can refuse to provide any implementation for a virtual function
in the base class.Such functions are called pure virtual, and any base
class that contains a pure virtual function is known as an abstract class:

class FlyingBird {
  public:
  virtual void fly(...) =3D 0;     // Pure virtual function
};

*****

An abstract class defines an interface only; it's the job of the concrete
derived classes to implement it.

*****

Note that, if the arguments differ, the derived class function doesn't
override anything and instead shadows the name of the base class function.
This can lead to subtle bugs where the programmer intended to override a
base class function but didn't copy the declaration correctly:

class Eagle : public FlyingBird {
  public:
  void fly(int speed, double direction);
};

*****

C++11 provides a very useful feature that greatly simplifies finding such
bugs, any function that's intended to be an override of a base class virtual
function can be declared with the override keyword:

class Eagle : public FlyingBird {
  public:
  void fly(int speed, double direction) override;
};

*****

It is also possible to prevent the derived classes from overriding a
virtual function by declaring it final:

class Eagle : public FlyingBird {
  public:
  // All Eagles fly the same way, derived classes BaldEagle
  // and GoldenEagle cannot change this.  void fly(int speed, double
direction) final;
};

*****

Note that the use of the final keyword is rare: it is unusual for the
design to require that from this point on, the customizations should be
disabled in the hierarchy.

*****

The final keyword can also be applied to the entire class: it means that no
more classes can be derived from this one. Again, this is a rare situation.

*****

So, should or shouldn't you use the virtual keyword on overrides?

*****

The following is the recommended practice:

*****

Any virtual function that does not override one in the base class must use
the virtual keyword. This includes both the functions in classes that have
no bases and the functions added in derived classes.

*****

Any other virtual function should not use the virtual keyword. All
overrides should use the override keyword, with the following exception,
which is also another rule.

*****

A final override must use the final keyword and should not use the override
keyword.

*****

Virtual functions can also be used with private inheritance.

*****

class Base {
  public:
  virtual void f() {
      std::cout << "Base::f()" << std::endl;
    }
  void g() { f(); }
};
class Derived : private Base {
  public:
  virtual void f() {
    std::cout << "Derived::f()" << std::endl;
  }
  void h() { g(); }
};
Derived d;
d.h(); // Prints "Derived::f()"

*****

There's no good way to implement similar functionality using composition;
so, if the virtual function behavior is desired, private inheritance is the
only way to go

*****

A class with a virtual method has to have its type encoded into every object

*****

class Base { ... };
class Derived : public Base { ... };
Base* b1 =3D new Derived;     // Really Derived
Base* b2 =3D new Base;   // Not Derived
Derived* d1 =3D dynamic_cast<Derived*>(b1);  // Succeeds
Derived* d2 =3D dynamic_cast<Derived*>(b2);  // d2 =3D=3D nullptr

*****

A function that returns a reference must always return a reference to some
valid object. Since the dynamic cast can't return a reference to a valid
object if the requested type doesn't match the actual type. The only
alternative is to throw an exception.

*****

In C++, a class can be derived from several base classes.

*****

class Eagle : public Bird, public FlyingAnimal { ... };

*****

In this case, the inheritance from both base classes is public, which means
that the derived class inherits both interfaces and must fulfill two
separate contracts.

*****

What happens if both interfaces define a method with the same name? If this
method isn't virtual, then an attempt to invoke it on the derived class is
ambiguous, and the program doesn't compile. If the method is virtual and
the derived class has an override for it, then there's no ambiguity since
the method of the derived class is called. Also, Eagle is now both Birdand
FlyingAnimal:

*****

Eagle* e =3D new Eagle;
Bird* b =3D e;
FlyingAnimal* f =3D e;

*****

Both conversions from the derived class into the base class pointer are
allowed. The reverse conversions must be made explicitly using a static or
a dynamic cast.

*****

If we have a pointer to a FlyingAnimal class that's also a Bird class, can
we cast from one to the other?

*****

Yes, we can with a dynamic cast:

*****

Bird* b =3D new Eagle;   // Also a FlyingAnimal
FlyingAnimal* f =3D dynamic_cast<FlyingAnimal*>(b);

*****

When used in this context, the dynamic cast is sometimes called a
cross-cast, we aren't casting up or down the hierarchy (between derived and
based classes) but across the hierarchy, between the classes on different
branches of the hierarchy tree.

*****

Multiple inheritance is often maligned and disfavored in C++. Much of this
advice is outdated and stems from the time when compilers implemented
multiple inheritance poorly and inefficiently. Today, with modern
compilers, this isn't a concern. It's often said that multiple inheritance
makes the class hierarchy harder to understand and reason about. Perhaps it
would be more accurate to say that it's harder to design a good multiple
inheritance hierarchy that accurately reflects the relations between
different properties, and that a poorly designed hierarchy is difficult to
understand and reason about.

*****

The empty base optimization can be done on multiple empty base classes and
remains a valid reason to use private inheritance, if it applies:

*****

class Empty1 {};
class Empty2 {};
class Derived : private Empty1, private Empty2 {
  int i;
};   // sizeof(Derived) =3D=3D 4
class Composed {
  int i;
  Empty1 e1;
  Empty2 e2;
};   // sizeof(Composed) =3D=3D 8

*****

Multiple inheritance can be particularly effective when the derived class
represents a system that combines several unrelated, non-overlapping
attributes.

## Chapter 2/18 <sup>(completed)</sup>

Function templates are generic functions, unlike regular functions, a
template function does not declare its argument types. Instead, the types
are template parameters:

*****

T increment(T x) { return x + 1; }

*****

increment(5);    // T is int, returns 6
increment(4.2);    // T is double, return 5.2 char c[10];
increment(c);    // T is char*, returns &c[1]

*****

Both non-member and class member functions can be function templates;
however, virtual functions cannot be templates.

*****

In C++20, simple template declarations can be abbreviated: instead of
writing

template<typename T> void f(T t);
we can write

// Example 01a
void f(auto t);

*****

Other than more terse declarations, there is no particular advantage to
this abbreviation, and the feature is quite limited.

*****

auto can be used only as the =E2=80=9Ctop-level=E2=80=9D parameter type; for example, this
is invalid (but allowed by some compilers):

void f(std::vector<auto>& v);
and must still be written as

template<typename T> void f(std::vector<T>& v);

*****

if you need to use template type parameters elsewhere in the function
declaration, you can't abbreviate them:

template<typename T> T f(T t);
Of course, you could declare the return type as auto and use the trailing
return type:

auto f(auto t) -> decltype(t);
but at this point, the template is not really =E2=80=9Cabbreviated.=E2=80=9D

*****

Class templates are classes that use generic types, usually to declare
their data members, but also to declare methods and local variables inside
them:

*****

template<typename T> class ArrayOf2 {
  public:
  T& operator[](size_t i) { return a_[i]; }
  const T& operator[](size_t i) const { return a_[i]; }
  T sum() const { return a_[0] + a_[1]; }
  private:
  T a_[2];
};

*****

This class is implemented once, and can then be used to define an array of
two elements of any type:

ArrayOf2<int> i; i[0] =3D 1; i[1] =3D 5;
std::cout << i.sum();                       // 6
ArrayOf2<double> x; x[0] =3D -3.5; x[1] =3D 4;
std::cout << x.sum();                       // 0.5
ArrayOf2<char*> c; char s[] =3D "Hello";
c[0] =3D s; c[1] =3D s + 2;

*****

The last kind of template in C++ is a variable template, which was
introduced in C++14. This template allows us to define a variable with a
generic type:

*****

template<typename T> constexpr T pi =3D
T(3.14159265358979323846264338327950288419716939937510582097494459230781L);
pi<float>;      // 3.141592
pi<double>;     // 3.141592653589793

*****

template parameters can be values of integer or enumeration types:

*****

template<typename T, size_t N> class Array {
  public:
  T& operator[](size_t i) {
    if (i >=3D N) throw std::out_of_range("Bad index");
     return data_[i];
  }
  private:
  T data_[N];
};
Array<int, 5> a;      // OK
cin >> a[0];
Array<int, a[0]> b;   // Error

*****

The values of non-type parameters that are used to instantiate a template
must be compile-time constants or constexpr values
--
so, for example, pointers to local variables are not allowed.

*****

C++20 allows floating-point and user-defined types for non-type template
parameters; until then, the parameters were limited to integral types,
pointers (including function and member pointers), references, and
enumerations.

*****

non-template parameters combined with constexpr functions: these functions,
first introduced in C++11, are used to define =E2=80=9Cimmediate functions,=E2=80=9D or
functions that are evaluated at compile time. The problem with constexpr
functions is that they may evaluate at compile time but it's not required;
they could also be evaluated at run time:

*****

constexpr size_t length(const char* s) {
  size_t res =3D 0;
  while (*(s++)) ++res;
  return res;
}
std::cout << length("abc") << std::endl;
char s[] =3D "runtime";
std::cout << length(s) << std::endl;

*****

Does the length computation actually happen at compile time?

*****

The only way to be sure is to invoke the function in a compile-time
context, for example:

*****

static_assert(length("abc") =3D=3D 3, ""); // OK
char s[] =3D "runtime";
static_assert(length(s) =3D=3D 7, ""); // Fails

*****

In C++20, the function may be declared consteval instead of constexpr: this
guarantees that the evaluation happens at compile time or not at all

*****

Prior to C++20, we have to get creative. Here is one way to enforce
compile-time execution:

*****

template <auto V>
static constexpr auto force_consteval =3D V;

*****

std::cout << force_consteval<length("abc")> << std::endl;
char s[] =3D "runtime";
std::cout << force_consteval<length(s)> << std::endl;

*****

The second cout statement does not compile because the function length()
cannot be evaluated as an immediate function.

*****

This is a C++17 feature; in C++14 we have to use a rather unelegant macro
to achieve the same result:

*****

template<typename T, T V>
static constexpr auto force_consteval_helper =3D V;
#define force_consteval(V)
force_consteval_helper<decltype(V), (V)>
std::cout << force_consteval(length("abc")) << std::endl;

*****

The second kind of non-type template parameter worth mentioning is a
template template parameter, a template parameter that is itself a template.

*****

This template parameter is substituted, not with a name of a class, but a
name of an entire template.

*****

template<typename T,
         template<typename> typename Container>
class Builder {
  Container<T> data_;
  public:
  void add(const T& t) { data_.push_back(t); }
  void print() const {
    for (const auto& x : data_) std::cout << x << " ";
    std::cout << std::endl;
  }
};

*****

The Builder template declares a class that is used to construct (build) a
container of an arbitrary type T. The container itself does not have a
specific type, it's a template itself.

*****

It can be instantiated with any container template that takes one type
argument:

*****

template<typename T> class my_vector { =E2=80=A6 };
Builder<int, my_vector> b;
b.add(1);
b.add(2);b.print();

*****

Of course, there are additional requirements on the Container template: it
must have a single type parameter T (the rest may be defaulted), it should
be default-constructible, it must have a push_back() method, and so on.

*****

Here is a function template that has two template template parameters:

*****

template <template<typename> class Out_container,
          template<typename> class In_container,
          typename T> Out_container<T>
resequence(const In_container<T>& in_container) {
  Out_container<T> out_container;
  for (auto x : in_container) {
    out_container.push_back(x);
  }
  return out_container;
}

*****

This function takes an arbitrary container as an argument and returns
another container, a different template, but instantiated on the same type,
with the values copied from the input container:

*****

my_vector<int> v { 1, 2, 3, 4, 5 };
template<typename T> class my_deque { =E2=80=A6 };
auto d =3D resequence<my_deque>(v);// my_deque with 1 =E2=80=A6 5

*****

Note that the compiler deduces both the type of the template argument
(In_container as my_vector) and the type of its template parameter (T as
int). Of course, the remaining template parameter Out_container cannot be
deduced (it is not used in any parameters of the template function) and
must be explicitly specified, which fits our intended use.

*****

There is a major limitation on template template parameters that is made
more complex by the fact that different compilers enforce it unevenly
(i.e., some compilers let through the code that should not compile but you
would really like it to). The limitation is that the number of template
parameters specified for the template template must match the number of the
template parameters of the argument. Consider this template function:

template <template<typename> class Container, typename T>
void print(const Container<T>& container) {
  for (auto x : container) { std::cout << x << " "; }
  std::cout << std::endl;
}
std::vector<int> v { 1, 2, 3, 4, 5 };
print(v);
This code may compile, but it depends on the version of the standard and
the compiler's strict adherence to the standard: the std::vector template
has two template parameters, not one. The second parameter is the
allocator; it has a default value, which is why we do not have to specify
the allocator type when declaring a vector object. GCC, Clang, and MSVC all
relax this requirement to some degree (but not to the same degree).
Variadic templates, which we will see later in this chapter, offer another,
more robust solution (at least in C++17 and later).Templates are a kind of
recipe for generating code. Next, we will see how we can convert these
recipes into actual code we can run.

*****

To use a function template to generate a function, we have to specify which
types should be used for all template type parameters. We can just specify
the types directly:

template<typename T> T half(T x) { return x/2; }
int i =3D half<int>(5);

*****

Most of the uses of function templates involve the automatic deduction of
types. Consider the following:

auto x =3D half(8);    // int
auto y =3D half(1.5);    // double

*****

The template type can be deduced only from the template function
arguments, the compiler will attempt to select the type for the T parameter
to match the type of the function argument that is declared with the same
type.

*****

Only the types that are used to declare function arguments can be deduced.
There is no rule that all template type parameters must be somehow present
in the argument list, but any parameters that cannot be deduced must be
explicitly specified:
template<typename U, typename V> U half(V x) {
  return x/2;
}
auto y =3D half<double>(8);
Here, the first template type parameter is explicitly specified, so U is
double, and V is deduced to be int.

*****

Sometimes, the compiler cannot deduce template type parameters, even if
they are used to declare arguments:

template<typename T> T Max(T x, T y) {
  return (x > y) ? x : y;
}
auto x =3D Max(7L, 11); // Error

*****

the compiler does not attempt to find a type for which all argument
conversions are possible: after all, there is usually more than one such
type. In our example, T could be double or unsigned long, and the function
would still be valid. If a type can be deduced from more than one argument,
the result of all these deductions must be the same.Otherwise, the template
instantiation is considered ambiguous.

*****

As we have seen, if a type can be deduced from more than one function
argument, the result of these deductions must be the same. On the other
hand, one argument can be used to deduce more than one type:
template<typename U, typename V>
std::pair<V, U> swap12(const std::pair<U, V>& x) {
  return std::pair<V, U>(x.second, x.first);
}
swap12(std::make_pair(7, 4.2)); // pair of 4.2, 7

*****

This example is unnecessarily verbose, and we can take advantage of a few
more C++ features to make it both more compact and easier to maintain.

*****

template<typename T> auto swap12(const T& x) {
  return std::make_pair(x.second, x.first);
}

*****

Instantiation of class templates is similar to that of function
templates, the use of a template to create a type implicitly instantiates
the template.

*****

template<typename N, typename D> class Ratio {
  public:
  Ratio() : num_(), denom_() {}
  Ratio(const N& num, const D& denom) :
    num_(num), denom_(denom) {}
  explicit operator double() const {
    return double(num_)/double(denom_);
  }
  private:
  N num_;
  D denom_;
};
Ratio<int, double> r;

*****

instantiating a template instantiates all data members, but does not
instantiate the methods until they are used, that allows us to write class
templates where only some of the methods compile for certain types.

*****

Both class and function templates can be explicitly instantiated as well.
Doing so instantiates a template without using it:
template class Ratio<long, long>;
template Ratio<long, long> make_ratio(const long&,
                                      const long&);

*****

Explicit instantiations are rarely needed,

*****

recall the common challenge of static class data members: they must be
defined somewhere, and only once:

// In the header:
class A {
  static int n;
};
// In a C file:
int A::n =3D 0;
std::cout << A::n;
Without such a definition, the program will not link: the name A::n is not
defined. But if the definition is moved into the header and the header is
included in several compilation units, the program also will not link, this
time the name A::n is multiply defined.
The requirement to define static data members exactly once is not feasible
for class templates: we need them defined for every set of template
parameters the template is instantiated with, and we can't do that in any
one compilation unit (other compilation units may instantiate the same
template with different types). Fortunately, this is not necessary. Static
members of class templates can (and should) be defined together with the
template itself:
// In the header:
template<typename T> class A {
  static T n;
};
template<typename T> T A<T>::n {};
While this technically results in multiple definitions, it is the job of
the linker to consolidate them so we are left with a single definition
(there is only one value of a static member variable for all objects of the
same type).
In C++17, inline variables offer a simpler solution:

// In the header:
template<typename T> class A {
  static inline T n {};
};
This also works for non-template classes:

// In the header:
class A {
  static inline int n =3D 0;
};
If the static data member of a class template has a non-trivial
constructor, this constructor is invoked once for every instantiation of
this template (not for every object =E2=80=93 there is only one instance of a
static member variable for all objects of the same type).
Class templates, as we have used them so

*****

Template specializations allow us to make the generated template code
differently for some types, not just the same code with different types
substituted, but completely different code. There are two kinds of template
specializations in C++, explicit, or full, specializations and partial
specialization

*****

In an explicit specialization, all generic types are replaced by specific,
concrete types. Since an explicit specialization is not a generic class or
function, it does not need to be instantiated later. For the same reason,
it is sometimes called full specialization. If the generic types are fully
substituted, there is nothing generic left. An explicit specialization
should not be confused with an explicit template instantiation, while both
create an instantiation of a template for a given set of type arguments, an
explicit instantiation creates an instantiation of the generic code, with
the generic types substituted by the specific types. An explicit
specialization creates an instantiation of the function or class with the
same name but it overrides the implementation, so the resulting code can be
completely different.

*****

template <> class Ratio<double, double> {
  public:
  Ratio() : value_() {}
  template<typename N, typename D>
    Ratio(const N& num, const D& denom) :
      value_(double(num)/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};

*****

Sometimes, we don't need to specialize the whole class template, because
most of the generic code is still applicable. However, we may want to
change the implementation of one or a few member functions. We can
explicitly specialize the member function as well:

template <> Ratio<float, float>::operator double() const {  return
num_/denom_;
}

*****

Template functions can be explicitly specialized as well. Again, unlike an
explicit instantiation, we get to write the body of the function, and we
can implement it any way we want:

template<typename T> T do_something(T x) {
  return ++x;
}
template <> double do_something<double>(double x) {
  return x/2;
}
do_something(3);        // 4
do_something(3.0);    // 1.5
We cannot, however, change the number or the types of arguments or the
return type, they must match the result of the substitution of the generic
types, so the following does not compile:

template <> long do_something<int>(int x) { return x*x; }

*****

An explicit specialization must be declared before the first use of the
template that would cause an implicit instantiation of the generic template
for the same types. This makes sense, the implicit instantiation would
create a class or a function with the same name and the same types as the
explicit specialization. We would now have two versions of the same class
or function in the program, and this violates the one definition rule and
makes the program ill-formed (the exact rules can be found in the standard
under [basic.def.odr]).

*****

Explicit specializations are useful when we have one or a few types for
which we need the template to behave very differently. However, this does
not solve our problem with the ratio of pointers, we want a specialization
that is still somewhat generic, that is, it can handle pointers to any
types, just not any other types. This is accomplished by a partial
specialization

*****

When a class template is partially specialized, it remains as generic code,
but less generic than the original template. The simplest form of a partial
template is one where some of the generic types are replaced by concrete
types, but other types remain generic:

template<typename N, typename D> class Ratio {
  .....
};
template<typename D> class Ratio<double, D> {
  public:
  Ratio() : value_() {}
  Ratio(const double& num, const D& denom) :
    value_(num/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};

*****

When the template is instantiated, the best specialization for the given
set of types is selected.

*****

then the general template has to be instantiated, there are no other choices.

*****

what happens if both terms are double? In this case, the two partial
specializations are equivalent; neither is more specific than the other.
This situation is considered ambiguous and the instantiation fails. Note
that only this particular instantiation, Ratio<double, double>, fails, it is
not an error (at least, not a syntax error) to define both specializations,
but it is an error to request an instantiation that cannot be uniquely
resolved to the narrowest specialization. To allow any instantiation of our
template, we have to remove this ambiguity, and the only way to do that is
to provide an even more narrow specialization that would be preferred over
the other two. In our case, there is only one option, a full specialization
for Ratio<double, double>:
template <> class Ratio<double, double> {
  public:
  Ratio() : value_() {}
  template<typename N, typename D>
    Ratio(const N& num, const D& denom) :
      value_(double(num)/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};

*****

Partial specializations do not have to specify some of the generic types
fully. Therefore, can keep all types generic, but impose some restrictions
on them. For example, we still want a specialization where both the
numerator and the denominator are pointers. They can be pointers to
anything, so they are generic types, but less generic than the arbitrary
types of the general template:

template<typename N, typename D> class Ratio<N*, D*> {
  public:
  Ratio(N* num, D* denom) : num_(num), denom_(denom) {}
  explicit operator double() const {
    return double(*num_)/double(*denom_);
  }
  private:  N* const num_;
  D* const denom_;
};
int i =3D 5; double x =3D 10;
auto r(make_ratio(&i, &x));        // Ratio<int*, double*>
double(r);                    // 0.5
x =3D 2.5;
double(r);                    // 2

*****

To define a specialization, a general template must first be declared. It
does not, however, need to be defined, it is possible to specialize a
template that does not exist in the general case. To do so, we must
forward-declare the general template, then define all the specializations
we need:

template<typename T> class Value; // Declaration
template<typename T> class Value<T*> {
  public:
  explicit Value(T* p) : v_(*p) {} private:
  T v_;
};
template<typename T> class Value<T&> {
  public:
  explicit Value(T& p) : v_(p) {}
  private:
  T v_;
};
int i =3D 5; int* p =3D &i; int& r =3D i;
Value<int*> v1(p); // T* specialization
Value<int&> v2(r); // T& specialization

*****

a partial function template specialization does not exist in C++. What is
sometimes incorrectly called a partial specialization is nothing more than
overloading template functions.

*****

Template function overloading

*****

If the arguments are a perfect match for one of the overloaded functions
with the given name, that function is called. Otherwise, the compiler
considers conversions to the parameter types of the available functions. If
one of the functions offers better conversions, that function is selected.
Otherwise, the call is ambiguous

*****

The precise definition of what constitutes the best conversion can be found
in the standard (see the section Overloading, more specifically, subsection
[over.match]).

*****

if there is a non-template function that is a near-perfect match to the
call arguments, that function is selected. The standard, of course, uses
much more precise terms than near-perfect, but trivial conversions, such as
adding const, fall under that category, you get them at no cost. If there is
no such function, the compiler will attempt to instantiate all function
templates with the same name to a near-perfect match, using the template
argument deduction. If exactly one of the templates was instantiated, the
function created by this instantiation is called. Otherwise, overload
resolution continues the usual way among the non-template functions.

*****

This is a very simplified description of a very complex process, but there
are two important points, firstly, if there is an equally good match of a
call to a template and a non-template function, the non-template function
is preferred, and secondly, the compiler does not attempt to instantiate
the function templates into something that might be convertible to the
types we need. The template functions must match the call almost perfectly
after the argument type deduction, or they are not called at all.

*****

void whatami(int x); // Same as above
void whatami(long x); // Same as above
template<typename T> void whatami(T* x) {
  std::cout << x << " is a pointer" << std::endl;
}
int i =3D 5;
whatami(i);    // 5 is int
whatami(&i);    // 0x???? is a pointer

*****

Here, we have what looks like a partial specialization of a function
template. But it really isn't, it is just a function template

*****

The template can have its type deduced if the argument is a pointer of any
kind. This includes a pointer to const, T could be a const type, so if we
call whatami(ptr), where ptr is const int*, that first template overload is
a perfect match when T is const int. If the deduction succeeds, the
function generated by the template, that is, the template instantiation, is
added to the overload set.For the int* argument, it is the only overload
that works, so it is called.

*****

what happens if more than one function template can match the call, and
both instantiations are valid overloads?

*****

void whatami(int x); // Same as above
void whatami(long x); // Same as above
template<typename T> void whatami(T* x); // Same as above
template<typename T> void whatami(T&& x) {
  std::cout << "Something weird" << std::endl;
}
class C {    };
C c;
whatami(c);    // Something weird
whatami(&c);    // 0x???? is a pointer

*****

This template function accepts its arguments by the universal reference, so
it can be instantiated for any call to whatami() with one argument. The
first call, whatami(c), is easy, the last overload, with T&&, is the only
one that can be called. There are no conversions from c to a pointer or an
integer. But the second call is tricky, we have not one, but two template
instantiations that are a perfect match for the call, with no conversions
needed. So why is this not an ambiguous overload? Because the rules for
resolving overloaded function templates are different than the rules for
non-template functions and resemble the rules for selecting the partial
specialization of a class template (which is another reason why function
template overloads are often confused with partial specializations). The
template that is more specific is a better match.In our case, the first
template is more specific, it can accept any pointer argument, but only
pointers. The second template can accept any argument at all, so any time
the first template is a possible match, the second is too, but not the
reverse. If a more specific template can be used to instantiate a function
that is a valid overload, then this template is used.
Otherwise, we have to fall back to the more general template.

*****

The very general template functions in the overload set sometimes lead to
unexpected results. Let's say we have the following three overloads for
int, double, and anything:

void whatami(int x) {
  std::cout << x << " is int" << std::endl;
}
void whatami(double x) {
  std::cout << x << " is double" << std::endl;
}
template<typename T> void whatami(T&& x) {
  std::cout << "Something weird" << std::endl;
}
int i =3D 5;
float x =3D 4.2;
whatami(i);    // i is int
whatami(x);    // Something weird
whatami(1.2);    // 1.2 is doubleThe first call has an int argument, so
whatami(int) is a perfect match. The second call would have gone to
whatami(double) if we did not have the template overload, the conversion
from float to double is implicit (so is the conversion from float to int,
but the conversion to double is preferred). But it's still a conversion, so
when the function template instantiates to a perfect match of
whatami(float&&), that is the best match and the chosen overload. The last
call has a double argument, and again we have a perfect match to a
non-template function whatami(double), so it is preferred over any
alternative.

*****

overloading pass-by-value and pass-by-reference functions for the same
parameter types often creates ambiguities in overload resolution. For
example, these two functions are almost always ambiguous:

template<typename T> void whatami(T&& x) {  std::cout << "Something weird"
<< std::endl;
}
template<typename T> void whatami(T x) {
  std::cout << "Something copyable" << std::endl;
}
class C {};
C c;
whatami(c);

*****

A variadic function is declared with ... instead of arguments, and it can
be called with any number of arguments of any type

*****

This function is the overload of the last resort, it is called only if no
other overloads can be used:

void whatami(...) {
  std::cout << "It's something or somethings" << std::endl;
}

*****

C++11 introduced the modern equivalent to a variadic function, a variadic
template. We can now declare a generic function with any number of
arguments:

template<typename ... T> auto sum(const T& ... x);

*****

How do we actually implement the function to add up the unknown number of
values whose types we can't name, not even as generic types? In C++17, it's
easy, because it has fold expressions:
// Example 08a
template<typename ... T> auto sum(const T& ... x) {
  return (x + ...);
}
sum(5, 7, 3);        // 15, int
sum(5, 7L, 3);        // 15, long
sum(5, 7L, 2.9);        // 14.9, double

*****

In C++14, as well as in C++17, when a fold expression is not sufficient
(and they are useful only in limited contexts, mostly when the arguments
and combines using binary or unary operators), the standard technique is
recursion, which is ever-popular in template programming:

*****

template<typename T1> auto sum(const T1& x1) {
  return x1;
}
template<typename T1, typename ... T>
auto sum(const T1& x1, const T& ... x) {
  return x1 + sum(x ...);
}

*****

The recursion continues until there is only one argument left, at which
point the other overload is called and the recursion stops. This is the
standard technique for unraveling the parameter packs in variadic templates

*****

The compiler will inline all the recursive function calls and generate
straightforward code that adds all arguments together.

*****

The recursion has to be terminated when there is only one type parameter
left. This is done using a partial specialization, so we will leave the
general template we showed previously as a declaration only, and define a
specialization for one type parameter:
template<typename ... T> struct Group;
template<typename T1> struct Group<T1> {
  T1 t1_;
  Group() =3D default;
  explicit Group(const T1& t1) : t1_(t1) {}
  explicit Group(T1&& t1) : t1_(std::move(t1)) {}
  explicit operator const T1&() const { return t1_; }
  explicit operator T1&() { return t1_; }
};

*****

This class holds the value of one type, T1, initializes it by copy or move
and returns a reference to it when converted to the T1 type. The
specialization for an arbitrary number of type parameters contains the
first one as a data member, together with the corresponding initialization
and conversion methods, and inherits from the Group class template of the
remaining types:

*****

template<typename T1, typename ... T>
struct Group<T1, T ...> : Group<T ...> {
  T1 t1_;
  Group() =3D default;
  explicit Group(const T1& t1, T&& ... t) :
    Group<T ...>(std::forward<T>(t) ...), t1_(t1) {}
  explicit Group(T1&& t1, T&& ... t) :
    Group<T...>(std::forward<T>(t)...),
                t1_(std::move(t1)) {}
  explicit operator const T1&() const { return t1_; }
  explicit operator T1&() { return t1_; }
};

*****

, we can use our Group class template to hold some values of different
types (it cannot handle multiple values of the same type since the attempt
to retrieve this type would be ambiguous):

Group<int, long> g(3, 5);
int(g);    // 3
long(g);    // 5
It is rather inconvenient to write all the group types explicitly and to
make sure they match the argument types.

*****

In C++17, we can use a deduction guide to enable class template parameter
deduction from the constructor:

template<typename ... T> Group(T&&... t) -> Group<T...>;
Group g(3, 2.2, std::string("xyz"));
int(g);            // 3
double(g);            // 2.2
std::string(g);        // "xyz"
Before C++17, the usual solution to this problem is to use a helper
function template (a variadic template, of course) to take advantage of the
template argument deduction:
template<typename ... T> auto makeGroup(T&& ... t) {
  return Group<T ...>(std::forward<T>(t) ...);
}
auto g =3D makeGroup(3, 2.2, std::string("xyz"));

*****

Variadic templates can have non-type parameters as well;

*****

Often, these non-type parameter packs are used in combination with auto
(deduced) types. For example, here is a template that holds a list of
compile-time constant values of different types:

// Example 10
template <auto... Values> struct value_list {};
Without auto (i.e., prior to C++17) it is almost impossible to declare such
a template since the types must be explicitly specified. Note that this is
the entire template: it holds the constant values as a part of its
definition. To extract them, we need another variadic template:

template <size_t N, auto... Values>
struct nth_value_helper;
template <size_t n, auto v1, auto... Values>
struct nth_value_helper<n, v1, Values...> {  static constexpr auto value =3D
    nth_value_helper<n - 1, Values...>::value;
};
template <auto v1, auto... Values>
struct nth_value_helper<0, v1, Values...> {
  static constexpr auto value =3D v1;
};
template <size_t N, auto... Values>
constexpr auto nth_value(value_list<Values...>) {
  return nth_value_helper<N, Values...>::value;
}

*****

The template function nth_value deduces the parameter pack Values from the
type of the value_list argument (the argument itself contains no data and
is of no interest except for its type). A recursive instantiation of
partial class specializations is then used to iterate over the parameter
pack until we get to the N-th value. Note that to store floating-point
constants in this manner, we need C++20.

*****

Variadic templates can be used in combination with template template
parameters to resolve some of the problems created when, for example,
standard library containers are used as arguments substituted for template
template parameters. A simple solution is to declare the parameter as
taking any number of types:

template <template<typename...> class Container,
         typename... T>
void print(const Container<T...>& container);
std::vector<int> v{ =E2=80=A6 };
print(v);
Note that the std::vector template has two type parameters. In C++17, a
standard change made this a valid match for the parameter pack specified in
the Container template template parameter. Most compilers allowed such
matches even earlier.

*****

Lambda expressions are most commonly used as local functions. However, they
are not really functions; they are callable objects, and so they are
missing one feature that functions have, the ability to overload them.

*****

Lambda expressions are objects, their types are classes, so we can inherit
from them too. If a class inherits publicly from a base class, all public
methods of the base class become public methods of the derived class. If a
class inherits publicly from several base classes (multiple inheritance),
its public interface is formed from all the public methods of all the base
classes. If there are multiple methods with the same name in this set, they
become overloaded and the usual overloading resolution rules apply (in
particular, it is possible to create an ambiguous set of overloads, in
which case the program will not compile).
So, we need to create a class that automatically inherits from any number
of base classes. We have just seen the right tool for that, variadic
templates.

*****

template<typename ... F> struct overload_set;
template<typename F1>
struct overload_set<F1> : public F1 {
  overload_set(F1&& f1) : F1(std::move(f1)) {}
  overload_set(const F1& f1) : F1(f1) {}
  using F1::operator();
};
template<typename F1, typename ... F>
struct overload_set<F1, F ...> :
    public F1, public overload_set<F ...> {
  overload_set(F1&& f1, F&& ... f) :
    F1(std::move(f1)),
    overload_set<F ...>(std::forward<F>(f) ...) {}
  overload_set(const F1& f1, F&& ... f) :
    F1(f1), overload_set<F ...>(std::forward<F>(f) ...) {}
  using F1::operator();
  using overload_set<F ...>::operator();
};
template<typename ... F> auto overload(F&& ... f) {
  return overload_set<F ...>(std::forward<F>(f) ...);
}

*****

Here is the C++17 version:

*****

template<typename ... F>
struct overload_set : public F ... {
  overload_set(F&& ... f) : F(std::forward<F>(f)) ... {}
  using F::operator() ...;    // C++17
};
template<typename ... F> auto overload(F&& ... f) {
  return overload_set<F ...>(std::forward<F>(f) ...);
}

*****

The variadic template does not rely on partial specializations anymore;
instead, it inherits directly from the parameter pack (this part of the
implementation works in C++14 as well, but the using declaration needs
C++17).

*****

We can get rid of the template function as well and use template deduction
guides:

// Example 12c
template<typename ... F>
struct overload : public F ... {
  using F::operator() ...;
};
template<typename ... F> // Deduction guideoverload(F&& ... ) ->
overload<F ...>;The use of the overload template remains largely unchanged;
note the curly braces used to construct an object:

int i =3D 5;
double d =3D 7.3;
auto l =3D overload{
  [](int* i) { std::cout << "i=3D" << *i << std::endl; },
  [](double* d) { std::cout << "d=3D" << *d << std::endl; },
};
l(&i);    // i=3D5
l(&d);    // d=3D5.3

*****

In C++20, templates (both class and function templates), as well as
non-template functions (members of class templates, usually) may use a
constraint to specify the requirements on template arguments. These
constraints are useful to produce better error messages, but they are truly
indispensable when there is a need to select a function overload or a
template specialization based on some properties of template arguments.

*****

The basic syntax for a constraint is quite simple: a constraint is
introduced by the keyword requires which can be specified after the
function declaration or before the return type

*****

template<typename T> T copy(T&& t)
  requires (sizeof(T) > 1)
{
  return std::forward<T>(t);
}

*****

Here the function copy() requires that the type of its argument has a size
of at least two bytes. If we attempt to call this function with a char
argument, the call will not compile. Note that if a constraint is violated,
it is as if the function did not exist for the purposes of a particular
call: if there is another overload, it will be considered next even if,
without the constraint, the overloads were ambiguous.

*****

template<typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
{
  if (t1 < t2) return std::forward<T1>(t1);
  return std::forward<T2>(t2);
}

*****

This is a function similar to std::min, except it takes two arguments of
different types. This creates two potential issues: first, what is the
return type? The return value is one of the two arguments, but there has to
be a single return type. We can use the std::common_type trait from the
<type_traits> header as a reasonable answer: for numeric types, it does the
usual type promotion, for classes, it converts from base class to derived
class if possible, and it respects implicit user-specified conversions. But
there is a second problem: if the expression t1 < t2 does not compile, we
get an error in the body of the function. This is unfortunate because the
error is hard to analyze and may be misleading: it suggests that the body
of the function is implemented incorrectly. We can address the second
concern by adding a static assert:

static_assert(sizeof(t1 < t2) > 0);
This at least makes clear that we intended for the code to not compile if
there is no matching operator<(). Note the weird way we had to formulate
the assert: the expression t1 < t2 itself must, in general, evaluate at run
time, and is just as likely to be false. We need a compile-time value, and
we don't care which argument is less, just that they can be compared. So we
assert something not about the result of the comparison but about the size
of this result: sizeof() is always a compile-time value and the size of
anything is at least 1 in C++. The only way this assertion can fail is if
the expression does not compile at all.This still does not solve the other
part of the problem: the requirement on the argument types is not included
in the interface of the function. The function can be called on any two
types and then may or may not compile. With C++20 constraints, we can move
the requirement from the implicit (compilation failure) or explicit (static
assert) error in the function body to the function declaration and make it
part of the function interface:

*****

template<typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires (sizeof(t1 < t2) > 0)
{
  if (t1 < t2) return std::forward<T1>(t1);
  return std::forward<T2>(t2);
}

*****

it is important to remember that the constraint expression must evaluate to
a bool value; no conversions whatsoever are permitted

*****

template<typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires (sizeof(t1 < t2));
The integer value of sizeof() is always non-zero and would have converted
to true, but not in this context.

*****

There is yet another type of constraint expression, a requires expression,
that is much more powerful and expresses our intent much clearer:

*****

template<typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires (requires { t1 < t2; });

*****

The requires expression begins with the requires keyword followed by braces
{}; it can contain any number of expressions that have to compile, or the
value of the entire requires expression is false (it does not matter what
the results of these expressions are, they just have to be valid C++). You
can also use types, type traits, and combinations of requirements of
different kinds. By a quirk of the language, the parentheses around the
requires expression are optional, which means you can see code like
requires requires { t1 < t2 } where the first and the second requires are
completely different keywords.

*****

The requirements on template types can be quite complex; often, the same
requirements apply in many different templates. Sets of such requirements
can be given names and defined for later use; these named requirements are
called concepts. Each concept is a condition that is evaluated at compile
time when used in a constraint.The syntax for a constraint is similar to a
template:

*****

template<typename T1, typename T2> concept Comparable =3D
  requires(T1 t1, T2 t2) { t1 < t2; };

*****

template<typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires Comparable<T1, T2>;

*****

template<typename T> concept HasXOR =3D
  requires(T a, T b) { a ^ b; };
The concept has a requires expression; every expression inside the curly
braces must compile, otherwise, the requirement of the concept is not met.

## Chapter 3/18
## Chapter 4/18
## Chapter 5/18
## Chapter 6/18
## Chapter 7/18
## Chapter 8/18
## Chapter 9/18
## Chapter 10/18
## Chapter 11/18
## Chapter 12/18
## Chapter 13/18
## Chapter 14/18
## Chapter 15/18
## Chapter 16/18
## Chapter 17/18
## Chapter 18/18
